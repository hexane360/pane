{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-pane","text":"<p><code>pane</code> is a modern data conversion and dataclass library for Python.</p> <p>There are many existing dataclass libraries for Python. <code>pane</code> gains in composibility, flexibility, and simplicity because it treats validating a dataclass as a special case of general type conversion. This base layer is built with robust support for product types, tagged &amp; untagged unions, and custom predicates.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Conversion between arbitrary types</li> <li>Helpful, detailed error messages</li> <li>Conversion to and from dataclasses</li> <li>Optional fields</li> <li>Field renaming</li> <li>Conversion from tuples &amp; dicts</li> <li>Dataclass inheritance</li> <li>Generic dataclasses</li> <li>Condition (field validators)</li> <li>First class typing support</li> <li>Tagged &amp; untagged unions</li> <li>Composable conversion</li> <li>Custom converters and hooks for extension</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><code>pane</code> is available from PyPI. To install:</p> <pre><code>pip install py-pane\n</code></pre> <p><code>pane</code> deliberately has very few depedencies, and has no binary dependencies.</p>"},{"location":"#supported-datatypes","title":"Supported datatypes","text":"<p><code>pane</code> aims to support a broad range of standard library and third-party datatypes. Currently, the following datatypes are supported:</p>"},{"location":"#standard-library","title":"Standard library","text":""},{"location":"#sequencecollection-types","title":"Sequence/collection types:","text":"<ul> <li><code>list</code>/<code>typing.List</code></li> <li><code>tuple</code>/<code>typing.Tuple</code>/<code>typing.Sequence</code>/<code>collections.abc.Sequence</code></li> <li><code>set</code>/<code>typing.Set</code>/<code>collections.abc.Set</code></li> <li><code>frozenset</code>/<code>typing.FrozenSet</code>/<code>collections.abc.FrozenSet</code></li> <li><code>collections.deque</code>/<code>typing.Deque</code></li> </ul>"},{"location":"#tuple-types","title":"Tuple types:","text":"<ul> <li>Heterogeneous: <code>tuple[int, str]</code>/<code>t.Tuple[int, str]</code></li> <li>Homogeneous: <code>tuple[int, ...]</code>/<code>t.Tuple[int, ...]</code></li> <li>Empty: <code>tuple[()]</code>/<code>t.Tuple[()]</code></li> </ul>"},{"location":"#mapping-types","title":"Mapping types:","text":"<ul> <li><code>dict</code>/<code>typing.Dict</code>/<code>typing.Mapping</code>/<code>typing.MutableMapping</code>/<code>collections.abc.Mapping</code>/<code>collections.abc.MutableMapping</code></li> <li><code>collections.defaultdict</code>/<code>typing.DefaultDict</code></li> <li><code>collections.OrderedDict</code>/<code>typing.OrderedDict</code></li> <li><code>collections.Counter</code></li> </ul>"},{"location":"#stringbytes-types","title":"String/bytes types:","text":"<ul> <li><code>str</code></li> <li><code>bytes</code></li> <li><code>bytearray</code></li> </ul>"},{"location":"#numeric-types","title":"Numeric types:","text":"<ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>complex</code></li> <li><code>decimal.Decimal</code></li> <li><code>fraction.Fraction</code></li> </ul>"},{"location":"#datetime-types","title":"Datetime types:","text":"<ul> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> </ul>"},{"location":"#path-like-types","title":"Path-like types:","text":"<ul> <li><code>os.PathLike</code> (currently <code>str</code> only)</li> <li><code>pathlib.Path</code>/<code>pathlib.PurePath</code></li> <li><code>pathlib.WindowsPath</code>/<code>pathlib.PureWindowsPath</code></li> <li><code>pathlib.PosixPath</code>/<code>pathlib.PurePosixPath</code></li> </ul>"},{"location":"#other-scalar-types","title":"Other scalar types:","text":"<ul> <li><code>bool</code></li> <li><code>None</code></li> <li><code>re.Pattern</code>/<code>typing.Pattern</code></li> </ul>"},{"location":"#third-party-datatypes","title":"Third-party datatypes","text":"<ul> <li><code>numpy.ndarray</code>/<code>NDArray[]</code></li> </ul>"},{"location":"#supported-typing-constructs","title":"Supported typing constructs","text":"<p>In addition, <code>pane</code> attempts to fully support modern Python type hints. This includes the following:</p> <ul> <li><code>typing.Union</code></li> <li><code>typing.Optional</code></li> <li><code>typing.TypeVar</code></li> <li><code>typing.Generic</code></li> <li><code>typing.Literal</code></li> <li><code>typing.Any</code></li> <li><code>typing.Annotated</code></li> </ul>"},{"location":"#comparison-to-other-libraries","title":"Comparison to other libraries","text":"<p>Coming soon</p>"},{"location":"api/","title":"<code>pane</code> API Reference","text":"<p>Top-level exports:</p>"},{"location":"api/#pane","title":"<code>pane</code>","text":""},{"location":"api/#pane.DataType","title":"<code>DataType = t.Union[str, bytes, int, bool, float, complex, None, t.Mapping['DataType', 'DataType'], t.Sequence['DataType'], numpy.NDArray[numpy.generic]]</code>  <code>module-attribute</code>","text":"<p>Common data interchange type. <code>into_data</code> converts to this.</p>"},{"location":"api/#pane.Convertible","title":"<code>Convertible = t.Union[DataType, HasConverter, t.AbstractSet[DataType], Fraction, Decimal, datetime.datetime, datetime.date, datetime.time, os.PathLike[str], t.Pattern[str], t.Pattern[bytes], enum.Enum]</code>  <code>module-attribute</code>","text":"<p>Types supported by <code>from_data</code>.</p> <p>Consists of <code>DataType</code> + <code>HasConverter</code> + supported stdlib types.</p>"},{"location":"api/#pane.Positive","title":"<code>Positive = adjective_condition(lambda : v &gt; 0, 'positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be positive</p>"},{"location":"api/#pane.Negative","title":"<code>Negative = adjective_condition(lambda : v &lt; 0, 'negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be negative</p>"},{"location":"api/#pane.NonPositive","title":"<code>NonPositive = adjective_condition(lambda : v &lt;= 0, 'non-positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-positive</p>"},{"location":"api/#pane.NonNegative","title":"<code>NonNegative = adjective_condition(lambda : v &gt;= 0, 'non-negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-negative</p>"},{"location":"api/#pane.Empty","title":"<code>Empty = adjective_condition(lambda : len(v) == 0, 'empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be empty (have no elements)</p>"},{"location":"api/#pane.NonEmpty","title":"<code>NonEmpty = adjective_condition(lambda : len(v) != 0, 'non-empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must not be empty</p>"},{"location":"api/#pane.PaneBase","title":"<code>PaneBase</code>","text":"<p>Base class for all <code>pane</code> dataclasses</p> Source code in <code>pane/classes.py</code> <pre><code>@dataclass_transform(\neq_default=True,\norder_default=True,\nfrozen_default=True,\nkw_only_default=False,\nfield_specifiers=(FieldSpec, field),\n)\nclass PaneBase:\n\"\"\"\n    Base class for all `pane` dataclasses\n    \"\"\"\n__slots__ = ('__pane_set__',)\n__pane_info__: PaneInfo\n\"\"\"Dunder attribute holding [`PaneInfo`][pane.classes.PaneInfo]\"\"\"\n__pane_set__: t.Set[str]\n\"\"\"Dunder attribute holding a set of fields which have been set/modified\"\"\"\ndef __init_subclass__(\ncls,\n*args: t.Any,\nname: t.Optional[str] = None,\nout_format: t.Optional[ClassLayout] = None,\nin_format: t.Optional[t.Sequence[ClassLayout]] = None,\neq: t.Optional[bool] = None,\norder: t.Optional[bool] = None,\nfrozen: t.Optional[bool] = None,\ninit: t.Optional[bool] = None,\nkw_only: t.Optional[bool] = None,\nrename: t.Optional[RenameStyle] = None,\nin_rename: t.Optional[t.Union[RenameStyle, t.Sequence[RenameStyle]]] = None,\nout_rename: t.Optional[RenameStyle] = None,\nallow_extra: t.Optional[bool] = None,\n**kwargs: t.Any,\n):\nold_params = getattr(cls, '__parameters__', ())\nsuper().__init_subclass__(*args, **kwargs)\nsetattr(cls, '__parameters__', old_params + getattr(cls, '__parameters__', ()))\nif rename is not None:\nif in_rename is not None or out_rename is not None:\nraise ValueError(\"'rename' cannot be specified with 'in_rename' or 'out_rename'\")\nin_rename = t.cast(t.Tuple[RenameStyle, ...], (rename,))\nout_rename = rename\nelif in_rename is not None and isinstance(in_rename, str):\nin_rename = t.cast(t.Tuple[RenameStyle, ...], (in_rename,))\n# handle option inheritance\nopts: PaneOptions = getattr(cls, PANE_INFO).opts if hasattr(cls, PANE_INFO) else PaneOptions()\nopts = opts.replace(\nname=name, out_format=out_format, in_format=in_format,\neq=eq, order=order, frozen=frozen, init=init, allow_extra=allow_extra,\nkw_only=kw_only, in_rename=in_rename, out_rename=out_rename,\n)\n_process(cls, opts)\ndef __class_getitem__(cls, params: t.Union[type, t.Tuple[type, ...]]):\nif not isinstance(params, tuple):\nparams = (params,)\nreturn _make_subclass(cls, params)\ndef __repr__(self) -&gt; str:\ninside = \", \".join(f\"{field.name}={getattr(self, field.name)!r}\" for field in self.__pane_info__.fields)\nreturn f\"{self.__class__.__name__}({inside})\"\ndef __setattr__(self, name: str, value: t.Any) -&gt; None:\nopts = self.__pane_info__.opts\nif opts.frozen:\nraise FrozenInstanceError(f\"cannot assign to field {name!r}\")\nsuper().__setattr__(name, value)\nset_fields: t.Set[str] = getattr(self, PANE_SET_FIELDS)\nset_fields.add(name)\ndef __delattr__(self, name: str) -&gt; None:\nraise AttributeError(f\"cannot delete field {name!r}\")\n@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\nif len(args) &gt; 0:\ncls = t.cast(t.Type[T], cls[tuple(args)])  # type: ignore\nreturn t.cast(Converter[T], PaneConverter(cls))\n@classmethod\ndef from_obj(cls, obj: Convertible) -&gt; Self:\n\"\"\"\n        Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n        Parameters:\n          obj: Object to convert. Must be convertible.\n        \"\"\"\nreturn convert(obj, cls)\n@classmethod\ndef from_data(cls, data: DataType) -&gt; Self:\n\"\"\"\n        Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n        Parameters:\n          data: Data to convert. Must be a data interchange type.\n        \"\"\"\nreturn from_data(data, cls)\ndef into_data(self) -&gt; DataType:\n\"\"\"Convert `self` into interchange data\"\"\"\nreturn into_data(self, self.__class__)\ndef dict(self, set_only: bool = False) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n        Return a dict of the fields in `self`\n        Parameters:\n          set_only: If `True`, return only the fields which have been set\n        \"\"\"\nif set_only:\nreturn {\nk : getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n}\nreturn {\nfield.name: getattr(self, field.name) for field in self.__pane_info__.fields\n}\n@classmethod\ndef from_json(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n        Load `cls` from a JSON file `f`\n        Parameters:\n          f: File-like or path-like to load from\n        \"\"\"\nimport json\nwith open_file(f) as f:\nobj = json.load(f)\nreturn cls.from_data(obj)\n@classmethod\ndef from_jsons(cls, s: str) -&gt; Self:\n\"\"\"\n        Load `cls` from a JSON string `s`\n        Parameters:\n          s: JSON string to load from\n        \"\"\"\nimport json\nobj = json.loads(s)\nreturn cls.from_data(obj)\n@classmethod\ndef from_yaml(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n        Load `cls` from a YAML file `f`\n        Parameters:\n          f: File-like or path-like to load from\n        \"\"\"\nimport yaml\ntry:\nfrom yaml import CSafeLoader as Loader\nexcept ImportError:\nfrom yaml import SafeLoader as Loader\nwith open_file(f) as f:\nobj = list(yaml.load_all(f, Loader))\nreturn cls.from_data(obj)\n@classmethod\ndef from_yamls(cls, s: str) -&gt; Self:\n\"\"\"\n        Load `cls` from a YAML string `s`\n        Parameters:\n          s: YAML string to load from\n        \"\"\"\nfrom io import StringIO\nreturn cls.from_yaml(StringIO(s))\n@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n...\n</code></pre>"},{"location":"api/#pane.PaneBase._converter","title":"<code>_converter(*args)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\nif len(args) &gt; 0:\ncls = t.cast(t.Type[T], cls[tuple(args)])  # type: ignore\nreturn t.cast(Converter[T], PaneConverter(cls))\n</code></pre>"},{"location":"api/#pane.PaneBase.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Convert <code>obj</code> into <code>cls</code>. Equivalent to <code>convert(obj, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to convert. Must be convertible.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_obj(cls, obj: Convertible) -&gt; Self:\n\"\"\"\n    Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n    Parameters:\n      obj: Object to convert. Must be convertible.\n    \"\"\"\nreturn convert(obj, cls)\n</code></pre>"},{"location":"api/#pane.PaneBase.from_data","title":"<code>from_data(data)</code>  <code>classmethod</code>","text":"<p>Convert <code>data</code> into <code>cls</code>. Equivalent to <code>from_data(data, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataType</code> <p>Data to convert. Must be a data interchange type.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_data(cls, data: DataType) -&gt; Self:\n\"\"\"\n    Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n    Parameters:\n      data: Data to convert. Must be a data interchange type.\n    \"\"\"\nreturn from_data(data, cls)\n</code></pre>"},{"location":"api/#pane.PaneBase.into_data","title":"<code>into_data()</code>","text":"<p>Convert <code>self</code> into interchange data</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self) -&gt; DataType:\n\"\"\"Convert `self` into interchange data\"\"\"\nreturn into_data(self, self.__class__)\n</code></pre>"},{"location":"api/#pane.PaneBase.dict","title":"<code>dict(set_only=False)</code>","text":"<p>Return a dict of the fields in <code>self</code></p> <p>Parameters:</p> Name Type Description Default <code>set_only</code> <code>bool</code> <p>If <code>True</code>, return only the fields which have been set</p> <code>False</code> Source code in <code>pane/classes.py</code> <pre><code>def dict(self, set_only: bool = False) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n    Return a dict of the fields in `self`\n    Parameters:\n      set_only: If `True`, return only the fields which have been set\n    \"\"\"\nif set_only:\nreturn {\nk : getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n}\nreturn {\nfield.name: getattr(self, field.name) for field in self.__pane_info__.fields\n}\n</code></pre>"},{"location":"api/#pane.PaneBase.from_json","title":"<code>from_json(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_json(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport json\nwith open_file(f) as f:\nobj = json.load(f)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/#pane.PaneBase.from_jsons","title":"<code>from_jsons(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_jsons(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON string `s`\n    Parameters:\n      s: JSON string to load from\n    \"\"\"\nimport json\nobj = json.loads(s)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/#pane.PaneBase.from_yaml","title":"<code>from_yaml(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport yaml\ntry:\nfrom yaml import CSafeLoader as Loader\nexcept ImportError:\nfrom yaml import SafeLoader as Loader\nwith open_file(f) as f:\nobj = list(yaml.load_all(f, Loader))\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/#pane.PaneBase.from_yamls","title":"<code>from_yamls(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>YAML string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yamls(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML string `s`\n    Parameters:\n      s: YAML string to load from\n    \"\"\"\nfrom io import StringIO\nreturn cls.from_yaml(StringIO(s))\n</code></pre>"},{"location":"api/#pane.PaneBase.make_unchecked","title":"<code>make_unchecked(*args, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n...\n</code></pre>"},{"location":"api/#pane.ConvertError","title":"<code>ConvertError</code>","text":"<p>             Bases: <code>Exception</code></p> <p><code>pane</code> conversion error.</p> <p><code>self.tree</code> contains a detailed error tree, and <code>str(self)</code> is a human-friendly representation of the same.</p> Source code in <code>pane/errors.py</code> <pre><code>class ConvertError(Exception):\n\"\"\"\n    `pane` conversion error.\n    `self.tree` contains a detailed error tree, and `str(self)`\n    is a human-friendly representation of the same.\n    \"\"\"\ndef __init__(self, tree: ErrorNode):\nself.tree: ErrorNode = tree\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({self.tree!r})\"\ndef __str__(self) -&gt; str:\nreturn str(self.tree)\n</code></pre>"},{"location":"api/#pane.ConvertError.tree","title":"<code>tree: ErrorNode = tree</code>  <code>instance-attribute</code>","text":""},{"location":"api/#pane.Condition","title":"<code>Condition</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ConvertAnnotation</code></p> Source code in <code>pane/annotations.py</code> <pre><code>@dataclass(frozen=True)\nclass Condition(ConvertAnnotation):\nf: t.Callable[[t.Any], bool]\n\"\"\"\n    Condition/predicate function.\n    This is called with a parsed value, and should return `True` if it passes the condition.\n    \"\"\"\nname: t.Optional[str] = None\n\"\"\"Human-readable name of this condition\"\"\"\nmake_expected: t.Optional[t.Callable[[str, bool], str]] = None\n\"\"\"\n    Given an inner `expected` string, and a boolean indicating plurality, this should return a\n    formatted `expected` string including the condition.\n    This is a low-level function that can be overrided for better error messages.\n    \"\"\"\n# for some reason this isn't auto-generated on python 3.9\ndef __hash__(self):\nreturn hash((\nself.__class__.__name__, self.f, self.name,\n))\ndef __and__(self, other: Condition) -&gt; Condition:\nreturn Condition.all(self, other)\ndef __or__(self, other: Condition) -&gt; Condition:\nreturn Condition.any(self, other)\ndef __invert__(self) -&gt; Condition:\nreturn Condition(\nlambda val: not self.f(val),\nf\"not {self.cond_name()}\"\n)\n@staticmethod\ndef all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n        Create a condition by `and`ing together multiple conditions.\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\nreturn Condition(\nlambda val: all(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\nmake_expected\n)\n@staticmethod\ndef any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n        Create a condition by `or`ing together multiple conditions.\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\nreturn Condition(\nlambda val: any(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\nmake_expected\n)\ndef cond_name(self) -&gt; str:\n\"\"\"Get the name of this condition\"\"\"\nreturn self.name or self.f.__name__\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; ConditionalConverter[t.Any]:\nfrom .converters import ConditionalConverter\nreturn ConditionalConverter(\ninner_type, self.f, self.cond_name(),\nself.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n)\n</code></pre>"},{"location":"api/#pane.Condition.f","title":"<code>f: t.Callable[[t.Any], bool]</code>  <code>instance-attribute</code>","text":"<p>Condition/predicate function.</p> <p>This is called with a parsed value, and should return <code>True</code> if it passes the condition.</p>"},{"location":"api/#pane.Condition.name","title":"<code>name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human-readable name of this condition</p>"},{"location":"api/#pane.Condition.make_expected","title":"<code>make_expected: t.Optional[t.Callable[[str, bool], str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Given an inner <code>expected</code> string, and a boolean indicating plurality, this should return a formatted <code>expected</code> string including the condition.</p> <p>This is a low-level function that can be overrided for better error messages.</p>"},{"location":"api/#pane.Condition.all","title":"<code>all(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>and</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n    Create a condition by `and`ing together multiple conditions.\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\nreturn Condition(\nlambda val: all(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\nmake_expected\n)\n</code></pre>"},{"location":"api/#pane.Condition.any","title":"<code>any(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>or</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n    Create a condition by `or`ing together multiple conditions.\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\nreturn Condition(\nlambda val: any(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\nmake_expected\n)\n</code></pre>"},{"location":"api/#pane.Condition.cond_name","title":"<code>cond_name()</code>","text":"<p>Get the name of this condition</p> Source code in <code>pane/annotations.py</code> <pre><code>def cond_name(self) -&gt; str:\n\"\"\"Get the name of this condition\"\"\"\nreturn self.name or self.f.__name__\n</code></pre>"},{"location":"api/#pane.Condition._converter","title":"<code>_converter(inner_type)</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; ConditionalConverter[t.Any]:\nfrom .converters import ConditionalConverter\nreturn ConditionalConverter(\ninner_type, self.f, self.cond_name(),\nself.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n)\n</code></pre>"},{"location":"api/#pane.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Represents a materialized dataclass field.</p> <p>Typically instantiated from a <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass Field:\n\"\"\"\n    Represents a materialized dataclass field.\n    Typically instantiated from a [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\nname: str\n\"\"\"Name of field\"\"\"\ntype: type\n\"\"\"Type of field. Must be [`Convertible`][pane.convert.Convertible].\"\"\"\nin_names: t.Sequence[str]\n\"\"\"List of names which convert to this field.\"\"\"\nout_name: str\n\"\"\"Name this field converts into.\"\"\"\ninit: bool = True\n\"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\ndefault: t.Union[t.Any, _Missing] = _MISSING\n\"\"\"Default value for field\"\"\"\ndefault_factory: t.Optional[t.Callable[[], t.Any]] = None\n\"\"\"Default value factory for field\"\"\"\nkw_only: bool = False\n\"\"\"Whether field is keyword only\"\"\"\n@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\ndef has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/#pane.Field.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of field</p>"},{"location":"api/#pane.Field.type","title":"<code>type: type</code>  <code>instance-attribute</code>","text":"<p>Type of field. Must be <code>Convertible</code>.</p>"},{"location":"api/#pane.Field.in_names","title":"<code>in_names: t.Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>List of names which convert to this field.</p>"},{"location":"api/#pane.Field.out_name","title":"<code>out_name: str</code>  <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/#pane.Field.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/#pane.Field.default","title":"<code>default: t.Union[t.Any, _Missing] = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/#pane.Field.default_factory","title":"<code>default_factory: t.Optional[t.Callable[[], t.Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/#pane.Field.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/#pane.Field.make","title":"<code>make(name, ty, in_rename=None, out_rename=None)</code>  <code>classmethod</code>","text":"Source code in <code>pane/field.py</code> <pre><code>@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n</code></pre>"},{"location":"api/#pane.Field.has_default","title":"<code>has_default()</code>","text":"<p>Return whether this field has a default value</p> Source code in <code>pane/field.py</code> <pre><code>def has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/#pane.PaneOptions","title":"<code>PaneOptions</code>  <code>dataclass</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@dataclasses.dataclass(frozen=True)\nclass PaneOptions:\nname: t.Optional[str] = None\n\"\"\"Dataclass name\"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\neq: bool = True\n\"\"\"Whether to generate `__eq__`/`__ne__` methods\"\"\"\norder: bool = True\n\"\"\"Whether to generate `__gt__`/`__ge__`/`__lt__`/`__le__` methods\"\"\"\nfrozen: bool = True\n\"\"\"Whether dataclass fields are frozen\"\"\"\ninit: bool = True\n\"\"\"Whether to generate `__init__` method\"\"\"\nkw_only: bool = False\n\"\"\"Whether all fields should be keyword-only\"\"\"\nout_format: ClassLayout = 'struct'\n\"\"\"Data format to convert class into\"\"\"\nin_format: t.Sequence[ClassLayout] = ('struct',)\n\"\"\"Set of data formats class is convertible from\"\"\"\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None\n\"\"\"Set of rename styles class is convertible from\"\"\"\nout_rename: t.Optional[RenameStyle] = None\n\"\"\"Rename style to convert class into\"\"\"\nallow_extra: bool = False\n\"\"\"Whether extra fields are allowed in conversion\"\"\"\ndef replace(self, **changes: t.Any):\n\"\"\"Return `self` with the given changes applied\"\"\"\nchanges['name'] = changes.get('name', None)\nreturn dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/#pane.PaneOptions.name","title":"<code>name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dataclass name</p>"},{"location":"api/#pane.PaneOptions.eq","title":"<code>eq: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__eq__</code>/<code>__ne__</code> methods</p>"},{"location":"api/#pane.PaneOptions.order","title":"<code>order: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__gt__</code>/<code>__ge__</code>/<code>__lt__</code>/<code>__le__</code> methods</p>"},{"location":"api/#pane.PaneOptions.frozen","title":"<code>frozen: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether dataclass fields are frozen</p>"},{"location":"api/#pane.PaneOptions.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__init__</code> method</p>"},{"location":"api/#pane.PaneOptions.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether all fields should be keyword-only</p>"},{"location":"api/#pane.PaneOptions.out_format","title":"<code>out_format: ClassLayout = 'struct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data format to convert class into</p>"},{"location":"api/#pane.PaneOptions.in_format","title":"<code>in_format: t.Sequence[ClassLayout] = ('struct')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of data formats class is convertible from</p>"},{"location":"api/#pane.PaneOptions.in_rename","title":"<code>in_rename: t.Optional[t.Sequence[RenameStyle]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of rename styles class is convertible from</p>"},{"location":"api/#pane.PaneOptions.out_rename","title":"<code>out_rename: t.Optional[RenameStyle] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rename style to convert class into</p>"},{"location":"api/#pane.PaneOptions.allow_extra","title":"<code>allow_extra: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether extra fields are allowed in conversion</p>"},{"location":"api/#pane.PaneOptions.replace","title":"<code>replace(**changes)</code>","text":"<p>Return <code>self</code> with the given changes applied</p> Source code in <code>pane/classes.py</code> <pre><code>def replace(self, **changes: t.Any):\n\"\"\"Return `self` with the given changes applied\"\"\"\nchanges['name'] = changes.get('name', None)\nreturn dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/#pane.val_range","title":"<code>val_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must be between <code>min</code> and <code>max</code> (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def val_range(*, min: t.Union[int, float, None] = None, max: t.Union[int, float, None] = None) -&gt; Condition:\n\"\"\"`Condition` indicating that a value must be between `min` and `max` (inclusive).\"\"\"\nconds: t.List[Condition] = []\nif min is not None:\nconds.append(Condition(lambda v: v &gt;= min, f\"v &gt;= {min}\"))\nif max is not None:\nconds.append(Condition(lambda v: v &lt;= max, f\"v &lt;= {max}\"))\nreturn Condition.all(*conds)\n</code></pre>"},{"location":"api/#pane.len_range","title":"<code>len_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must have between <code>min</code> and <code>max</code> elements (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def len_range(*, min: t.Optional[int] = None, max: t.Optional[int] = None) -&gt; Condition:\n\"\"\"`Condition` indicating that a value must have between `min` and `max` elements (inclusive).\"\"\"\nconds: t.List[Condition] = []\nif min is not None:\nconds.append(Condition(lambda v: len(v) &gt;= min, f\"at least {min} {pluralize('elem', min)}\"))\nif max is not None:\nconds.append(Condition(lambda v: len(v) &lt;= max, f\"at most {max} {pluralize('elem', max)}\"))\ncond = Condition.all(*conds, make_expected=lambda exp, plural: f\"{exp} with {cond.cond_name()}\")\nreturn cond\n</code></pre>"},{"location":"api/#pane.into_data","title":"<code>into_data(val, ty=None)</code>","text":"<p>Convert <code>val</code> of type <code>ty</code> into a data interchange format.</p> Source code in <code>pane/convert.py</code> <pre><code>def into_data(val: Convertible, ty: t.Optional[IntoConverter] = None) -&gt; DataType:\n\"\"\"\n    Convert `val` of type `ty` into a data interchange format.\n    \"\"\"\nif ty is None:\nif isinstance(val, _DataType):\nreturn val\nty = type(val)\ntry:\nconv = make_converter(ty)\nexcept TypeError:\nraise TypeError(f\"Can't convert type '{type(val)}' into data.\") from None\nreturn conv.into_data(val)\n</code></pre>"},{"location":"api/#pane.from_data","title":"<code>from_data(val, ty)</code>","text":"<p>Convert <code>val</code> from a data interchange format into type <code>ty</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>def from_data(val: DataType, ty: t.Type[T]) -&gt; T:\n\"\"\"\n    Convert `val` from a data interchange format into type `ty`.\n    \"\"\"\nif not isinstance(val, _DataType):\nraise TypeError(f\"Type {type(val)} is not a valid data interchange type.\")\nconverter = make_converter(ty)\nreturn converter.convert(val)\n</code></pre>"},{"location":"api/annotations/","title":"pane.annotations","text":""},{"location":"api/annotations/#pane.annotations","title":"<code>pane.annotations</code>","text":"<p>Annotations supported by <code>pane.convert()</code> and dataclasses.</p>"},{"location":"api/annotations/#pane.annotations.Positive","title":"<code>Positive = adjective_condition(lambda : v &gt; 0, 'positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be positive</p>"},{"location":"api/annotations/#pane.annotations.Negative","title":"<code>Negative = adjective_condition(lambda : v &lt; 0, 'negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be negative</p>"},{"location":"api/annotations/#pane.annotations.NonPositive","title":"<code>NonPositive = adjective_condition(lambda : v &lt;= 0, 'non-positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-positive</p>"},{"location":"api/annotations/#pane.annotations.NonNegative","title":"<code>NonNegative = adjective_condition(lambda : v &gt;= 0, 'non-negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-negative</p>"},{"location":"api/annotations/#pane.annotations.Finite","title":"<code>Finite = adjective_condition(math.isfinite, 'finite')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be finite</p>"},{"location":"api/annotations/#pane.annotations.Empty","title":"<code>Empty = adjective_condition(lambda : len(v) == 0, 'empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be empty (have no elements)</p>"},{"location":"api/annotations/#pane.annotations.NonEmpty","title":"<code>NonEmpty = adjective_condition(lambda : len(v) != 0, 'non-empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must not be empty</p>"},{"location":"api/annotations/#pane.annotations.ConvertAnnotation","title":"<code>ConvertAnnotation</code>","text":"<p>             Bases: <code>ABC</code>, <code>Hashable</code></p> <p>Abstract annotation supported by <code>pane</code>.</p> Source code in <code>pane/annotations.py</code> <pre><code>class ConvertAnnotation(abc.ABC, t.Hashable):\n\"\"\"\n    Abstract annotation supported by `pane`.\n    \"\"\"\n@abc.abstractmethod\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; Converter[t.Any]:\n...\n</code></pre>"},{"location":"api/annotations/#pane.annotations.ConvertAnnotation._converter","title":"<code>_converter(inner_type)</code>  <code>abstractmethod</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>@abc.abstractmethod\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; Converter[t.Any]:\n...\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Tagged","title":"<code>Tagged</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ConvertAnnotation</code></p> Source code in <code>pane/annotations.py</code> <pre><code>@dataclass(frozen=True)\nclass Tagged(ConvertAnnotation):\ntag: str\n\"\"\"Name of tag. This name will be searched in every Union member\"\"\"\nexternal: t.Union[bool, t.Tuple[str, str]] = False\n\"\"\"\n    Tagged unions can be stored three ways:\n     - Internally tagged (`external=False`, default). In this format, the tags are stored inside of each object: `{tag_name: tag_value, **obj}`\n     - Externally tagged (`external=True`). In this format, the tag is stored as a key outside the rest of the object: `{tag_value: obj}`\n     - Adjacently tagged (`external=(tag_key, value_key)`). In this format, the tag and value are stored under separate items: `{tag_key: tag_value, value_key: obj}`\n    This specification affects conversion into and out symmetrically.\n    \"\"\"\n# for some reason this isn't auto-generated on python 3.9\ndef __hash__(self):\nreturn hash((self.__class__.__name__, self.tag, self.external))\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; Converter[t.Any]:\nfrom .converters import TaggedUnionConverter\norigin = t.get_origin(inner_type)\nif origin is not t.Union:\nraise TypeError(f\"'Tagged' must surround a 'Union' type.\")\ntypes = tuple(flatten_union_args(t.get_args(inner_type)))\nreturn TaggedUnionConverter(types, tag=self.tag, external=self.external)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Tagged.tag","title":"<code>tag: str</code>  <code>instance-attribute</code>","text":"<p>Name of tag. This name will be searched in every Union member</p>"},{"location":"api/annotations/#pane.annotations.Tagged.external","title":"<code>external: t.Union[bool, t.Tuple[str, str]] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Tagged unions can be stored three ways <ul> <li>Internally tagged (<code>external=False</code>, default). In this format, the tags are stored inside of each object: <code>{tag_name: tag_value, **obj}</code></li> <li>Externally tagged (<code>external=True</code>). In this format, the tag is stored as a key outside the rest of the object: <code>{tag_value: obj}</code></li> <li>Adjacently tagged (<code>external=(tag_key, value_key)</code>). In this format, the tag and value are stored under separate items: <code>{tag_key: tag_value, value_key: obj}</code></li> </ul> <p>This specification affects conversion into and out symmetrically.</p>"},{"location":"api/annotations/#pane.annotations.Tagged._converter","title":"<code>_converter(inner_type)</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; Converter[t.Any]:\nfrom .converters import TaggedUnionConverter\norigin = t.get_origin(inner_type)\nif origin is not t.Union:\nraise TypeError(f\"'Tagged' must surround a 'Union' type.\")\ntypes = tuple(flatten_union_args(t.get_args(inner_type)))\nreturn TaggedUnionConverter(types, tag=self.tag, external=self.external)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition","title":"<code>Condition</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ConvertAnnotation</code></p> Source code in <code>pane/annotations.py</code> <pre><code>@dataclass(frozen=True)\nclass Condition(ConvertAnnotation):\nf: t.Callable[[t.Any], bool]\n\"\"\"\n    Condition/predicate function.\n    This is called with a parsed value, and should return `True` if it passes the condition.\n    \"\"\"\nname: t.Optional[str] = None\n\"\"\"Human-readable name of this condition\"\"\"\nmake_expected: t.Optional[t.Callable[[str, bool], str]] = None\n\"\"\"\n    Given an inner `expected` string, and a boolean indicating plurality, this should return a\n    formatted `expected` string including the condition.\n    This is a low-level function that can be overrided for better error messages.\n    \"\"\"\n# for some reason this isn't auto-generated on python 3.9\ndef __hash__(self):\nreturn hash((\nself.__class__.__name__, self.f, self.name,\n))\ndef __and__(self, other: Condition) -&gt; Condition:\nreturn Condition.all(self, other)\ndef __or__(self, other: Condition) -&gt; Condition:\nreturn Condition.any(self, other)\ndef __invert__(self) -&gt; Condition:\nreturn Condition(\nlambda val: not self.f(val),\nf\"not {self.cond_name()}\"\n)\n@staticmethod\ndef all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n        Create a condition by `and`ing together multiple conditions.\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\nreturn Condition(\nlambda val: all(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\nmake_expected\n)\n@staticmethod\ndef any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n        Create a condition by `or`ing together multiple conditions.\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\nreturn Condition(\nlambda val: any(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\nmake_expected\n)\ndef cond_name(self) -&gt; str:\n\"\"\"Get the name of this condition\"\"\"\nreturn self.name or self.f.__name__\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; ConditionalConverter[t.Any]:\nfrom .converters import ConditionalConverter\nreturn ConditionalConverter(\ninner_type, self.f, self.cond_name(),\nself.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.f","title":"<code>f: t.Callable[[t.Any], bool]</code>  <code>instance-attribute</code>","text":"<p>Condition/predicate function.</p> <p>This is called with a parsed value, and should return <code>True</code> if it passes the condition.</p>"},{"location":"api/annotations/#pane.annotations.Condition.name","title":"<code>name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human-readable name of this condition</p>"},{"location":"api/annotations/#pane.annotations.Condition.make_expected","title":"<code>make_expected: t.Optional[t.Callable[[str, bool], str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Given an inner <code>expected</code> string, and a boolean indicating plurality, this should return a formatted <code>expected</code> string including the condition.</p> <p>This is a low-level function that can be overrided for better error messages.</p>"},{"location":"api/annotations/#pane.annotations.Condition.all","title":"<code>all(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>and</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n    Create a condition by `and`ing together multiple conditions.\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\nreturn Condition(\nlambda val: all(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\nmake_expected\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.any","title":"<code>any(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>or</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n\"\"\"\n    Create a condition by `or`ing together multiple conditions.\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\nreturn Condition(\nlambda val: any(cond.f(val) for cond in conditions),\nlist_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\nmake_expected\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.cond_name","title":"<code>cond_name()</code>","text":"<p>Get the name of this condition</p> Source code in <code>pane/annotations.py</code> <pre><code>def cond_name(self) -&gt; str:\n\"\"\"Get the name of this condition\"\"\"\nreturn self.name or self.f.__name__\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition._converter","title":"<code>_converter(inner_type)</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter]) -&gt; ConditionalConverter[t.Any]:\nfrom .converters import ConditionalConverter\nreturn ConditionalConverter(\ninner_type, self.f, self.cond_name(),\nself.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.val_range","title":"<code>val_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must be between <code>min</code> and <code>max</code> (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def val_range(*, min: t.Union[int, float, None] = None, max: t.Union[int, float, None] = None) -&gt; Condition:\n\"\"\"`Condition` indicating that a value must be between `min` and `max` (inclusive).\"\"\"\nconds: t.List[Condition] = []\nif min is not None:\nconds.append(Condition(lambda v: v &gt;= min, f\"v &gt;= {min}\"))\nif max is not None:\nconds.append(Condition(lambda v: v &lt;= max, f\"v &lt;= {max}\"))\nreturn Condition.all(*conds)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.len_range","title":"<code>len_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must have between <code>min</code> and <code>max</code> elements (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def len_range(*, min: t.Optional[int] = None, max: t.Optional[int] = None) -&gt; Condition:\n\"\"\"`Condition` indicating that a value must have between `min` and `max` elements (inclusive).\"\"\"\nconds: t.List[Condition] = []\nif min is not None:\nconds.append(Condition(lambda v: len(v) &gt;= min, f\"at least {min} {pluralize('elem', min)}\"))\nif max is not None:\nconds.append(Condition(lambda v: len(v) &lt;= max, f\"at most {max} {pluralize('elem', max)}\"))\ncond = Condition.all(*conds, make_expected=lambda exp, plural: f\"{exp} with {cond.cond_name()}\")\nreturn cond\n</code></pre>"},{"location":"api/annotations/#pane.annotations.shape","title":"<code>shape(shape)</code>","text":"<p><code>Condition</code> indicating that a value must have a shape <code>shape</code>.</p> <p>Fails on objects that don't have a <code>shape</code> attribute.</p> Source code in <code>pane/annotations.py</code> <pre><code>def shape(shape: t.Sequence[int]) -&gt; Condition:\n\"\"\"\n    `Condition` indicating that a value must have a shape `shape`.\n    Fails on objects that don't have a `shape` attribute.\n    \"\"\"\nname = f\"shape {tuple(shape)}\"\nreturn Condition(\nlambda v: v.shape == shape, name,\nlambda exp, plural: f\"{exp} with {name}\"\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.broadcastable","title":"<code>broadcastable(shape)</code>","text":"<p><code>Condition</code> indicating that a value must be broadcastable to shape <code>shape</code>.</p> <p>Fails on objects that don't have a <code>shape</code> attribute.</p> Source code in <code>pane/annotations.py</code> <pre><code>def broadcastable(shape: t.Sequence[int]) -&gt; Condition:\n\"\"\"\n    `Condition` indicating that a value must be broadcastable to shape `shape`.\n    Fails on objects that don't have a `shape` attribute.\n    \"\"\"\nname = f\"broadcastable to {tuple(shape)}\"\nreturn Condition(\nlambda v: is_broadcastable(v.shape, shape), name,\nlambda exp, plural: f\"{exp} {name}\"\n)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.adjective_condition","title":"<code>adjective_condition(f, adjective, article='a')</code>","text":"<p>Make a condition that can be expressed as a simple adjective (e.g. 'empty' or 'non-empty').</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[Any], bool]</code> <p>Condition/predicate function</p> required <code>adjective</code> <code>str</code> <p>Adjective corresponding to <code>f</code> (e.g. 'empty' or 'non-empty').</p> required <code>article</code> <code>str</code> <p>Article to put in front of <code>adjective</code> (only when not pluralized).</p> <code>'a'</code> Source code in <code>pane/annotations.py</code> <pre><code>def adjective_condition(f: t.Callable[[t.Any], bool], adjective: str, article: str = 'a') -&gt; Condition:\n\"\"\"\n    Make a condition that can be expressed as a simple adjective (e.g. 'empty' or 'non-empty').\n    Parameters:\n      f: Condition/predicate function\n      adjective: Adjective corresponding to `f` (e.g. 'empty' or 'non-empty').\n      article: Article to put in front of `adjective` (only when not pluralized).\n    \"\"\"\nreturn Condition(\nf, adjective,\n# e.g. 'positive ints' if plural else 'a positive int'\nlambda exp, plural: f\"{adjective} {exp}\" if plural else f\"{article} {adjective} {remove_article(exp)}\"\n)\n</code></pre>"},{"location":"api/classes/","title":"pane.classes","text":""},{"location":"api/classes/#pane.classes","title":"<code>pane.classes</code>","text":"<p>Pane dataclasses.</p>"},{"location":"api/classes/#pane.classes.ClassLayout","title":"<code>ClassLayout = t.Literal['tuple', 'struct']</code>  <code>module-attribute</code>","text":"<p>Set of known class layouts for 'in_formats' and 'out_format'.</p>"},{"location":"api/classes/#pane.classes.PANE_INFO","title":"<code>PANE_INFO = '__pane_info__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding <code>PaneInfo</code></p>"},{"location":"api/classes/#pane.classes.PANE_SET_FIELDS","title":"<code>PANE_SET_FIELDS = '__pane_set__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding a set of fields which have been set/modified</p>"},{"location":"api/classes/#pane.classes.PANE_BOUNDVARS","title":"<code>PANE_BOUNDVARS = '__pane_boundvars__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding a dictionary of bound type variables (for generic subclasses only).</p>"},{"location":"api/classes/#pane.classes.POST_INIT","title":"<code>POST_INIT = '__post_init__'</code>  <code>module-attribute</code>","text":"<p>Name of post-init method</p>"},{"location":"api/classes/#pane.classes.PaneBase","title":"<code>PaneBase</code>","text":"<p>Base class for all <code>pane</code> dataclasses</p> Source code in <code>pane/classes.py</code> <pre><code>@dataclass_transform(\neq_default=True,\norder_default=True,\nfrozen_default=True,\nkw_only_default=False,\nfield_specifiers=(FieldSpec, field),\n)\nclass PaneBase:\n\"\"\"\n    Base class for all `pane` dataclasses\n    \"\"\"\n__slots__ = ('__pane_set__',)\n__pane_info__: PaneInfo\n\"\"\"Dunder attribute holding [`PaneInfo`][pane.classes.PaneInfo]\"\"\"\n__pane_set__: t.Set[str]\n\"\"\"Dunder attribute holding a set of fields which have been set/modified\"\"\"\ndef __init_subclass__(\ncls,\n*args: t.Any,\nname: t.Optional[str] = None,\nout_format: t.Optional[ClassLayout] = None,\nin_format: t.Optional[t.Sequence[ClassLayout]] = None,\neq: t.Optional[bool] = None,\norder: t.Optional[bool] = None,\nfrozen: t.Optional[bool] = None,\ninit: t.Optional[bool] = None,\nkw_only: t.Optional[bool] = None,\nrename: t.Optional[RenameStyle] = None,\nin_rename: t.Optional[t.Union[RenameStyle, t.Sequence[RenameStyle]]] = None,\nout_rename: t.Optional[RenameStyle] = None,\nallow_extra: t.Optional[bool] = None,\n**kwargs: t.Any,\n):\nold_params = getattr(cls, '__parameters__', ())\nsuper().__init_subclass__(*args, **kwargs)\nsetattr(cls, '__parameters__', old_params + getattr(cls, '__parameters__', ()))\nif rename is not None:\nif in_rename is not None or out_rename is not None:\nraise ValueError(\"'rename' cannot be specified with 'in_rename' or 'out_rename'\")\nin_rename = t.cast(t.Tuple[RenameStyle, ...], (rename,))\nout_rename = rename\nelif in_rename is not None and isinstance(in_rename, str):\nin_rename = t.cast(t.Tuple[RenameStyle, ...], (in_rename,))\n# handle option inheritance\nopts: PaneOptions = getattr(cls, PANE_INFO).opts if hasattr(cls, PANE_INFO) else PaneOptions()\nopts = opts.replace(\nname=name, out_format=out_format, in_format=in_format,\neq=eq, order=order, frozen=frozen, init=init, allow_extra=allow_extra,\nkw_only=kw_only, in_rename=in_rename, out_rename=out_rename,\n)\n_process(cls, opts)\ndef __class_getitem__(cls, params: t.Union[type, t.Tuple[type, ...]]):\nif not isinstance(params, tuple):\nparams = (params,)\nreturn _make_subclass(cls, params)\ndef __repr__(self) -&gt; str:\ninside = \", \".join(f\"{field.name}={getattr(self, field.name)!r}\" for field in self.__pane_info__.fields)\nreturn f\"{self.__class__.__name__}({inside})\"\ndef __setattr__(self, name: str, value: t.Any) -&gt; None:\nopts = self.__pane_info__.opts\nif opts.frozen:\nraise FrozenInstanceError(f\"cannot assign to field {name!r}\")\nsuper().__setattr__(name, value)\nset_fields: t.Set[str] = getattr(self, PANE_SET_FIELDS)\nset_fields.add(name)\ndef __delattr__(self, name: str) -&gt; None:\nraise AttributeError(f\"cannot delete field {name!r}\")\n@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\nif len(args) &gt; 0:\ncls = t.cast(t.Type[T], cls[tuple(args)])  # type: ignore\nreturn t.cast(Converter[T], PaneConverter(cls))\n@classmethod\ndef from_obj(cls, obj: Convertible) -&gt; Self:\n\"\"\"\n        Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n        Parameters:\n          obj: Object to convert. Must be convertible.\n        \"\"\"\nreturn convert(obj, cls)\n@classmethod\ndef from_data(cls, data: DataType) -&gt; Self:\n\"\"\"\n        Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n        Parameters:\n          data: Data to convert. Must be a data interchange type.\n        \"\"\"\nreturn from_data(data, cls)\ndef into_data(self) -&gt; DataType:\n\"\"\"Convert `self` into interchange data\"\"\"\nreturn into_data(self, self.__class__)\ndef dict(self, set_only: bool = False) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n        Return a dict of the fields in `self`\n        Parameters:\n          set_only: If `True`, return only the fields which have been set\n        \"\"\"\nif set_only:\nreturn {\nk : getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n}\nreturn {\nfield.name: getattr(self, field.name) for field in self.__pane_info__.fields\n}\n@classmethod\ndef from_json(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n        Load `cls` from a JSON file `f`\n        Parameters:\n          f: File-like or path-like to load from\n        \"\"\"\nimport json\nwith open_file(f) as f:\nobj = json.load(f)\nreturn cls.from_data(obj)\n@classmethod\ndef from_jsons(cls, s: str) -&gt; Self:\n\"\"\"\n        Load `cls` from a JSON string `s`\n        Parameters:\n          s: JSON string to load from\n        \"\"\"\nimport json\nobj = json.loads(s)\nreturn cls.from_data(obj)\n@classmethod\ndef from_yaml(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n        Load `cls` from a YAML file `f`\n        Parameters:\n          f: File-like or path-like to load from\n        \"\"\"\nimport yaml\ntry:\nfrom yaml import CSafeLoader as Loader\nexcept ImportError:\nfrom yaml import SafeLoader as Loader\nwith open_file(f) as f:\nobj = list(yaml.load_all(f, Loader))\nreturn cls.from_data(obj)\n@classmethod\ndef from_yamls(cls, s: str) -&gt; Self:\n\"\"\"\n        Load `cls` from a YAML string `s`\n        Parameters:\n          s: YAML string to load from\n        \"\"\"\nfrom io import StringIO\nreturn cls.from_yaml(StringIO(s))\n@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n...\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase._converter","title":"<code>_converter(*args)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\nif len(args) &gt; 0:\ncls = t.cast(t.Type[T], cls[tuple(args)])  # type: ignore\nreturn t.cast(Converter[T], PaneConverter(cls))\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Convert <code>obj</code> into <code>cls</code>. Equivalent to <code>convert(obj, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to convert. Must be convertible.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_obj(cls, obj: Convertible) -&gt; Self:\n\"\"\"\n    Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n    Parameters:\n      obj: Object to convert. Must be convertible.\n    \"\"\"\nreturn convert(obj, cls)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_data","title":"<code>from_data(data)</code>  <code>classmethod</code>","text":"<p>Convert <code>data</code> into <code>cls</code>. Equivalent to <code>from_data(data, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataType</code> <p>Data to convert. Must be a data interchange type.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_data(cls, data: DataType) -&gt; Self:\n\"\"\"\n    Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n    Parameters:\n      data: Data to convert. Must be a data interchange type.\n    \"\"\"\nreturn from_data(data, cls)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.into_data","title":"<code>into_data()</code>","text":"<p>Convert <code>self</code> into interchange data</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self) -&gt; DataType:\n\"\"\"Convert `self` into interchange data\"\"\"\nreturn into_data(self, self.__class__)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.dict","title":"<code>dict(set_only=False)</code>","text":"<p>Return a dict of the fields in <code>self</code></p> <p>Parameters:</p> Name Type Description Default <code>set_only</code> <code>bool</code> <p>If <code>True</code>, return only the fields which have been set</p> <code>False</code> Source code in <code>pane/classes.py</code> <pre><code>def dict(self, set_only: bool = False) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n    Return a dict of the fields in `self`\n    Parameters:\n      set_only: If `True`, return only the fields which have been set\n    \"\"\"\nif set_only:\nreturn {\nk : getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n}\nreturn {\nfield.name: getattr(self, field.name) for field in self.__pane_info__.fields\n}\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_json","title":"<code>from_json(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_json(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport json\nwith open_file(f) as f:\nobj = json.load(f)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_jsons","title":"<code>from_jsons(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_jsons(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON string `s`\n    Parameters:\n      s: JSON string to load from\n    \"\"\"\nimport json\nobj = json.loads(s)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_yaml","title":"<code>from_yaml(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport yaml\ntry:\nfrom yaml import CSafeLoader as Loader\nexcept ImportError:\nfrom yaml import SafeLoader as Loader\nwith open_file(f) as f:\nobj = list(yaml.load_all(f, Loader))\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_yamls","title":"<code>from_yamls(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>YAML string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yamls(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML string `s`\n    Parameters:\n      s: YAML string to load from\n    \"\"\"\nfrom io import StringIO\nreturn cls.from_yaml(StringIO(s))\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.make_unchecked","title":"<code>make_unchecked(*args, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n...\n</code></pre>"},{"location":"api/classes/#pane.classes.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Represents a materialized dataclass field.</p> <p>Typically instantiated from a <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass Field:\n\"\"\"\n    Represents a materialized dataclass field.\n    Typically instantiated from a [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\nname: str\n\"\"\"Name of field\"\"\"\ntype: type\n\"\"\"Type of field. Must be [`Convertible`][pane.convert.Convertible].\"\"\"\nin_names: t.Sequence[str]\n\"\"\"List of names which convert to this field.\"\"\"\nout_name: str\n\"\"\"Name this field converts into.\"\"\"\ninit: bool = True\n\"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\ndefault: t.Union[t.Any, _Missing] = _MISSING\n\"\"\"Default value for field\"\"\"\ndefault_factory: t.Optional[t.Callable[[], t.Any]] = None\n\"\"\"Default value factory for field\"\"\"\nkw_only: bool = False\n\"\"\"Whether field is keyword only\"\"\"\n@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\ndef has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/classes/#pane.classes.Field.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of field</p>"},{"location":"api/classes/#pane.classes.Field.type","title":"<code>type: type</code>  <code>instance-attribute</code>","text":"<p>Type of field. Must be <code>Convertible</code>.</p>"},{"location":"api/classes/#pane.classes.Field.in_names","title":"<code>in_names: t.Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>List of names which convert to this field.</p>"},{"location":"api/classes/#pane.classes.Field.out_name","title":"<code>out_name: str</code>  <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/classes/#pane.classes.Field.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/classes/#pane.classes.Field.default","title":"<code>default: t.Union[t.Any, _Missing] = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/classes/#pane.classes.Field.default_factory","title":"<code>default_factory: t.Optional[t.Callable[[], t.Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/classes/#pane.classes.Field.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/classes/#pane.classes.Field.make","title":"<code>make(name, ty, in_rename=None, out_rename=None)</code>  <code>classmethod</code>","text":"Source code in <code>pane/field.py</code> <pre><code>@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n</code></pre>"},{"location":"api/classes/#pane.classes.Field.has_default","title":"<code>has_default()</code>","text":"<p>Return whether this field has a default value</p> Source code in <code>pane/field.py</code> <pre><code>def has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneInfo","title":"<code>PaneInfo</code>  <code>dataclass</code>","text":"<p>Structure holding internal information about a <code>pane</code> dataclass</p> Source code in <code>pane/classes.py</code> <pre><code>@dataclasses.dataclass\nclass PaneInfo:\n\"\"\"Structure holding internal information about a `pane` dataclass\"\"\"\nopts: PaneOptions\n\"\"\"Dataclass options\"\"\"\nspecs: t.Dict[str, FieldSpec]\n\"\"\"\n    Dict of raw field specifications\n    This is used by subclasses to build [`Field`][pane.field.Field]s\n    \"\"\"\nfields: t.Tuple[Field, ...]\n\"\"\"\n    Tuple of processed [`Field`][pane.field.Field]s\n    \"\"\"\npos_args: t.Tuple[int, int]\n\"\"\"\n    Range of allowed positional argument numbers, `[min, max]` inclusive\n    \"\"\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneInfo.opts","title":"<code>opts: PaneOptions</code>  <code>instance-attribute</code>","text":"<p>Dataclass options</p>"},{"location":"api/classes/#pane.classes.PaneInfo.specs","title":"<code>specs: t.Dict[str, FieldSpec]</code>  <code>instance-attribute</code>","text":"<p>Dict of raw field specifications</p> <p>This is used by subclasses to build <code>Field</code>s</p>"},{"location":"api/classes/#pane.classes.PaneInfo.fields","title":"<code>fields: t.Tuple[Field, ...]</code>  <code>instance-attribute</code>","text":"<p>Tuple of processed <code>Field</code>s</p>"},{"location":"api/classes/#pane.classes.PaneInfo.pos_args","title":"<code>pos_args: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":"<p>Range of allowed positional argument numbers, <code>[min, max]</code> inclusive</p>"},{"location":"api/classes/#pane.classes.PaneOptions","title":"<code>PaneOptions</code>  <code>dataclass</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@dataclasses.dataclass(frozen=True)\nclass PaneOptions:\nname: t.Optional[str] = None\n\"\"\"Dataclass name\"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\neq: bool = True\n\"\"\"Whether to generate `__eq__`/`__ne__` methods\"\"\"\norder: bool = True\n\"\"\"Whether to generate `__gt__`/`__ge__`/`__lt__`/`__le__` methods\"\"\"\nfrozen: bool = True\n\"\"\"Whether dataclass fields are frozen\"\"\"\ninit: bool = True\n\"\"\"Whether to generate `__init__` method\"\"\"\nkw_only: bool = False\n\"\"\"Whether all fields should be keyword-only\"\"\"\nout_format: ClassLayout = 'struct'\n\"\"\"Data format to convert class into\"\"\"\nin_format: t.Sequence[ClassLayout] = ('struct',)\n\"\"\"Set of data formats class is convertible from\"\"\"\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None\n\"\"\"Set of rename styles class is convertible from\"\"\"\nout_rename: t.Optional[RenameStyle] = None\n\"\"\"Rename style to convert class into\"\"\"\nallow_extra: bool = False\n\"\"\"Whether extra fields are allowed in conversion\"\"\"\ndef replace(self, **changes: t.Any):\n\"\"\"Return `self` with the given changes applied\"\"\"\nchanges['name'] = changes.get('name', None)\nreturn dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneOptions.name","title":"<code>name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dataclass name</p>"},{"location":"api/classes/#pane.classes.PaneOptions.eq","title":"<code>eq: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__eq__</code>/<code>__ne__</code> methods</p>"},{"location":"api/classes/#pane.classes.PaneOptions.order","title":"<code>order: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__gt__</code>/<code>__ge__</code>/<code>__lt__</code>/<code>__le__</code> methods</p>"},{"location":"api/classes/#pane.classes.PaneOptions.frozen","title":"<code>frozen: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether dataclass fields are frozen</p>"},{"location":"api/classes/#pane.classes.PaneOptions.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__init__</code> method</p>"},{"location":"api/classes/#pane.classes.PaneOptions.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether all fields should be keyword-only</p>"},{"location":"api/classes/#pane.classes.PaneOptions.out_format","title":"<code>out_format: ClassLayout = 'struct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data format to convert class into</p>"},{"location":"api/classes/#pane.classes.PaneOptions.in_format","title":"<code>in_format: t.Sequence[ClassLayout] = ('struct')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of data formats class is convertible from</p>"},{"location":"api/classes/#pane.classes.PaneOptions.in_rename","title":"<code>in_rename: t.Optional[t.Sequence[RenameStyle]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of rename styles class is convertible from</p>"},{"location":"api/classes/#pane.classes.PaneOptions.out_rename","title":"<code>out_rename: t.Optional[RenameStyle] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rename style to convert class into</p>"},{"location":"api/classes/#pane.classes.PaneOptions.allow_extra","title":"<code>allow_extra: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether extra fields are allowed in conversion</p>"},{"location":"api/classes/#pane.classes.PaneOptions.replace","title":"<code>replace(**changes)</code>","text":"<p>Return <code>self</code> with the given changes applied</p> Source code in <code>pane/classes.py</code> <pre><code>def replace(self, **changes: t.Any):\n\"\"\"Return `self` with the given changes applied\"\"\"\nchanges['name'] = changes.get('name', None)\nreturn dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter","title":"<code>PaneConverter</code>","text":"<p>             Bases: <code>Converter[PaneBase]</code></p> <p><code>Converter</code> for <code>pane</code> dataclasses</p> Source code in <code>pane/classes.py</code> <pre><code>class PaneConverter(Converter[PaneBase]):\n\"\"\"\n    [`Converter`][pane.converters.Converter] for `pane` dataclasses\n    \"\"\"\ndef __init__(self, cls: t.Type[PaneBase]):\nself.cls = cls\nself.name = self.cls.__name__\nself.cls_info: PaneInfo = getattr(self.cls, PANE_INFO)\nself.opts: PaneOptions = self.cls_info.opts\nself.fields: t.Sequence[Field] = self.cls_info.fields\nself.field_converters: t.Sequence[Converter[t.Any]] = [make_converter(field.type) for field in self.fields]\nself.field_map: t.Dict[str, int] = {}\nfor (i, field) in enumerate(self.fields):\nself.field_map[field.name] = i\nfor alias in field.in_names:\nself.field_map[alias] = i\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"Convert dataclass `val` into data interchange, using the correct 'out_format'\"\"\"\nassert isinstance(val, PaneBase)\nif self.opts.out_format == 'tuple':\nreturn tuple(\nconv.into_data(getattr(val, field.name))\nfor (field, conv) in zip(self.fields, self.field_converters)\n)\nelif self.opts.out_format == 'struct':\nreturn {\nfield.out_name: conv.into_data(getattr(val, field.name))\nfor (field, conv) in zip(self.fields, self.field_converters)\n}\nraise ValueError(f\"Unknown 'out_format' '{self.opts.out_format}'\")\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for this converter\"\"\"\nreturn f\"{list_phrase(self.opts.in_format)} {self.name}\"\ndef try_convert(self, val: t.Any) -&gt; PaneBase:\n\"\"\"\n        See [`Converter.try_convert`][pane.converters.Converter.try_convert]\n        Dispatches to [`try_convert_tuple`][pane.classes.PaneConverter.try_convert_tuple]\n        and [`try_convert_struct`][pane.classes.PaneConverter.try_convert_struct]\n        \"\"\"\n# based on type, try to delegate to try_convert_tuple or try_convert_struct\nif isinstance(val, (list, tuple, t.Sequence)):\nval = t.cast(t.Sequence[t.Any], val)\nif 'tuple' not in self.opts.in_format:\nraise ParseInterrupt()\nreturn self.try_convert_tuple(t.cast(t.Sequence[t.Any], val))\nelif isinstance(val, (dict, t.Mapping)):\nif 'struct' not in self.opts.in_format:\nraise ParseInterrupt()\nreturn self.try_convert_struct(t.cast(t.Mapping[str, t.Any], val))\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, WrongLenError, ProductErrorNode, None]:\n\"\"\"\n        See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\n        Dispatches to [`collect_errors_tuple`][pane.classes.PaneConverter.collect_errors_tuple]\n        and [`collect_errors_struct`][pane.classes.PaneConverter.collect_errors_struct]\n        \"\"\"\n# based on type, try to delegate to collect_errors_tuple or collect_errors_struct\nif isinstance(val, (list, tuple, t.Sequence)):\nif 'tuple' not in self.opts.in_format:\nreturn WrongTypeError(self.expected_struct(), val)\nreturn self.collect_errors_tuple(t.cast(t.Sequence[t.Any], val))\nelif isinstance(val, (dict, t.Mapping)):\nval = t.cast(t.Mapping[str, t.Any], val)\nif 'struct' not in self.opts.in_format:\nreturn WrongTypeError(f'tuple {self.name}', val)\nreturn self.collect_errors_struct(t.cast(t.Mapping[str, t.Any], val))\nreturn WrongTypeError(self.name, val)\ndef expected_struct(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for the 'struct' data format\"\"\"\nreturn f\"struct {self.name}\"\ndef try_convert_struct(self, val: t.Mapping[str, t.Any]) -&gt; PaneBase:\n\"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'struct' data format\"\"\"\n# loop through values, and handle accordingly\nvalues: t.Dict[str, t.Any] = {}\nfor (k, v) in t.cast(t.Dict[str, t.Any], val).items():\nif k not in self.field_map:\nif not self.opts.allow_extra:\nraise ParseInterrupt()  # extra key\ncontinue\nfield = self.fields[self.field_map[k]]\nconv = self.field_converters[self.field_map[k]]\nif field.name in values:\nraise ParseInterrupt()  # multiple values for key\nvalues[field.name] = conv.try_convert(v)\nfor field in self.fields:\nif field.name not in values and not field.has_default():\nraise ParseInterrupt()  # missing field\ntry:\nreturn self.cls.make_unchecked(**values)\nexcept Exception:  # error in __post_init__\nraise ParseInterrupt()\ndef collect_errors_struct(self, val: t.Mapping[str, t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n\"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'struct' data format\"\"\"\nvalues: t.Dict[str, t.Any] = {}  # converted field values. Required to check for __post_init__ errors\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {}  # errors in converting fields\nextra: t.Set[str] = set()  # extra fields found\nseen: t.Set[str] = set()   # fields seen already (used to find dupes)\nfor (k, v) in val.items():\nif k not in self.field_map:\nif not self.opts.allow_extra:\nextra.add(k)  # unknown key\ncontinue\nfield = self.fields[self.field_map[k]]\nconv = self.field_converters[self.field_map[k]]\nif field.name in seen:\nchildren[k] = DuplicateKeyError(k, field.in_names)\ncontinue\nseen.add(field.name)\n# this is a little tricky. we need to call convert() rather\n# than collect_errors to grab a successful value\ntry:\nvalues[field.name] = conv.convert(v)\nexcept ConvertError as e:\n# then we can collect errors if that fails.\nchildren[k] = e.tree\nmissing: t.Set[str] = set()\nfor field in self.fields:\nif field.name not in seen and not field.has_default():\nmissing.add(field.name)\nif len(missing) or len(children) or len(extra):\n# return field errors\nreturn ProductErrorNode(self.expected_struct(), children, val, missing, extra)\ntry:\nself.cls.make_unchecked(**values)\nreturn None\nexcept Exception as e:  # error in __post_init__\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(f'struct {self.name}', val, tb)\ndef expected_tuple(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for the 'tuple' data format\"\"\"\nreturn f\"tuple {self.name}\"\ndef try_convert_tuple(self, val: t.Sequence[t.Any]) -&gt; PaneBase:\n\"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'tuple' data format\"\"\"\n(min_len, max_len) = self.cls_info.pos_args\nif min_len &lt; len(val) &gt; max_len:\nraise ParseInterrupt()\nvals: t.List[t.Any] = []\nfor (conv, v) in zip(self.field_converters, val):\nvals.append(conv.try_convert(v))\ntry:\nreturn self.cls.make_unchecked(*vals)\nexcept Exception:  # error in __post_init__\nraise ParseInterrupt()\ndef collect_errors_tuple(self, val: t.Sequence[t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, WrongLenError, None]:\n\"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'tuple' data format\"\"\"\n(min_len, max_len) = self.cls_info.pos_args\nif min_len &lt; len(val) &gt; max_len:\nreturn WrongLenError(f'tuple {self.name}', (min_len, max_len), val, len(val))\nvals: t.List[t.Any] = []\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {}\nfor (i, (conv, v)) in enumerate(zip(self.field_converters, val)):\n# this is a little tricky. we need to call convert() rather\n# than collect_errors to grab a successful value\ntry:\nvals.append(conv.convert(v))\nexcept ConvertError as e:\n# then we can collect errors if that fails.\nchildren[i] = e.tree\nif len(children):\n# return field errors\nreturn ProductErrorNode(self.expected_tuple(), children, val)\ntry:\nself.cls.make_unchecked(*vals)\nreturn None\nexcept Exception as e:  # error in __post_init__\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(f'tuple {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.cls","title":"<code>cls = cls</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.name","title":"<code>name = self.cls.__name__</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.cls_info","title":"<code>cls_info: PaneInfo = getattr(self.cls, PANE_INFO)</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.opts","title":"<code>opts: PaneOptions = self.cls_info.opts</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.fields","title":"<code>fields: t.Sequence[Field] = self.cls_info.fields</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.field_converters","title":"<code>field_converters: t.Sequence[Converter[t.Any]] = [make_converter(field.type) for field in self.fields]</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.field_map","title":"<code>field_map: t.Dict[str, int] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert dataclass <code>val</code> into data interchange, using the correct 'out_format'</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"Convert dataclass `val` into data interchange, using the correct 'out_format'\"\"\"\nassert isinstance(val, PaneBase)\nif self.opts.out_format == 'tuple':\nreturn tuple(\nconv.into_data(getattr(val, field.name))\nfor (field, conv) in zip(self.fields, self.field_converters)\n)\nelif self.opts.out_format == 'struct':\nreturn {\nfield.out_name: conv.into_data(getattr(val, field.name))\nfor (field, conv) in zip(self.fields, self.field_converters)\n}\nraise ValueError(f\"Unknown 'out_format' '{self.opts.out_format}'\")\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>Expected value for this converter</p> Source code in <code>pane/classes.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for this converter\"\"\"\nreturn f\"{list_phrase(self.opts.in_format)} {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> <p>Dispatches to <code>try_convert_tuple</code> and <code>try_convert_struct</code></p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; PaneBase:\n\"\"\"\n    See [`Converter.try_convert`][pane.converters.Converter.try_convert]\n    Dispatches to [`try_convert_tuple`][pane.classes.PaneConverter.try_convert_tuple]\n    and [`try_convert_struct`][pane.classes.PaneConverter.try_convert_struct]\n    \"\"\"\n# based on type, try to delegate to try_convert_tuple or try_convert_struct\nif isinstance(val, (list, tuple, t.Sequence)):\nval = t.cast(t.Sequence[t.Any], val)\nif 'tuple' not in self.opts.in_format:\nraise ParseInterrupt()\nreturn self.try_convert_tuple(t.cast(t.Sequence[t.Any], val))\nelif isinstance(val, (dict, t.Mapping)):\nif 'struct' not in self.opts.in_format:\nraise ParseInterrupt()\nreturn self.try_convert_struct(t.cast(t.Mapping[str, t.Any], val))\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> <p>Dispatches to <code>collect_errors_tuple</code> and <code>collect_errors_struct</code></p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, WrongLenError, ProductErrorNode, None]:\n\"\"\"\n    See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\n    Dispatches to [`collect_errors_tuple`][pane.classes.PaneConverter.collect_errors_tuple]\n    and [`collect_errors_struct`][pane.classes.PaneConverter.collect_errors_struct]\n    \"\"\"\n# based on type, try to delegate to collect_errors_tuple or collect_errors_struct\nif isinstance(val, (list, tuple, t.Sequence)):\nif 'tuple' not in self.opts.in_format:\nreturn WrongTypeError(self.expected_struct(), val)\nreturn self.collect_errors_tuple(t.cast(t.Sequence[t.Any], val))\nelif isinstance(val, (dict, t.Mapping)):\nval = t.cast(t.Mapping[str, t.Any], val)\nif 'struct' not in self.opts.in_format:\nreturn WrongTypeError(f'tuple {self.name}', val)\nreturn self.collect_errors_struct(t.cast(t.Mapping[str, t.Any], val))\nreturn WrongTypeError(self.name, val)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected_struct","title":"<code>expected_struct(plural=False)</code>","text":"<p>Expected value for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def expected_struct(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for the 'struct' data format\"\"\"\nreturn f\"struct {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert_struct","title":"<code>try_convert_struct(val)</code>","text":"<p><code>Converter.try_convert</code> for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert_struct(self, val: t.Mapping[str, t.Any]) -&gt; PaneBase:\n\"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'struct' data format\"\"\"\n# loop through values, and handle accordingly\nvalues: t.Dict[str, t.Any] = {}\nfor (k, v) in t.cast(t.Dict[str, t.Any], val).items():\nif k not in self.field_map:\nif not self.opts.allow_extra:\nraise ParseInterrupt()  # extra key\ncontinue\nfield = self.fields[self.field_map[k]]\nconv = self.field_converters[self.field_map[k]]\nif field.name in values:\nraise ParseInterrupt()  # multiple values for key\nvalues[field.name] = conv.try_convert(v)\nfor field in self.fields:\nif field.name not in values and not field.has_default():\nraise ParseInterrupt()  # missing field\ntry:\nreturn self.cls.make_unchecked(**values)\nexcept Exception:  # error in __post_init__\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors_struct","title":"<code>collect_errors_struct(val)</code>","text":"<p><code>Converter.collect_errors</code> for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors_struct(self, val: t.Mapping[str, t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n\"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'struct' data format\"\"\"\nvalues: t.Dict[str, t.Any] = {}  # converted field values. Required to check for __post_init__ errors\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {}  # errors in converting fields\nextra: t.Set[str] = set()  # extra fields found\nseen: t.Set[str] = set()   # fields seen already (used to find dupes)\nfor (k, v) in val.items():\nif k not in self.field_map:\nif not self.opts.allow_extra:\nextra.add(k)  # unknown key\ncontinue\nfield = self.fields[self.field_map[k]]\nconv = self.field_converters[self.field_map[k]]\nif field.name in seen:\nchildren[k] = DuplicateKeyError(k, field.in_names)\ncontinue\nseen.add(field.name)\n# this is a little tricky. we need to call convert() rather\n# than collect_errors to grab a successful value\ntry:\nvalues[field.name] = conv.convert(v)\nexcept ConvertError as e:\n# then we can collect errors if that fails.\nchildren[k] = e.tree\nmissing: t.Set[str] = set()\nfor field in self.fields:\nif field.name not in seen and not field.has_default():\nmissing.add(field.name)\nif len(missing) or len(children) or len(extra):\n# return field errors\nreturn ProductErrorNode(self.expected_struct(), children, val, missing, extra)\ntry:\nself.cls.make_unchecked(**values)\nreturn None\nexcept Exception as e:  # error in __post_init__\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(f'struct {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected_tuple","title":"<code>expected_tuple(plural=False)</code>","text":"<p>Expected value for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def expected_tuple(self, plural: bool = False) -&gt; str:\n\"\"\"Expected value for the 'tuple' data format\"\"\"\nreturn f\"tuple {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert_tuple","title":"<code>try_convert_tuple(val)</code>","text":"<p><code>Converter.try_convert</code> for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert_tuple(self, val: t.Sequence[t.Any]) -&gt; PaneBase:\n\"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'tuple' data format\"\"\"\n(min_len, max_len) = self.cls_info.pos_args\nif min_len &lt; len(val) &gt; max_len:\nraise ParseInterrupt()\nvals: t.List[t.Any] = []\nfor (conv, v) in zip(self.field_converters, val):\nvals.append(conv.try_convert(v))\ntry:\nreturn self.cls.make_unchecked(*vals)\nexcept Exception:  # error in __post_init__\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors_tuple","title":"<code>collect_errors_tuple(val)</code>","text":"<p><code>Converter.collect_errors</code> for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors_tuple(self, val: t.Sequence[t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, WrongLenError, None]:\n\"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'tuple' data format\"\"\"\n(min_len, max_len) = self.cls_info.pos_args\nif min_len &lt; len(val) &gt; max_len:\nreturn WrongLenError(f'tuple {self.name}', (min_len, max_len), val, len(val))\nvals: t.List[t.Any] = []\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {}\nfor (i, (conv, v)) in enumerate(zip(self.field_converters, val)):\n# this is a little tricky. we need to call convert() rather\n# than collect_errors to grab a successful value\ntry:\nvals.append(conv.convert(v))\nexcept ConvertError as e:\n# then we can collect errors if that fails.\nchildren[i] = e.tree\nif len(children):\n# return field errors\nreturn ProductErrorNode(self.expected_tuple(), children, val)\ntry:\nself.cls.make_unchecked(*vals)\nreturn None\nexcept Exception as e:  # error in __post_init__\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(f'tuple {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.field","title":"<code>field(*, rename=None, in_names=None, aliases=None, out_name=None, init=True, default=_MISSING, default_factory=None, kw_only=False)</code>","text":"<p>Annotate a dataclass field.</p> <p>Parameters:</p> Name Type Description Default <code>rename</code> <code>Optional[str]</code> <p>Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.</p> <code>None</code> <code>in_names</code> <code>Optional[Sequence[str]]</code> <p>List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike <code>aliases</code>).</p> <code>None</code> <code>aliases</code> <code>Optional[Sequence[str]]</code> <p>List of aliases (additional names) for this field. Includes the field name inside Python (unlike <code>in_names</code>).</p> <code>None</code> <code>out_name</code> <code>Optional[str]</code> <p>Name which this field should convert into.</p> <code>None</code> <code>init</code> <code>bool</code> <p>If <code>False</code>, this field won't be touched by <code>pane</code>, and it's up to the class to initialize it in <code>__post_init__</code>.</p> <code>True</code> <code>default</code> <code>Union[T, _Missing]</code> <p>Default value for field</p> <code>_MISSING</code> <code>default_factory</code> <code>Optional[Callable[[], T]]</code> <p>Default value factory for field</p> <code>None</code> <code>kw_only</code> <code>bool</code> <p>Whether the field is keyword-only.</p> <code>False</code> Source code in <code>pane/field.py</code> <pre><code>def field(*,\nrename: t.Optional[str] = None,\nin_names: t.Optional[t.Sequence[str]] = None,\naliases: t.Optional[t.Sequence[str]] = None,\nout_name: t.Optional[str] = None,\ninit: bool = True,\ndefault: t.Union[T, _Missing] = _MISSING,\ndefault_factory: t.Optional[t.Callable[[], T]] = None,\nkw_only: bool = False,\n) -&gt; t.Any:\n\"\"\"\n    Annotate a dataclass field.\n    Parameters:\n      rename: Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.\n      in_names: List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike `aliases`).\n      aliases: List of aliases (additional names) for this field. Includes the field name inside Python (unlike `in_names`).\n      out_name: Name which this field should convert into.\n      init: If `False`, this field won't be touched by `pane`, and it's up to the class to initialize it in `__post_init__`.\n      default: Default value for field\n      default_factory: Default value factory for field\n      kw_only: Whether the field is keyword-only.\n    \"\"\"\nreturn FieldSpec(\nrename=rename, in_names=in_names, aliases=aliases, out_name=out_name,\ninit=init, default=default, default_factory=default_factory, kw_only=kw_only\n)\n</code></pre>"},{"location":"api/convert/","title":"pane.convert","text":""},{"location":"api/convert/#pane.convert","title":"<code>pane.convert</code>","text":"<p>High-level interface to <code>pane</code>.</p>"},{"location":"api/convert/#pane.convert.DataType","title":"<code>DataType = t.Union[str, bytes, int, bool, float, complex, None, t.Mapping['DataType', 'DataType'], t.Sequence['DataType'], numpy.NDArray[numpy.generic]]</code>  <code>module-attribute</code>","text":"<p>Common data interchange type. <code>into_data</code> converts to this.</p>"},{"location":"api/convert/#pane.convert.Convertible","title":"<code>Convertible = t.Union[DataType, HasConverter, t.AbstractSet[DataType], Fraction, Decimal, datetime.datetime, datetime.date, datetime.time, os.PathLike[str], t.Pattern[str], t.Pattern[bytes], enum.Enum]</code>  <code>module-attribute</code>","text":"<p>Types supported by <code>from_data</code>.</p> <p>Consists of <code>DataType</code> + <code>HasConverter</code> + supported stdlib types.</p>"},{"location":"api/convert/#pane.convert.IntoConverter","title":"<code>IntoConverter = t.Union[t.Type[Convertible], t.Mapping[str, 'IntoConverter'], t.Sequence['IntoConverter']]</code>  <code>module-attribute</code>","text":"<p>Inputs supported by <code>make_converter</code>. Consists of <code>t.Type[Convertible]</code>, mappings (struct types), and sequences (tuple types).</p>"},{"location":"api/convert/#pane.convert.HasConverter","title":"<code>HasConverter</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol to add <code>convert</code> functionality into an arbitrary type from data.</p> Source code in <code>pane/convert.py</code> <pre><code>@t.runtime_checkable\nclass HasConverter(t.Protocol):\n\"\"\"\n    Protocol to add [`convert`][pane.convert.convert] functionality into an arbitrary type from data.\n    \"\"\"\n@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\n\"\"\"\n        Return a [`Converter`][pane.converters.Converter] capable of constructing `cls`.\n        Any given type arguments are passed as positional arguments.\n        This function should error when passed unknown type arguments.\n        \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.HasConverter._converter","title":"<code>_converter(*args)</code>  <code>classmethod</code>","text":"<p>Return a <code>Converter</code> capable of constructing <code>cls</code>.</p> <p>Any given type arguments are passed as positional arguments. This function should error when passed unknown type arguments.</p> Source code in <code>pane/convert.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\n\"\"\"\n    Return a [`Converter`][pane.converters.Converter] capable of constructing `cls`.\n    Any given type arguments are passed as positional arguments.\n    This function should error when passed unknown type arguments.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.ConvertError","title":"<code>ConvertError</code>","text":"<p>             Bases: <code>Exception</code></p> <p><code>pane</code> conversion error.</p> <p><code>self.tree</code> contains a detailed error tree, and <code>str(self)</code> is a human-friendly representation of the same.</p> Source code in <code>pane/errors.py</code> <pre><code>class ConvertError(Exception):\n\"\"\"\n    `pane` conversion error.\n    `self.tree` contains a detailed error tree, and `str(self)`\n    is a human-friendly representation of the same.\n    \"\"\"\ndef __init__(self, tree: ErrorNode):\nself.tree: ErrorNode = tree\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({self.tree!r})\"\ndef __str__(self) -&gt; str:\nreturn str(self.tree)\n</code></pre>"},{"location":"api/convert/#pane.convert.ConvertError.tree","title":"<code>tree: ErrorNode = tree</code>  <code>instance-attribute</code>","text":""},{"location":"api/convert/#pane.convert.Converter","title":"<code>Converter</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T_co]</code></p> <p>Base class for a converter to a given type <code>T_co</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>class Converter(abc.ABC, t.Generic[T_co]):\n\"\"\"\n    Base class for a converter to a given type ``T_co``.\n    \"\"\"\ndef convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n        Convert ``val`` into a data interchange format.\n        ``val`` *should* be of a type returned by this converter,\n        but don't count on it.\n        \"\"\"\nreturn into_data(val, None)\n@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"\n        Return a descriptive string indicating the value(s) expected.\n        Parameters:\n          plural: Whether to pluralize the descriptive string\n        \"\"\"\n...\n@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"\n        Attempt to convert ``val`` to ``T``.\n        Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n        when a given parsing path reaches a dead end.\n        \"\"\"\n...\n@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"\n        Return an error tree caused by converting ``val`` to ``T``.\n        ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n        \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.expected","title":"<code>expected(plural=False)</code>  <code>abstractmethod</code>","text":"<p>Return a descriptive string indicating the value(s) expected.</p> <p>Parameters:</p> Name Type Description Default <code>plural</code> <code>bool</code> <p>Whether to pluralize the descriptive string</p> <code>False</code> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"\n    Return a descriptive string indicating the value(s) expected.\n    Parameters:\n      plural: Whether to pluralize the descriptive string\n    \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.try_convert","title":"<code>try_convert(val)</code>  <code>abstractmethod</code>","text":"<p>Attempt to convert <code>val</code> to <code>T</code>. Should raise <code>ParseInterrupt</code> (and only <code>ParseInterrupt</code>) when a given parsing path reaches a dead end.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"\n    Attempt to convert ``val`` to ``T``.\n    Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n    when a given parsing path reaches a dead end.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.collect_errors","title":"<code>collect_errors(val)</code>  <code>abstractmethod</code>","text":"<p>Return an error tree caused by converting <code>val</code> to <code>T</code>. <code>collect_errors</code> should return <code>None</code> iff <code>convert</code> doesn't raise.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"\n    Return an error tree caused by converting ``val`` to ``T``.\n    ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/convert/#pane.convert.make_converter","title":"<code>make_converter(ty)</code>","text":"<p>Make a <code>Converter</code> for <code>ty</code>.</p> <p>Supports types, mappings of types, and sequences of types.</p> Source code in <code>pane/convert.py</code> <pre><code>@key_cache(id)\ndef make_converter(ty: IntoConverter) -&gt; Converter[t.Any]:\n\"\"\"\n    Make a [`Converter`][pane.convert.Converter] for `ty`.\n    Supports types, mappings of types, and sequences of types.\n    \"\"\"\nfrom .converters import AnyConverter, StructConverter, SequenceConverter, UnionConverter\nfrom .converters import LiteralConverter, DictConverter, TupleConverter, ScalarConverter\nfrom .converters import EnumConverter, _BASIC_CONVERTERS, _BASIC_WITH_ARGS\nif ty is t.Any:\nreturn AnyConverter()\nif isinstance(ty, t.TypeVar):\nif ty.__bound__ is not None:  # type: ignore\n# bound typevar\nvar_ty = ty.__bound__\nelif len(ty.__constraints__) == 1:\n# typevar with constraints\nvar_ty = ty.__constraints__\nelif len(ty.__constraints__) &gt; 1:\n# typevar with multiple constraints\nvar_ty = t.Union[ty.__constraints__]  # type: ignore\nelse:\n# unbound typevar\nvar_ty = t.Any\nwarnings.warn(f\"Unbound TypeVar '{ty}'. Will be interpreted as '{var_ty}'.\")\nreturn make_converter(var_ty)\nif isinstance(ty, (dict, t.Mapping)):\nreturn StructConverter(type(ty), ty)\nif isinstance(ty, (tuple, t.Tuple)):\nreturn TupleConverter(type(ty), ty)\nif isinstance(ty, t.ForwardRef) or isinstance(ty, str):\nraise TypeError(f\"Unresolved forward reference '{ty}'\")\nbase = t.get_origin(ty) or ty\nargs = t.get_args(ty)\n# special types\n# handle annotations\nif base is t.Annotated:\nreturn _annotated_converter(args[0], args[1:])\n# union converter\nif base is t.Union:\nreturn UnionConverter(args)\n# literal converter\nif base is t.Literal:\nreturn LiteralConverter(args)\nif not isinstance(base, type):\nraise TypeError(f\"Unsupported special type '{base}'\")\n# custom converter\nif issubclass(base, HasConverter):\nreturn base._converter(*args)\n# simple/scalar converters\nif base in _BASIC_CONVERTERS:\nreturn _BASIC_CONVERTERS[base]\nif base in _BASIC_WITH_ARGS:\nreturn _BASIC_WITH_ARGS[base](*args)\n# add-on handlers\nfor handler in _CONVERTER_HANDLERS:\ntry:\nresult = handler(base, args)\nif result is not NotImplemented:\nreturn result\nexcept NotImplementedError:\npass\nif issubclass(base, enum.Enum):\nreturn EnumConverter(base)\n# pathlike converter\nif issubclass(base, os.PathLike):\nnew_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\nif inspect.isabstract(new_base):\nraise TypeError(f\"No converter for abstract type '{ty}'\")\nreturn ScalarConverter(new_base, (str, os.PathLike), 'a path', 'paths', str)  # type: ignore\n# tuple converter\nif issubclass(base, (tuple, t.Tuple)):\n# treat tuple[int, ...] and tuple[()] correctly\nif len(args) &gt; 0 and args[-1] != Ellipsis \\\n              or args == () and hasattr(ty, '__args__'):\nif args == ((),):  # tuple[()] on python &lt;3.11\nargs = ()\nreturn TupleConverter(base, args)\n# fall through to sequence converter\n# homogenous sequence converter\n# concrete t.Set/t.List/etc are already converted to set/list/etc by t.get_origin\nif issubclass(base, (collections.abc.Sequence, collections.abc.Set)):\n# map abstract to concrete types\nnew_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\nif inspect.isabstract(new_base):\nraise TypeError(f\"No converter for abstract type '{ty}'\")\nreturn SequenceConverter(new_base, args[0] if len(args) &gt; 0 else t.Any)  # type: ignore\n# homogenous mapping converter\n# this also handles dict subclasses like Counter &amp; OrderedDict\nif issubclass(base, (dict, t.Mapping)):\n# map abstract to concrete types\nnew_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\nif inspect.isabstract(new_base):\nraise TypeError(f\"No converter for abstract type '{ty}'\")\nif issubclass(new_base, collections.Counter):\n# counter takes one type argument, handle it specially\nreturn DictConverter(new_base, args[0] if len(args) &gt; 0 else t.Any, int)\n# defaultdict needs a special constructor\nconstructor: t.Optional[t.Callable[[t.Mapping[t.Any, t.Any]], collections.defaultdict[t.Any, t.Any]]]\nconstructor = (lambda d: collections.defaultdict(None, d)) if issubclass(new_base, collections.defaultdict) else None\nreturn DictConverter(new_base,  # type: ignore\nargs[0] if len(args) &gt; 0 else t.Any,\nargs[1] if len(args) &gt; 1 else t.Any,\nconstructor)\n# after we've handled common cases, look for subclasses of basic types\nfor (conv_ty, conv) in _BASIC_CONVERTERS.items():\nif issubclass(base, conv_ty):\nreturn conv\nraise TypeError(f\"No converter for type '{ty}'\")\n</code></pre>"},{"location":"api/convert/#pane.convert.register_converter_handler","title":"<code>register_converter_handler(handler)</code>","text":"<p>Register a handler for make_converter.</p> <p>This allows extending <code>pane</code> to handle third-party types, not defined by your code or by <code>pane</code>. Use sparingly, as this will add runtime to <code>make_converter</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>def register_converter_handler(handler: t.Callable[[t.Any, t.Tuple[t.Any, ...]], Converter[t.Any]]) -&gt; None:\n\"\"\"\n    Register a handler for make_converter.\n    This allows extending `pane` to handle third-party types, not\n    defined by your code or by `pane`. Use sparingly, as this will\n    add runtime to [`make_converter`][pane.convert.make_converter].\n    \"\"\"\n_CONVERTER_HANDLERS.append(handler)\n</code></pre>"},{"location":"api/convert/#pane.convert._annotated_converter","title":"<code>_annotated_converter(ty, args)</code>","text":"<p>Make an annotated converter.</p> <p>Wraps <code>ty</code> in <code>args</code> from left to right. However, <code>Condition</code> annotations are handled separately (bundled together).</p> Source code in <code>pane/convert.py</code> <pre><code>def _annotated_converter(ty: IntoConverter, args: t.Sequence[t.Any]) -&gt; Converter[t.Any]:\n\"\"\"\n    Make an annotated converter.\n    Wraps `ty` in `args` from left to right. However, [`Condition`][pane.annotations.Condition] annotations\n    are handled separately (bundled together).\n    \"\"\"\nfrom .converters import Converter\nfrom .annotations import Condition, ConvertAnnotation\nconv: t.Union[IntoConverter, Converter[t.Any]] = ty\nconditions: t.List[Condition] = []  # buffer of conditions to combine\nfor arg in args:\nif isinstance(arg, Condition):\nconditions.append(arg)\ncontinue\nif not isinstance(arg, ConvertAnnotation):\nraise UnsupportedAnnotation(arg)\n# dump list of conditions\nif len(conditions):\nif len(conditions) &gt; 1:\nconv = Condition.all(*conditions)._converter(conv)\nelse:\nconv = conditions[0]._converter(conv)\nconv = arg._converter(conv)\n# dump list of conditions\nif len(conditions):\nif len(conditions) &gt; 1:\nconv = Condition.all(*conditions)._converter(conv)\nelse:\nconv = conditions[0]._converter(conv)\nreturn conv if isinstance(conv, Converter) else make_converter(conv)\n</code></pre>"},{"location":"api/convert/#pane.convert.into_data","title":"<code>into_data(val, ty=None)</code>","text":"<p>Convert <code>val</code> of type <code>ty</code> into a data interchange format.</p> Source code in <code>pane/convert.py</code> <pre><code>def into_data(val: Convertible, ty: t.Optional[IntoConverter] = None) -&gt; DataType:\n\"\"\"\n    Convert `val` of type `ty` into a data interchange format.\n    \"\"\"\nif ty is None:\nif isinstance(val, _DataType):\nreturn val\nty = type(val)\ntry:\nconv = make_converter(ty)\nexcept TypeError:\nraise TypeError(f\"Can't convert type '{type(val)}' into data.\") from None\nreturn conv.into_data(val)\n</code></pre>"},{"location":"api/convert/#pane.convert.from_data","title":"<code>from_data(val, ty)</code>","text":"<p>Convert <code>val</code> from a data interchange format into type <code>ty</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>def from_data(val: DataType, ty: t.Type[T]) -&gt; T:\n\"\"\"\n    Convert `val` from a data interchange format into type `ty`.\n    \"\"\"\nif not isinstance(val, _DataType):\nraise TypeError(f\"Type {type(val)} is not a valid data interchange type.\")\nconverter = make_converter(ty)\nreturn converter.convert(val)\n</code></pre>"},{"location":"api/convert/#pane.convert.convert","title":"<code>convert(val, ty)</code>","text":"<p>Convert <code>val</code> into type <code>ty</code>, passing through a data interchange format.</p> Source code in <code>pane/convert.py</code> <pre><code>def convert(val: Convertible, ty: t.Type[T]) -&gt; T:\n\"\"\"\n    Convert `val` into type `ty`, passing through a data interchange format.\n    \"\"\"\ndata = into_data(val)\nreturn from_data(data, ty)\n</code></pre>"},{"location":"api/converters/","title":"pane.converters","text":""},{"location":"api/converters/#pane.converters","title":"<code>pane.converters</code>","text":"<p>Converter types, which do the hard work of recursive validation.</p>"},{"location":"api/converters/#pane.converters.NestedSequence","title":"<code>NestedSequence = t.Union[T, t.Sequence['NestedSequence[T]']]</code>  <code>module-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeT","title":"<code>DatetimeT = t.TypeVar('DatetimeT', bound=t.Union[datetime.datetime, datetime.date, datetime.time])</code>  <code>module-attribute</code>","text":""},{"location":"api/converters/#pane.converters.Converter","title":"<code>Converter</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T_co]</code></p> <p>Base class for a converter to a given type <code>T_co</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>class Converter(abc.ABC, t.Generic[T_co]):\n\"\"\"\n    Base class for a converter to a given type ``T_co``.\n    \"\"\"\ndef convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n        Convert ``val`` into a data interchange format.\n        ``val`` *should* be of a type returned by this converter,\n        but don't count on it.\n        \"\"\"\nreturn into_data(val, None)\n@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"\n        Return a descriptive string indicating the value(s) expected.\n        Parameters:\n          plural: Whether to pluralize the descriptive string\n        \"\"\"\n...\n@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"\n        Attempt to convert ``val`` to ``T``.\n        Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n        when a given parsing path reaches a dead end.\n        \"\"\"\n...\n@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"\n        Return an error tree caused by converting ``val`` to ``T``.\n        ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n        \"\"\"\n...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.expected","title":"<code>expected(plural=False)</code>  <code>abstractmethod</code>","text":"<p>Return a descriptive string indicating the value(s) expected.</p> <p>Parameters:</p> Name Type Description Default <code>plural</code> <code>bool</code> <p>Whether to pluralize the descriptive string</p> <code>False</code> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"\n    Return a descriptive string indicating the value(s) expected.\n    Parameters:\n      plural: Whether to pluralize the descriptive string\n    \"\"\"\n...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.try_convert","title":"<code>try_convert(val)</code>  <code>abstractmethod</code>","text":"<p>Attempt to convert <code>val</code> to <code>T</code>. Should raise <code>ParseInterrupt</code> (and only <code>ParseInterrupt</code>) when a given parsing path reaches a dead end.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"\n    Attempt to convert ``val`` to ``T``.\n    Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n    when a given parsing path reaches a dead end.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.collect_errors","title":"<code>collect_errors(val)</code>  <code>abstractmethod</code>","text":"<p>Return an error tree caused by converting <code>val</code> to <code>T</code>. <code>collect_errors</code> should return <code>None</code> iff <code>convert</code> doesn't raise.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"\n    Return an error tree caused by converting ``val`` to ``T``.\n    ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter","title":"<code>AnyConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[Any]</code></p> <p>Converter for <code>t.Any</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass AnyConverter(Converter[t.Any]):\n\"\"\"Converter for ``t.Any``.\"\"\"\ndef try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nreturn val\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(\"any value\", plural)\ndef collect_errors(self, val: t.Any) -&gt; None:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nreturn val\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(\"any value\", plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; None:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter","title":"<code>ScalarConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[T]</code></p> <p>Converter for a simple scalar type, constructible from a list of allowed types.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass ScalarConverter(Converter[T]):\n\"\"\"\n    Converter for a simple scalar type,\n    constructible from a list of allowed types.\n    \"\"\"\n# TODO this needs to handle into_data better\nty: t.Type[T]\n\"\"\"Type to convert into.\"\"\"\nallowed: t.Union[type, t.Tuple[type, ...]]\n\"\"\"Type or list of allowed types.\"\"\"\nexpect: t.Optional[str] = None\n\"\"\"Singular form of expected value.\"\"\"\nexpect_plural: t.Optional[str] = None\n\"\"\"Plural form of expected value.\"\"\"\n_into_data_f: t.Callable[[T], DataType] = lambda v: v  # type: ignore\ndef __post_init__(self):\nself.expect = self.expect or self.ty.__name__\nself.expect_plural = self.expect_plural or self.expect\ndef into_data(self, val: t.Any) -&gt; DataType:\nreturn self._into_data_f(val)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn t.cast(str, self.expect_plural if plural else self.expect)\ndef try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif isinstance(val, self.allowed):\ntry:\nreturn self.ty(val)  # type: ignore\nexcept Exception:\nraise ParseInterrupt()\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif isinstance(val, self.allowed):\ntry:\nself.ty(val)\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nreturn WrongTypeError(f'{self.expected()}', val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.ty","title":"<code>ty: t.Type[T]</code>  <code>instance-attribute</code>","text":"<p>Type to convert into.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.allowed","title":"<code>allowed: t.Union[type, t.Tuple[type, ...]]</code>  <code>instance-attribute</code>","text":"<p>Type or list of allowed types.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.expect","title":"<code>expect: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Singular form of expected value.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.expect_plural","title":"<code>expect_plural: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plural form of expected value.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\nreturn self._into_data_f(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn t.cast(str, self.expect_plural if plural else self.expect)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif isinstance(val, self.allowed):\ntry:\nreturn self.ty(val)  # type: ignore\nexcept Exception:\nraise ParseInterrupt()\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif isinstance(val, self.allowed):\ntry:\nself.ty(val)\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nreturn WrongTypeError(f'{self.expected()}', val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter","title":"<code>NoneConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[None]</code></p> <p>Converter which accepts only <code>None</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass NoneConverter(Converter[None]):\n\"\"\"\n    Converter which accepts only ``None``.\n    \"\"\"\ndef try_convert(self, val: t.Any) -&gt; None:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif val is None:\nreturn val\nraise ParseInterrupt()\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(\"null value\", plural)\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif val is None:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; None:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif val is None:\nreturn val\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(\"null value\", plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif val is None:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter","title":"<code>LiteralConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[T_co]</code></p> <p>Converter which accepts any of a list of literal values.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass LiteralConverter(Converter[T_co]):\n\"\"\"\n    Converter which accepts any of a list of literal values.\n    \"\"\"\nvals: t.Sequence[T_co]\ndef try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif val in self.vals:\nreturn val\nraise ParseInterrupt()\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nl = list_phrase(tuple(map(repr, self.vals)))\nreturn f\"({l})\" if plural else l\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif val in self.vals:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.vals","title":"<code>vals: t.Sequence[T_co]</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.LiteralConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T_co:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif val in self.vals:\nreturn val\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nl = list_phrase(tuple(map(repr, self.vals)))\nreturn f\"({l})\" if plural else l\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif val in self.vals:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter","title":"<code>UnionConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[Any]</code></p> <p>Converter for an untagged union of subtypes. Unions are always evaluated left-to-right.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass UnionConverter(Converter[t.Any]):\n\"\"\"\n    Converter for an untagged union of subtypes.\n    Unions are always evaluated left-to-right.\n    \"\"\"\ntypes: t.Tuple[IntoConverter, ...]\n\"\"\"List of potential types\"\"\"\nconverters: t.Tuple[Converter[t.Any], ...]\n\"\"\"List of type converters\"\"\"\nconstructor: t.Optional[t.Callable[[t.Any, int], t.Any]]\n\"\"\"\n    Constructor to call with parsed value.\n    Called with ``(val, index of type in union)``\n    \"\"\"\ndef __init__(self, types: t.Sequence[IntoConverter],\nconstructor: t.Optional[t.Callable[[t.Any, int], t.Any]] = None):\nself.types = tuple(flatten_union_args(types))\nself.converters = tuple(map(make_converter, types))\nself.constructor = constructor\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn list_phrase(tuple(conv.expected(plural) for conv in self.converters))\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n# this is tricky, because we have no type information about which variant ``val`` is.\n# so we basically try_convert each until we find a match\n# this works because try_convert should be idempotent\nfor conv in self.converters:\ntry:\nconv.try_convert(val)\nexcept ParseInterrupt:\npass\nelse:\nreturn conv.into_data(val)\n# default to regular conversion\nreturn into_data(val)\ndef construct(self, val: t.Any, i: int) -&gt; t.Any:\nif self.constructor is None:\nreturn val\nreturn self.constructor(val, i)\ndef try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nfor (i, conv) in enumerate(self.converters):\ntry:\nval = conv.try_convert(val)\ntry:\nreturn self.construct(val, i)\nexcept Exception:\npass\nexcept ParseInterrupt:\npass\nraise ParseInterrupt\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nfailed_children: t.List[ErrorNode] = []\nfor (i, conv) in enumerate(self.converters):\n# if one branch is successful, the whole type is successful\ntry:\nconv_val = conv.try_convert(val)\nexcept ParseInterrupt:\nfailed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\ncontinue\ntry:\nself.construct(conv_val, i)\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nfailed_children.append(WrongTypeError(self.expected(), val, tb))\nreturn SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.types","title":"<code>types: t.Tuple[IntoConverter, ...] = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/converters/#pane.converters.UnionConverter.converters","title":"<code>converters: t.Tuple[Converter[t.Any], ...] = tuple(map(make_converter, types))</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/converters/#pane.converters.UnionConverter.constructor","title":"<code>constructor: t.Optional[t.Callable[[t.Any, int], t.Any]] = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/converters/#pane.converters.UnionConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n# this is tricky, because we have no type information about which variant ``val`` is.\n# so we basically try_convert each until we find a match\n# this works because try_convert should be idempotent\nfor conv in self.converters:\ntry:\nconv.try_convert(val)\nexcept ParseInterrupt:\npass\nelse:\nreturn conv.into_data(val)\n# default to regular conversion\nreturn into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\nif self.constructor is None:\nreturn val\nreturn self.constructor(val, i)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nfor (i, conv) in enumerate(self.converters):\ntry:\nval = conv.try_convert(val)\ntry:\nreturn self.construct(val, i)\nexcept Exception:\npass\nexcept ParseInterrupt:\npass\nraise ParseInterrupt\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nfailed_children: t.List[ErrorNode] = []\nfor (i, conv) in enumerate(self.converters):\n# if one branch is successful, the whole type is successful\ntry:\nconv_val = conv.try_convert(val)\nexcept ParseInterrupt:\nfailed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\ncontinue\ntry:\nself.construct(conv_val, i)\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nfailed_children.append(WrongTypeError(self.expected(), val, tb))\nreturn SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter","title":"<code>TaggedUnionConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>UnionConverter</code></p> <p>Converter for a tagged union of subtypes.</p> <p>Tagged unions may be parsed in three ways. The default is an 'internally tagged' union, where the tag is found by looking for a given key in the given object. This is the default. An 'externally tagged' union is stored as a dict with a key and a single value <code>{tag: content}</code>. This may be specified using <code>external=True</code>. Finally, a 'adjacently tagged' union may be specified using two keys <code>external=(t, c)</code>. The union is stored as <code>{t: tag, c: content}</code></p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass TaggedUnionConverter(UnionConverter):\n\"\"\"\n    Converter for a tagged union of subtypes.\n    Tagged unions may be parsed in three ways. The default\n    is an 'internally tagged' union, where the tag is found\n    by looking for a given key in the given object. This is the\n    default.\n    An 'externally tagged' union is stored as a dict with a key\n    and a single value ``{tag: content}``. This may be specified\n    using ``external=True``.\n    Finally, a 'adjacently tagged' union may be specified using\n    two keys ``external=(t, c)``. The union is stored as\n    ``{t: tag, c: content}``\n    \"\"\"\ntag: str\ntag_map: t.Dict[t.Any, int]\n\"\"\"Map from tags to indices into self.types/self.converters\"\"\"\nexternal: t.Union[bool, t.Tuple[str, str]] = False\n\"\"\"\n    Tagged union representation.\n    False: internal representation\n    True: external representation\n    (t, c): adjacent representation\n    \"\"\"\ndef __init__(self, types: t.Sequence[t.Any], tag: str,\nexternal: t.Union[bool, t.Tuple[str, str]] = False):\nsuper().__init__(types)\nself.tag = tag\nself.external = external if isinstance(external, t.Sequence) else bool(external)\n# look for tag in each of self.types\nself.tag_map = {}\nfor (i, ty) in enumerate(self.types):\ntry:\n# TODO error if used on non-literal\nval = getattr(ty, self.tag)\nif val in self.tag_map:\nraise TypeError(f\"Tag value '{val}' matches multiple types\")\nself.tag_map[val] = i\nexcept AttributeError:\nraise AttributeError(f\"Tag '{self.tag}' not found inside type '{ty}'\")\ndef tag_expected(self) -&gt; str:\n\"\"\"Return a string list of the expected/supported tags\"\"\"\nreturn list_phrase(tuple(map(repr, self.tag_map.keys())))\ndef obj_expected(self, plural: bool = False) -&gt; str:\n\"\"\"Return a string list of the supported objects\"\"\"\nreturn list_phrase(tuple(conv.expected(plural) for conv in self.converters))\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nif self.external is False:\n# internally tagged\nreturn self.obj_expected(plural)\nobj = self.obj_expected(False)\nmapping = pluralize('mapping', plural, article='a')\ntag = list_phrase(tuple(map(repr, self.tag_map.keys())))\nif self.external is True:\n# externally tagged\nreturn f\"{mapping} '{tag}' =&gt; {obj}\"\nelse:\n# adjacently tagged\n(t, c) = self.external \nreturn f\"{mapping} {repr(t)} =&gt; {tag}, {repr(c)} =&gt; {obj}\"\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\ntag = getattr(val, self.tag)\ninner_conv = self.converters[self.tag_map[tag]]\nif self.external is False:\n# internally tagged\nreturn inner_conv.into_data(val)\nif self.external is True:\n# externally tagged\nreturn {tag: inner_conv.into_data(val)}\n# adjacently tagged\n(t_r, c_r) = self.external\nreturn {t_r: tag, c_r: inner_conv.into_data(val)}\ndef try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nval = t.cast(t.Dict[str, t.Any], val)\ntag: t.Any\nif self.external is False:\ntry:\n# don't give 'tag' to variants\nval = val.copy()\ntag = val.pop(self.tag)\nexcept KeyError:\nraise ParseInterrupt()\nelif self.external is True:\nif len(val) != 1:\nraise ParseInterrupt()\n(tag, val) = next(iter(val.items()))\nelse:\n(t_r, c_r) = self.external\ntry:\nif len(val) != 2:\nraise ParseInterrupt()\ntag, val = val[t_r], val[c_r]\nexcept KeyError:\nraise ParseInterrupt()\ntry:\ni = self.tag_map[tag]\nexcept KeyError:\nraise ParseInterrupt()\nreturn self.converters[i].try_convert(val)\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nval = t.cast(t.Dict[str, t.Any], val)\ntag: t.Any\nif self.external is False:\ntry:\n# don't give 'tag' to variants\nval = val.copy()\ntag = val.pop(self.tag)\nexcept KeyError:\nreturn WrongTypeError(f\"mapping with key '{self.tag}' =&gt; {self.tag_expected()}\", val)\nelif self.external is True:\nif len(val) != 1:\nreturn WrongTypeError(self.expected(), val)\n(tag, val) = next(iter(val.items()))\nelse:\n(t_r, c_r) = self.external\ntry:\nif len(val) != 2:\nraise KeyError()\ntag, val = val[t_r], val[c_r]\nexcept KeyError:\nreturn WrongTypeError(f\"mapping with keys '{t_r}' and '{c_r}'\", val)\ntry:\ni = self.tag_map[tag]\nexcept KeyError:\nreturn WrongTypeError(f\"tag '{self.tag}' one of {self.tag_expected()}\", tag)\nreturn self.converters[i].collect_errors(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.types","title":"<code>types: t.Tuple[IntoConverter, ...] = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.converters","title":"<code>converters: t.Tuple[Converter[t.Any], ...] = tuple(map(make_converter, types))</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.constructor","title":"<code>constructor: t.Optional[t.Callable[[t.Any, int], t.Any]] = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag","title":"<code>tag: str = tag</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.TaggedUnionConverter.external","title":"<code>external: t.Union[bool, t.Tuple[str, str]] = external if isinstance(external, t.Sequence) else bool(external)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Tagged union representation. False: internal representation True: external representation (t, c): adjacent representation</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag_map","title":"<code>tag_map: t.Dict[t.Any, int] = {}</code>  <code>instance-attribute</code>","text":"<p>Map from tags to indices into self.types/self.converters</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\nif self.constructor is None:\nreturn val\nreturn self.constructor(val, i)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag_expected","title":"<code>tag_expected()</code>","text":"<p>Return a string list of the expected/supported tags</p> Source code in <code>pane/converters.py</code> <pre><code>def tag_expected(self) -&gt; str:\n\"\"\"Return a string list of the expected/supported tags\"\"\"\nreturn list_phrase(tuple(map(repr, self.tag_map.keys())))\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.obj_expected","title":"<code>obj_expected(plural=False)</code>","text":"<p>Return a string list of the supported objects</p> Source code in <code>pane/converters.py</code> <pre><code>def obj_expected(self, plural: bool = False) -&gt; str:\n\"\"\"Return a string list of the supported objects\"\"\"\nreturn list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nif self.external is False:\n# internally tagged\nreturn self.obj_expected(plural)\nobj = self.obj_expected(False)\nmapping = pluralize('mapping', plural, article='a')\ntag = list_phrase(tuple(map(repr, self.tag_map.keys())))\nif self.external is True:\n# externally tagged\nreturn f\"{mapping} '{tag}' =&gt; {obj}\"\nelse:\n# adjacently tagged\n(t, c) = self.external \nreturn f\"{mapping} {repr(t)} =&gt; {tag}, {repr(c)} =&gt; {obj}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\ntag = getattr(val, self.tag)\ninner_conv = self.converters[self.tag_map[tag]]\nif self.external is False:\n# internally tagged\nreturn inner_conv.into_data(val)\nif self.external is True:\n# externally tagged\nreturn {tag: inner_conv.into_data(val)}\n# adjacently tagged\n(t_r, c_r) = self.external\nreturn {t_r: tag, c_r: inner_conv.into_data(val)}\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nval = t.cast(t.Dict[str, t.Any], val)\ntag: t.Any\nif self.external is False:\ntry:\n# don't give 'tag' to variants\nval = val.copy()\ntag = val.pop(self.tag)\nexcept KeyError:\nraise ParseInterrupt()\nelif self.external is True:\nif len(val) != 1:\nraise ParseInterrupt()\n(tag, val) = next(iter(val.items()))\nelse:\n(t_r, c_r) = self.external\ntry:\nif len(val) != 2:\nraise ParseInterrupt()\ntag, val = val[t_r], val[c_r]\nexcept KeyError:\nraise ParseInterrupt()\ntry:\ni = self.tag_map[tag]\nexcept KeyError:\nraise ParseInterrupt()\nreturn self.converters[i].try_convert(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nval = t.cast(t.Dict[str, t.Any], val)\ntag: t.Any\nif self.external is False:\ntry:\n# don't give 'tag' to variants\nval = val.copy()\ntag = val.pop(self.tag)\nexcept KeyError:\nreturn WrongTypeError(f\"mapping with key '{self.tag}' =&gt; {self.tag_expected()}\", val)\nelif self.external is True:\nif len(val) != 1:\nreturn WrongTypeError(self.expected(), val)\n(tag, val) = next(iter(val.items()))\nelse:\n(t_r, c_r) = self.external\ntry:\nif len(val) != 2:\nraise KeyError()\ntag, val = val[t_r], val[c_r]\nexcept KeyError:\nreturn WrongTypeError(f\"mapping with keys '{t_r}' and '{c_r}'\", val)\ntry:\ni = self.tag_map[tag]\nexcept KeyError:\nreturn WrongTypeError(f\"tag '{self.tag}' one of {self.tag_expected()}\", tag)\nreturn self.converters[i].collect_errors(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter","title":"<code>StructConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Converter[T]</code></p> <p>Converter for a simple, hetereogeneous struct-like type, constructible from a dict.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass StructConverter(Converter[T]):\n\"\"\"\n    Converter for a simple, hetereogeneous struct-like type, constructible from a dict.\n    \"\"\"\nty: t.Type[T]\n\"\"\"Type to convert into. Must be constructible from a dict/mapping.\"\"\"\nfields: t.Mapping[str, IntoConverter]\n\"\"\"List of fields and their types\"\"\"\nname: t.Optional[str] = None\n\"\"\"Optional name of struct\"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\nopt_fields: t.Set[str] = dataclasses.field(default_factory=set)\n\"\"\"Set of fields which are optional\"\"\"\nfield_converters: t.Dict[str, Converter[t.Any]] = dataclasses.field(init=False)\n\"\"\"Dict of sub-converters for each field\"\"\"\ndef __post_init__(self):\nself.field_converters = {k: make_converter(v) for (k, v) in self.fields.items()}\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nname = f\" {self.name}\" if self.name is not None else \"\"\nreturn f\"{pluralize('struct', plural)}{name}\"\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nassert data_is_mapping(val)\nd: t.Dict[DataType, DataType] = {}\nfor (k, v) in t.cast(t.Mapping[str, t.Any], val).items():\nif (conv := self.field_converters.get(k)) is not None:\nd[k] = conv.into_data(v)\nelse:\nd[k] = into_data(v)\nreturn d\ndef try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nval = t.cast(t.Dict[str, t.Any], val)\nd: t.Dict[str, t.Any] = {}\nfor (k, v) in val.items():\nif k not in self.fields:\nraise ParseInterrupt()  # unknown field\nd[k] = self.field_converters[k].try_convert(v)\nmissing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\nif len(missing):\nraise ParseInterrupt()\nreturn self.ty(d)  # type: ignore\ndef collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nval = t.cast(t.Dict[str, t.Any], val)\nchildren: t.Dict[t.Union[str, int], t.Any] = {}\nextra: t.Set[str] = set()\nfor (k, v) in val.items():\nif k not in self.fields:\nextra.add(k)\ncontinue\nif (node := self.field_converters[k].collect_errors(v)) is not None:\nchildren[k] = node\nmissing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\nif len(children) or len(missing) or len(extra):\nreturn ProductErrorNode(self.expected(), children, val, missing, extra)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.ty","title":"<code>ty: t.Type[T]</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from a dict/mapping.</p>"},{"location":"api/converters/#pane.converters.StructConverter.fields","title":"<code>fields: t.Mapping[str, IntoConverter]</code>  <code>instance-attribute</code>","text":"<p>List of fields and their types</p>"},{"location":"api/converters/#pane.converters.StructConverter.name","title":"<code>name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional name of struct</p>"},{"location":"api/converters/#pane.converters.StructConverter.opt_fields","title":"<code>opt_fields: t.Set[str] = dataclasses.field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of fields which are optional</p>"},{"location":"api/converters/#pane.converters.StructConverter.field_converters","title":"<code>field_converters: t.Dict[str, Converter[t.Any]] = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dict of sub-converters for each field</p>"},{"location":"api/converters/#pane.converters.StructConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nname = f\" {self.name}\" if self.name is not None else \"\"\nreturn f\"{pluralize('struct', plural)}{name}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nassert data_is_mapping(val)\nd: t.Dict[DataType, DataType] = {}\nfor (k, v) in t.cast(t.Mapping[str, t.Any], val).items():\nif (conv := self.field_converters.get(k)) is not None:\nd[k] = conv.into_data(v)\nelse:\nd[k] = into_data(v)\nreturn d\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nval = t.cast(t.Dict[str, t.Any], val)\nd: t.Dict[str, t.Any] = {}\nfor (k, v) in val.items():\nif k not in self.fields:\nraise ParseInterrupt()  # unknown field\nd[k] = self.field_converters[k].try_convert(v)\nmissing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\nif len(missing):\nraise ParseInterrupt()\nreturn self.ty(d)  # type: ignore\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nval = t.cast(t.Dict[str, t.Any], val)\nchildren: t.Dict[t.Union[str, int], t.Any] = {}\nextra: t.Set[str] = set()\nfor (k, v) in val.items():\nif k not in self.fields:\nextra.add(k)\ncontinue\nif (node := self.field_converters[k].collect_errors(v)) is not None:\nchildren[k] = node\nmissing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\nif len(children) or len(missing) or len(extra):\nreturn ProductErrorNode(self.expected(), children, val, missing, extra)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter","title":"<code>TupleConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T]</code>, <code>Converter[T]</code></p> <p>Converter for a simple, heterogeneous tuple-like type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass TupleConverter(t.Generic[T], Converter[T]):\n\"\"\"Converter for a simple, heterogeneous tuple-like type\"\"\"\nty: t.Type[T]\n\"\"\"Type to convert into. Must be constructible from a sequence/tuple\"\"\"\nconverters: t.Tuple[Converter[t.Any], ...]\n\"\"\"List of sub-converters for each field\"\"\"\ndef __init__(self, ty: t.Type[T], types: t.Sequence[IntoConverter]):\nself.ty = ty\nself.converters = tuple(map(make_converter, types))\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn tuple(\nconv.into_data(v)\nfor (v, conv) in zip(t.cast(t.Sequence[t.Any], val), self.converters)\n)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('tuple', plural)} of length {len(self.converters)}\"\ndef try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_sequence(val):\nraise ParseInterrupt\nif len(val) != len(self.converters):\nraise ParseInterrupt\nreturn self.ty(conv.try_convert(v) for (conv, v) in zip(self.converters, val))\ndef collect_errors(self, val: t.Any) -&gt; t.Union[None, ProductErrorNode, WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_sequence(val) or len(val) != len(self.converters):\nreturn WrongTypeError(self.expected(), val)\nchildren = {}\nfor (i, (conv, v)) in enumerate(zip(self.converters, val)):\nnode = conv.collect_errors(v)\nif node is not None:\nchildren[i] = node\nif len(children) == 0:\nreturn None\nreturn ProductErrorNode(self.expected(), children, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.ty","title":"<code>ty: t.Type[T] = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from a sequence/tuple</p>"},{"location":"api/converters/#pane.converters.TupleConverter.converters","title":"<code>converters: t.Tuple[Converter[t.Any], ...] = tuple(map(make_converter, types))</code>  <code>instance-attribute</code>","text":"<p>List of sub-converters for each field</p>"},{"location":"api/converters/#pane.converters.TupleConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn tuple(\nconv.into_data(v)\nfor (v, conv) in zip(t.cast(t.Sequence[t.Any], val), self.converters)\n)\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('tuple', plural)} of length {len(self.converters)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_sequence(val):\nraise ParseInterrupt\nif len(val) != len(self.converters):\nraise ParseInterrupt\nreturn self.ty(conv.try_convert(v) for (conv, v) in zip(self.converters, val))\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, ProductErrorNode, WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_sequence(val) or len(val) != len(self.converters):\nreturn WrongTypeError(self.expected(), val)\nchildren = {}\nfor (i, (conv, v)) in enumerate(zip(self.converters, val)):\nnode = conv.collect_errors(v)\nif node is not None:\nchildren[i] = node\nif len(children) == 0:\nreturn None\nreturn ProductErrorNode(self.expected(), children, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter","title":"<code>DictConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[FromDataK, FromDataV]</code>, <code>Converter[Mapping[FromDataK, FromDataV]]</code></p> <p>Converter for a homogenous dict-like type.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass DictConverter(t.Generic[FromDataK, FromDataV], Converter[t.Mapping[FromDataK, FromDataV]]):\n\"\"\"Converter for a homogenous dict-like type.\"\"\"\nty: t.Type[t.Mapping[FromDataK, FromDataV]]\n\"\"\"Type to convert into. Must be constructible from a dict (unless `constructor` is specified)\"\"\"\nk_conv: Converter[FromDataK]\n\"\"\"Sub-converter for keys\"\"\"\nv_conv: Converter[FromDataV]\n\"\"\"Sub-converter for values\"\"\"\nconstructor: t.Callable[[t.Dict[t.Any, t.Any]], t.Mapping[FromDataK, FromDataV]]\ndef __init__(self, ty: t.Type[t.Dict[t.Any, t.Any]],\nk: t.Type[FromDataK] = t.Any, v: t.Type[FromDataV] = t.Any,\nconstructor: t.Optional[t.Callable[[t.Dict[t.Any, t.Any]], t.Mapping[FromDataK, FromDataV]]] = None):\nself.ty = ty\nself.k_conv = make_converter(k)\nself.v_conv = make_converter(v)\nself.constructor = self.ty if constructor is None else constructor\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn {\nself.k_conv.into_data(k): self.v_conv.into_data(v)\nfor (k, v) in t.cast(t.Mapping[FromDataK, FromDataV], val).items()\n}\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('mapping', plural)} of {self.k_conv.expected(True)} =&gt; {self.v_conv.expected(True)}\"\ndef try_convert(self, val: t.Any) -&gt; t.Mapping[FromDataK, FromDataV]:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nd = {self.k_conv.try_convert(k): self.v_conv.try_convert(v) for (k, v) in val.items()}\n# TODO catch errors here\nreturn self.constructor(d)\ndef collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nnodes: t.Dict[t.Union[str, int], ErrorNode] = {}\nfor (k, v) in val.items():\nif (node := self.k_conv.collect_errors(k)) is not None:\nnodes[str(k)] = node  # TODO split bad fields from bad values\nif (node := self.v_conv.collect_errors(v)) is not None:\nnodes[str(k)] = node\nif len(nodes):\nreturn ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.ty","title":"<code>ty: t.Type[t.Mapping[FromDataK, FromDataV]] = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from a dict (unless <code>constructor</code> is specified)</p>"},{"location":"api/converters/#pane.converters.DictConverter.k_conv","title":"<code>k_conv: Converter[FromDataK] = make_converter(k)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for keys</p>"},{"location":"api/converters/#pane.converters.DictConverter.v_conv","title":"<code>v_conv: Converter[FromDataV] = make_converter(v)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for values</p>"},{"location":"api/converters/#pane.converters.DictConverter.constructor","title":"<code>constructor: t.Callable[[t.Dict[t.Any, t.Any]], t.Mapping[FromDataK, FromDataV]] = self.ty if constructor is None else constructor</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DictConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn {\nself.k_conv.into_data(k): self.v_conv.into_data(v)\nfor (k, v) in t.cast(t.Mapping[FromDataK, FromDataV], val).items()\n}\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('mapping', plural)} of {self.k_conv.expected(True)} =&gt; {self.v_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Mapping[FromDataK, FromDataV]:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_mapping(val):\nraise ParseInterrupt()\nd = {self.k_conv.try_convert(k): self.v_conv.try_convert(v) for (k, v) in val.items()}\n# TODO catch errors here\nreturn self.constructor(d)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_mapping(val):\nreturn WrongTypeError(self.expected(), val)\nnodes: t.Dict[t.Union[str, int], ErrorNode] = {}\nfor (k, v) in val.items():\nif (node := self.k_conv.collect_errors(k)) is not None:\nnodes[str(k)] = node  # TODO split bad fields from bad values\nif (node := self.v_conv.collect_errors(v)) is not None:\nnodes[str(k)] = node\nif len(nodes):\nreturn ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter","title":"<code>SequenceConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[FromDataT]</code>, <code>Converter[Sequence[FromDataT]]</code></p> <p>Converter for a homogenous sequence-like type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass SequenceConverter(t.Generic[FromDataT], Converter[t.Sequence[FromDataT]]):\n\"\"\"Converter for a homogenous sequence-like type\"\"\"\nty: type\n\"\"\"Type to convert into. Must be constructible from an iterator.\"\"\"\nv_conv: Converter[FromDataT]\n\"\"\"Sub-converter for values\"\"\"\nconstructor: t.Callable[[t.Iterator[t.Any]], t.Sequence[t.Any]]\ndef __init__(self, ty: t.Type[t.Sequence[t.Any]], v: t.Type[FromDataT] = t.Any,\nconstructor: t.Optional[t.Callable[[t.Iterator[t.Any]], t.Sequence[t.Any]]] = None):\nself.ty = ty\nself.v_conv = make_converter(v)\nself.constructor = self.ty if constructor is None else constructor\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn [\nself.v_conv.into_data(v)\nfor v in t.cast(t.Sequence[FromDataT], val)\n]\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('sequence', plural)} of {self.v_conv.expected(True)}\"\ndef try_convert(self, val: t.Any) -&gt; t.Sequence[FromDataT]:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_sequence(val):\nraise ParseInterrupt\ntry:\nreturn self.constructor(self.v_conv.try_convert(v) for v in val)  # type: ignore\nexcept Exception:\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_sequence(val):\nreturn WrongTypeError(self.expected(), val)\nnodes = {}\nvals: t.List[FromDataT] = []\nfor (i, v) in enumerate(val):\ntry:\nvals.append(self.v_conv.convert(v))\nexcept ConvertError as e:\nnodes[i] = e.tree\nif len(nodes):\nreturn ProductErrorNode(self.expected(), nodes, val)\n# try to construct val\ntry:\nself.constructor(iter(vals))\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.ty","title":"<code>ty: type = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from an iterator.</p>"},{"location":"api/converters/#pane.converters.SequenceConverter.v_conv","title":"<code>v_conv: Converter[FromDataT] = make_converter(v)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for values</p>"},{"location":"api/converters/#pane.converters.SequenceConverter.constructor","title":"<code>constructor: t.Callable[[t.Iterator[t.Any]], t.Sequence[t.Any]] = self.ty if constructor is None else constructor</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.SequenceConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn [\nself.v_conv.into_data(v)\nfor v in t.cast(t.Sequence[FromDataT], val)\n]\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn f\"{pluralize('sequence', plural)} of {self.v_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Sequence[FromDataT]:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif not data_is_sequence(val):\nraise ParseInterrupt\ntry:\nreturn self.constructor(self.v_conv.try_convert(v) for v in val)  # type: ignore\nexcept Exception:\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif not data_is_sequence(val):\nreturn WrongTypeError(self.expected(), val)\nnodes = {}\nvals: t.List[FromDataT] = []\nfor (i, v) in enumerate(val):\ntry:\nvals.append(self.v_conv.convert(v))\nexcept ConvertError as e:\nnodes[i] = e.tree\nif len(nodes):\nreturn ProductErrorNode(self.expected(), nodes, val)\n# try to construct val\ntry:\nself.constructor(iter(vals))\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter","title":"<code>NestedSequenceConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T, U]</code>, <code>Converter[T]</code></p> <p>Converter which delegates to a sub-converter, and then attempts to construct a different type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass NestedSequenceConverter(t.Generic[T, U], Converter[T]):\n\"\"\"\n    Converter which delegates to a sub-converter, and then attempts\n    to construct a different type\n    \"\"\"\nval_type: t.Type[U]\n\"\"\"Inner type to convert to\"\"\"\nconstructor: t.Callable[[NestedSequence[U]], T]\n\"\"\"Constructor to call.\"\"\"\nragged: bool = False\n\"\"\"Whether to accept ragged arrays.\"\"\"\nval_conv: Converter[U] = dataclasses.field(init=False)\n\"\"\"[`Converter`][pane.converters.Converter] for value type\"\"\"\ndef __post_init__(self):\nself.val_conv = make_converter(self.val_type)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nword = 'nested sequence' if self.ragged else 'n-d array'\nreturn f\"{pluralize(word, plural, article='a')} of {self.val_conv.expected(True)}\"\n@staticmethod\ndef _check_shape(val: NestedSequence[t.Any], dim: int = 0) -&gt; t.Tuple[int, ...]:\nif not data_is_sequence(val):\n# single value\nreturn ()\nshapes = [NestedSequenceConverter._check_shape(v, dim+1) for v in val]\nif len(shapes) == 0:\nreturn (0,)\nshape = shapes[0]\nif not all(s == shape for s in shapes):\nraise ValueError(f\"shape mismatch at dim {dim}. Sub-shapes: {shapes}\")\nnew_shape = (len(shapes), *shape)\nreturn new_shape\ndef try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nresult = self._try_convert(val)\nif not self.ragged:\ntry:\nself._check_shape(result)\nexcept ValueError:\nraise ParseInterrupt()\nreturn self.constructor(result)\ndef _try_convert(self, val: t.Any) -&gt; NestedSequence[U]:\nif not data_is_sequence(val):\n# single value\nreturn self.val_conv.try_convert(val)\nvals = list(map(self._try_convert, val))\nreturn t.cast(NestedSequence[U], vals)\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif (node := self._collect_errors(val)) is not None:\nreturn node\nval = self._try_convert(val)\nif not self.ragged:\ntry:\nself._check_shape(val)\nexcept ValueError as e:\nreturn WrongTypeError(self.expected(), val, info=e.args[0])\ntry:\nself.constructor(val)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\ndef _collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\nif not data_is_sequence(val):\nreturn self.val_conv.collect_errors(val)\nnodes = {}\nfor (i, v) in enumerate(val):\nif (node := self._collect_errors(v)) is not None:\nnodes[i] = node\nif len(nodes):\nreturn ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.val_type","title":"<code>val_type: t.Type[U]</code>  <code>instance-attribute</code>","text":"<p>Inner type to convert to</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.constructor","title":"<code>constructor: t.Callable[[NestedSequence[U]], T]</code>  <code>instance-attribute</code>","text":"<p>Constructor to call.</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.ragged","title":"<code>ragged: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to accept ragged arrays.</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.val_conv","title":"<code>val_conv: Converter[U] = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p><code>Converter</code> for value type</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"\n    Convert ``val`` into a data interchange format.\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\nreturn into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nword = 'nested sequence' if self.ragged else 'n-d array'\nreturn f\"{pluralize(word, plural, article='a')} of {self.val_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nresult = self._try_convert(val)\nif not self.ragged:\ntry:\nself._check_shape(result)\nexcept ValueError:\nraise ParseInterrupt()\nreturn self.constructor(result)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif (node := self._collect_errors(val)) is not None:\nreturn node\nval = self._try_convert(val)\nif not self.ragged:\ntry:\nself._check_shape(val)\nexcept ValueError as e:\nreturn WrongTypeError(self.expected(), val, info=e.args[0])\ntry:\nself.constructor(val)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter","title":"<code>ConditionalConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[FromDataT]</code>, <code>Converter[FromDataT]</code></p> <p>Converter which applies an arbitrary pre-condition to the converted value.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass ConditionalConverter(t.Generic[FromDataT], Converter[FromDataT]):\n\"\"\"\n    Converter which applies an arbitrary pre-condition to the converted value.\n    \"\"\"\ninner_type: t.Union[t.Type[FromDataT], Converter[FromDataT]]\n\"\"\"Inner type to apply condition to\"\"\"\ncondition: t.Callable[[FromDataT], bool]\n\"\"\"Function to evaluate condition\"\"\"\ncondition_name: str\n\"\"\"Human-readable name of condition\"\"\"\nmake_expected: t.Callable[[str, bool], str]\n\"\"\"Function which takes ``(expected, plural)`` and makes a compound ``expected``.\"\"\"\ninner: Converter[FromDataT] = dataclasses.field(init=False)\n\"\"\"Inner sub-converter\"\"\"\ndef __post_init__(self):\nif isinstance(self.inner_type, Converter):\nself.inner = self.inner_type\nelse:\nself.inner = make_converter(t.cast(t.Type[FromDataT], self.inner_type))\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn self.inner.into_data(val)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn self.make_expected(self.inner.expected(plural), plural)\ndef try_convert(self, val: t.Any) -&gt; FromDataT:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner.try_convert(val)\ntry:\nif self.condition(val):\nreturn val\nexcept Exception:\npass\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nconv_val = self.inner.try_convert(val)\nexcept ParseInterrupt:\n# TODO with_expected() here\nreturn self.inner.collect_errors(val)\ntry:\n# condition failed\nif not self.condition(conv_val):\nreturn ConditionFailedError(self.expected(), val, self.condition_name)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn ConditionFailedError(self.expected(), val, self.condition_name, tb)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.inner_type","title":"<code>inner_type: t.Union[t.Type[FromDataT], Converter[FromDataT]]</code>  <code>instance-attribute</code>","text":"<p>Inner type to apply condition to</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.condition","title":"<code>condition: t.Callable[[FromDataT], bool]</code>  <code>instance-attribute</code>","text":"<p>Function to evaluate condition</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.condition_name","title":"<code>condition_name: str</code>  <code>instance-attribute</code>","text":"<p>Human-readable name of condition</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.make_expected","title":"<code>make_expected: t.Callable[[str, bool], str]</code>  <code>instance-attribute</code>","text":"<p>Function which takes <code>(expected, plural)</code> and makes a compound <code>expected</code>.</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.inner","title":"<code>inner: Converter[FromDataT] = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner sub-converter</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nreturn self.inner.into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn self.make_expected(self.inner.expected(plural), plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; FromDataT:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner.try_convert(val)\ntry:\nif self.condition(val):\nreturn val\nexcept Exception:\npass\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nconv_val = self.inner.try_convert(val)\nexcept ParseInterrupt:\n# TODO with_expected() here\nreturn self.inner.collect_errors(val)\ntry:\n# condition failed\nif not self.condition(conv_val):\nreturn ConditionFailedError(self.expected(), val, self.condition_name)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn ConditionFailedError(self.expected(), val, self.condition_name, tb)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter","title":"<code>EnumConverter</code>","text":"<p>             Bases: <code>Converter[Enum]</code></p> Source code in <code>pane/converters.py</code> <pre><code>class EnumConverter(Converter[enum.Enum]):\ndef __init__(self, ty: t.Type[enum.Enum]):\nfrom pane.convert import _DataType  # type: ignore\nif issubclass(ty, enum.Flag):\nraise TypeError(\"Flag enums are not currently supported\")\nself.ty: t.Type[enum.Enum] = ty\nmembers = ty.__members__.values()\ntry:\nself.val_map = {member.value: member for member in members}\nexcept TypeError:\nraise TypeError(\"All enum members must be hashable\")\nself.member_vals = tuple(self.val_map.keys())\nif not all(isinstance(val, _DataType) for val in self.member_vals):\nraise TypeError(\"All enum members must be data-interchange types\")\nself.inner_ty = type_union(map(type, self.member_vals))\nself.inner_conv = make_converter(self.inner_ty)\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nif isinstance(val, self.ty):\nreturn val.value  # guaranteed to be data-interchange type\nreturn into_data(val)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nl = list_phrase(tuple(map(str, self.member_vals)))\nreturn f\"{pluralize('member', plural)} of enum '{self.ty.__name__}' ({l})\"\ndef try_convert(self, val: t.Any) -&gt; enum.Enum:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner_conv.try_convert(val)\ntry:\nreturn self.val_map[val]\nexcept KeyError:\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nval = self.inner_conv.try_convert(val)\nexcept ParseInterrupt:\nreturn self.inner_conv.collect_errors(val)\ntry:\nself.val_map[val]\nreturn None\nexcept KeyError:\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.ty","title":"<code>ty: t.Type[enum.Enum] = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.val_map","title":"<code>val_map = {member.value: memberfor member in members}</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.member_vals","title":"<code>member_vals = tuple(self.val_map.keys())</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.inner_ty","title":"<code>inner_ty = type_union(map(type, self.member_vals))</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.inner_conv","title":"<code>inner_conv = make_converter(self.inner_ty)</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\nif isinstance(val, self.ty):\nreturn val.value  # guaranteed to be data-interchange type\nreturn into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nl = list_phrase(tuple(map(str, self.member_vals)))\nreturn f\"{pluralize('member', plural)} of enum '{self.ty.__name__}' ({l})\"\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; enum.Enum:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner_conv.try_convert(val)\ntry:\nreturn self.val_map[val]\nexcept KeyError:\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nval = self.inner_conv.try_convert(val)\nexcept ParseInterrupt:\nreturn self.inner_conv.collect_errors(val)\ntry:\nself.val_map[val]\nreturn None\nexcept KeyError:\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter","title":"<code>DelegateConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[T, U]</code>, <code>Converter[T]</code></p> <p>Converter which delegates to a sub-converter, and then attempts to construct a different type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass DelegateConverter(t.Generic[T, U], Converter[T]):\n\"\"\"\n    Converter which delegates to a sub-converter, and then attempts\n    to construct a different type\n    \"\"\"\nfrom_type: t.Type[U]\n\"\"\"Inner type to convert to\"\"\"\nconstructor: t.Callable[[U], T]\n\"\"\"Constructor for outer type\"\"\"\nexpect: t.Optional[str] = None\n\"\"\"Expected value. Defaults to inner expected value.\"\"\"\nexpect_plural: t.Optional[str] = None\n\"\"\"Plural expected value. Defaults to inner expected value.\"\"\"\ninner: Converter[U] = dataclasses.field(init=False)\n\"\"\"Inner sub-converter\"\"\"\ndef __post_init__(self):\nself.inner = make_converter(self.from_type)\nself.expect = self.expect or self.from_type.__name__\nself.expect_plural = self.expect_plural or self.expect\ndef into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n# TODO: this is a hack, because we can't easily convert T back to U\ntry:\nreturn self.inner.into_data(val)\nexcept Exception:\npass\nreturn into_data(val)\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn t.cast(str, self.expect_plural if plural else self.expect)\ndef try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner.try_convert(val)\ntry:\nreturn self.constructor(val)\nexcept Exception:\nraise ParseInterrupt from None\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nconv_val = self.inner.try_convert(val)\nexcept ParseInterrupt:\n# TODO with_expected() here\nreturn self.inner.collect_errors(val)\ntry:\nself.constructor(conv_val)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.from_type","title":"<code>from_type: t.Type[U]</code>  <code>instance-attribute</code>","text":"<p>Inner type to convert to</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.constructor","title":"<code>constructor: t.Callable[[U], T]</code>  <code>instance-attribute</code>","text":"<p>Constructor for outer type</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.expect","title":"<code>expect: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected value. Defaults to inner expected value.</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.expect_plural","title":"<code>expect_plural: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plural expected value. Defaults to inner expected value.</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.inner","title":"<code>inner: Converter[U] = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner sub-converter</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n\"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n# TODO: this is a hack, because we can't easily convert T back to U\ntry:\nreturn self.inner.into_data(val)\nexcept Exception:\npass\nreturn into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn t.cast(str, self.expect_plural if plural else self.expect)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nval = self.inner.try_convert(val)\ntry:\nreturn self.constructor(val)\nexcept Exception:\nraise ParseInterrupt from None\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\ntry:\nconv_val = self.inner.try_convert(val)\nexcept ParseInterrupt:\n# TODO with_expected() here\nreturn self.inner.collect_errors(val)\ntry:\nself.constructor(conv_val)\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter","title":"<code>PatternConverter</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[AnyStr]</code>, <code>Converter[Pattern[AnyStr]]</code></p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass PatternConverter(t.Generic[t.AnyStr], Converter[re.Pattern[t.AnyStr]]):\nty: t.Type[t.AnyStr]\nty_conv: Converter[t.AnyStr]\ndef __init__(self, ty: t.Type[t.AnyStr] = str, *args: t.Any):\nif len(args) &gt; 0:\nraise TypeError(\"PatternConverter takes only one type argument\")\nself.ty = ty\nif not issubclass(ty, (str, bytes)):\nraise TypeError(f\"Pattern only accepts a 'str' or 'bytes' type argument, instead got '{ty!r}'\")\nself.ty_conv = make_converter(self.ty)\ndef into_data(self, val: t.Any) -&gt; t.AnyStr:\nassert isinstance(val, re.Pattern)\nreturn t.cast(re.Pattern[t.AnyStr], val).pattern\ndef expected(self, plural: bool = False) -&gt; str:\nty = 'bytes' if self.ty is bytes else 'string'\nreturn pluralize(f'{ty} regex pattern', plural, article='a')\ndef try_convert(self, val: t.Any) -&gt; re.Pattern[t.AnyStr]:\nif isinstance(val, re.Pattern):\nval = t.cast(re.Pattern[t.Any], val).pattern\ns = self.ty_conv.try_convert(val)\ntry:\nreturn re.compile(s)\nexcept Exception:\nraise ParseInterrupt from None\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\nif isinstance(val, re.Pattern):\nval = t.cast(re.Pattern[t.Any], val).pattern\ntry:\ns = self.ty_conv.try_convert(val)\nexcept ParseInterrupt:\nreturn WrongTypeError(self.expected(), val)\ntry:\nre.compile(s)\nexcept re.error as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.ty","title":"<code>ty: t.Type[t.AnyStr] = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.PatternConverter.ty_conv","title":"<code>ty_conv: Converter[t.AnyStr] = make_converter(self.ty)</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.PatternConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; t.AnyStr:\nassert isinstance(val, re.Pattern)\nreturn t.cast(re.Pattern[t.AnyStr], val).pattern\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.expected","title":"<code>expected(plural=False)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\nty = 'bytes' if self.ty is bytes else 'string'\nreturn pluralize(f'{ty} regex pattern', plural, article='a')\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.try_convert","title":"<code>try_convert(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; re.Pattern[t.AnyStr]:\nif isinstance(val, re.Pattern):\nval = t.cast(re.Pattern[t.Any], val).pattern\ns = self.ty_conv.try_convert(val)\ntry:\nreturn re.compile(s)\nexcept Exception:\nraise ParseInterrupt from None\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\nif isinstance(val, re.Pattern):\nval = t.cast(re.Pattern[t.Any], val).pattern\ntry:\ns = self.ty_conv.try_convert(val)\nexcept ParseInterrupt:\nreturn WrongTypeError(self.expected(), val)\ntry:\nre.compile(s)\nexcept re.error as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nreturn None\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter","title":"<code>DatetimeConverter</code>","text":"<p>             Bases: <code>Converter[DatetimeT]</code>, <code>Generic[DatetimeT]</code></p> <p>Converter for a simple scalar type, constructible from a list of allowed types.</p> Source code in <code>pane/converters.py</code> <pre><code>class DatetimeConverter(Converter[DatetimeT], t.Generic[DatetimeT]):\n\"\"\"\n    Converter for a simple scalar type,\n    constructible from a list of allowed types.\n    \"\"\"\n_date_types: t.Tuple[type, ...] = (datetime.date, datetime.time, datetime.datetime)\n_expected: t.Mapping[type, str] = {\ndatetime.date: \"date\",\ndatetime.datetime: \"datetime\",\ndatetime.time: \"time\",\n}\ndef __init__(self, ty: t.Type[DatetimeT]):\nself.ty = ty\nself.super_ty: t.Type[DatetimeT]\nif ty in self._date_types:\nself.super_ty = ty\nreturn\nfor date_ty in self._date_types:\nif issubclass(ty, date_ty):\nself.super_ty = t.cast(t.Type[DatetimeT], date_ty)\nreturn\nraise TypeError(f\"Only types {list_phrase([repr(str(ty)) for ty in self._date_types])} are supported\")\ndef __eq__(self, other: t.Any) -&gt; bool:\nreturn type(self) == type(other) and self.ty == other.ty\ndef expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(self._expected[self.super_ty], plural, article='a')\ndef into_data(self, val: t.Any) -&gt; str:\nif isinstance(val, (datetime.time, datetime.date, datetime.datetime)):\nreturn val.isoformat()\nreturn str(val)\n#                input type:\n# output type:     date    datetime  time    str\n#          date     id     .date()   error  parse\n#      datetime   combine     id     error  parse\n#          time    error   .timetz()  id    parse\ndef from_datetime(self, dt: datetime.datetime) -&gt; DatetimeT:\nd: t.Mapping[type, t.Callable[[datetime.datetime], DatetimeT]] = {\n# datetime to datetime\ndatetime.datetime: lambda dt: t.cast(DatetimeT, dt),\n# datetime to time\ndatetime.time: lambda dt: t.cast(DatetimeT, dt.time()),\n# datetime to date\ndatetime.date: lambda dt: t.cast(DatetimeT, dt.date()),\n}\nreturn d[self.super_ty](dt)\ndef from_date(self, dt: datetime.date) -&gt; DatetimeT:\ndef err(val: t.Any):\nraise TypeError()\nd: t.Mapping[type, t.Callable[[datetime.date], DatetimeT]] = {\n# date to datetime\ndatetime.datetime: lambda date: t.cast(DatetimeT, datetime.datetime.combine(date, datetime.time())),\n# date to date\ndatetime.date: lambda date: t.cast(DatetimeT, date),\ndatetime.time: err,\n}\nreturn d[self.super_ty](dt)\ndef try_convert(self, val: t.Any) -&gt; DatetimeT:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif isinstance(val, str):\n# parse string\ntry:\nreturn t.cast(DatetimeT, self.ty.fromisoformat(val))\nexcept ValueError:\nraise ParseInterrupt() from None\nif isinstance(val, datetime.datetime):\n# from datetime, to datetime, date, or time\nreturn self.from_datetime(val)\nelif isinstance(val, datetime.time):\n# from time, to time only\nif self.super_ty == datetime.time:\nreturn t.cast(DatetimeT, val)\nelif isinstance(val, datetime.date):\n# from date, to date or datetime\nif self.super_ty != datetime.time:\nreturn self.from_date(val)\nraise ParseInterrupt()\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif isinstance(val, str):\n# parse string\ntry:\nself.ty.fromisoformat(val)\nreturn None\nexcept ValueError as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nif isinstance(val, datetime.datetime):\nreturn None\nelif isinstance(val, datetime.time):\nif self.super_ty == datetime.time:\nreturn None\nelif isinstance(val, datetime.date):\nif self.super_ty != datetime.time:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeConverter.super_ty","title":"<code>super_ty: t.Type[DatetimeT]</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n\"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\nreturn pluralize(self._expected[self.super_ty], plural, article='a')\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; str:\nif isinstance(val, (datetime.time, datetime.date, datetime.datetime)):\nreturn val.isoformat()\nreturn str(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.from_datetime","title":"<code>from_datetime(dt)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def from_datetime(self, dt: datetime.datetime) -&gt; DatetimeT:\nd: t.Mapping[type, t.Callable[[datetime.datetime], DatetimeT]] = {\n# datetime to datetime\ndatetime.datetime: lambda dt: t.cast(DatetimeT, dt),\n# datetime to time\ndatetime.time: lambda dt: t.cast(DatetimeT, dt.time()),\n# datetime to date\ndatetime.date: lambda dt: t.cast(DatetimeT, dt.date()),\n}\nreturn d[self.super_ty](dt)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.from_date","title":"<code>from_date(dt)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def from_date(self, dt: datetime.date) -&gt; DatetimeT:\ndef err(val: t.Any):\nraise TypeError()\nd: t.Mapping[type, t.Callable[[datetime.date], DatetimeT]] = {\n# date to datetime\ndatetime.datetime: lambda date: t.cast(DatetimeT, datetime.datetime.combine(date, datetime.time())),\n# date to date\ndatetime.date: lambda date: t.cast(DatetimeT, date),\ndatetime.time: err,\n}\nreturn d[self.super_ty](dt)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; DatetimeT:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nif isinstance(val, str):\n# parse string\ntry:\nreturn t.cast(DatetimeT, self.ty.fromisoformat(val))\nexcept ValueError:\nraise ParseInterrupt() from None\nif isinstance(val, datetime.datetime):\n# from datetime, to datetime, date, or time\nreturn self.from_datetime(val)\nelif isinstance(val, datetime.time):\n# from time, to time only\nif self.super_ty == datetime.time:\nreturn t.cast(DatetimeT, val)\nelif isinstance(val, datetime.date):\n# from date, to date or datetime\nif self.super_ty != datetime.time:\nreturn self.from_date(val)\nraise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nif isinstance(val, str):\n# parse string\ntry:\nself.ty.fromisoformat(val)\nreturn None\nexcept ValueError as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nreturn WrongTypeError(self.expected(), val, tb)\nif isinstance(val, datetime.datetime):\nreturn None\nelif isinstance(val, datetime.time):\nif self.super_ty == datetime.time:\nreturn None\nelif isinstance(val, datetime.date):\nif self.super_ty != datetime.time:\nreturn None\nreturn WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.data_is_sequence","title":"<code>data_is_sequence(val)</code>","text":"<p>Return whether <code>val</code> is a sequence-like data type.</p> Source code in <code>pane/converters.py</code> <pre><code>def data_is_sequence(val: t.Any) -&gt; TypeGuard[t.Sequence[t.Any]]:\n\"\"\"Return whether `val` is a sequence-like data type.\"\"\"\nreturn isinstance(val, t.Sequence) and not isinstance(val, (str, bytes, bytearray))\n</code></pre>"},{"location":"api/converters/#pane.converters.data_is_mapping","title":"<code>data_is_mapping(val)</code>","text":"<p>Return whether <code>val</code> is a mapping-like data type.</p> Source code in <code>pane/converters.py</code> <pre><code>def data_is_mapping(val: t.Any) -&gt; TypeGuard[t.Mapping[t.Any, t.Any]]:\n\"\"\"Return whether `val` is a mapping-like data type.\"\"\"\nreturn isinstance(val, (dict, t.Mapping))\n</code></pre>"},{"location":"api/errors/","title":"pane.errors","text":""},{"location":"api/errors/#pane.errors","title":"<code>pane.errors</code>","text":"<p>Error types for <code>pane</code> library.</p>"},{"location":"api/errors/#pane.errors.ParseInterrupt","title":"<code>ParseInterrupt</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised by <code>Converter</code>s to indicate that a given parsing path has failed (without materializing a detailed error message).</p> Source code in <code>pane/errors.py</code> <pre><code>class ParseInterrupt(Exception):\n\"\"\"\n    Raised by [`Converter`][pane.converters.Converter]s to indicate that a given parsing path has failed\n    (without materializing a detailed error message).\n    \"\"\"\n...\n</code></pre>"},{"location":"api/errors/#pane.errors.UnsupportedAnnotation","title":"<code>UnsupportedAnnotation</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a given <code>t.Annotated</code> isn't understood by <code>pane</code>.</p> Source code in <code>pane/errors.py</code> <pre><code>class UnsupportedAnnotation(Exception):\n\"\"\"\n    Raised when a given [`t.Annotated`][typing.Annotated] isn't understood by `pane`.\n    \"\"\"\ndef __init__(self, obj: t.Any):\nself.obj: t.Any = obj\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({self.obj!r})\"\ndef __str__(self) -&gt; str:\nreturn f\"Unsupported annotation: {self.obj!r}\"\n</code></pre>"},{"location":"api/errors/#pane.errors.UnsupportedAnnotation.obj","title":"<code>obj: t.Any = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pane.errors.ConvertError","title":"<code>ConvertError</code>","text":"<p>             Bases: <code>Exception</code></p> <p><code>pane</code> conversion error.</p> <p><code>self.tree</code> contains a detailed error tree, and <code>str(self)</code> is a human-friendly representation of the same.</p> Source code in <code>pane/errors.py</code> <pre><code>class ConvertError(Exception):\n\"\"\"\n    `pane` conversion error.\n    `self.tree` contains a detailed error tree, and `str(self)`\n    is a human-friendly representation of the same.\n    \"\"\"\ndef __init__(self, tree: ErrorNode):\nself.tree: ErrorNode = tree\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({self.tree!r})\"\ndef __str__(self) -&gt; str:\nreturn str(self.tree)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConvertError.tree","title":"<code>tree: ErrorNode = tree</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pane.errors.ErrorNode","title":"<code>ErrorNode</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract node in a conversion error tree</p> Source code in <code>pane/errors.py</code> <pre><code>class ErrorNode(abc.ABC):\n\"\"\"\n    Abstract node in a conversion error tree\n    \"\"\"\n@abc.abstractmethod\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n\"\"\"\n        Print a description of this error to `file`.\n        Parameters:\n          indent: String to indent all extra lines we print\n          inside_sum: Whether we are printing inside a [`SumErrorNode`][pane.errors.SumErrorNode] \n                      and so should omit printing the actual value we got)\n          file: File-like object to print text to\n        \"\"\"\n...\ndef __str__(self) -&gt; str:\nbuf = StringIO()\nself.print_error(file=buf)\nreturn buf.getvalue().rstrip('\\n')\n</code></pre>"},{"location":"api/errors/#pane.errors.ErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>  <code>abstractmethod</code>","text":"<p>Print a description of this error to <code>file</code>.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>str</code> <p>String to indent all extra lines we print</p> <code>''</code> <code>inside_sum</code> <code>bool</code> <p>Whether we are printing inside a <code>SumErrorNode</code>            and so should omit printing the actual value we got)</p> <code>False</code> <code>file</code> <code>TextIO</code> <p>File-like object to print text to</p> <code>stdout</code> Source code in <code>pane/errors.py</code> <pre><code>@abc.abstractmethod\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n\"\"\"\n    Print a description of this error to `file`.\n    Parameters:\n      indent: String to indent all extra lines we print\n      inside_sum: Whether we are printing inside a [`SumErrorNode`][pane.errors.SumErrorNode] \n                  and so should omit printing the actual value we got)\n      file: File-like object to print text to\n    \"\"\"\n...\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongTypeError","title":"<code>WrongTypeError</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass WrongTypeError(ErrorNode):\nexpected: str\n\"\"\"Short description of expected value type\"\"\"\nactual: t.Any\n\"\"\"Actual value received\"\"\"\ncause: t.Optional[traceback.TracebackException] = None\n\"\"\"If this was caused by an error, contains a traceback to that error\"\"\"\ninfo: t.Optional[str] = None\n\"\"\"Additional information to supply on an new line\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nif inside_sum:\nprint(f\"{self.expected}\", file=file)\nelse:\nprint(f\"Expected {self.expected}, instead got `{self.actual}` of type `{type(self.actual).__name__}`\", file=file)\nif self.info is not None:\nprint(f\"{indent}{self.info}\", file=file)\nif self.cause is not None:\ns = f\"{indent}\\n\".join(self.cause.format())\nprint(f\"Caused by exception:\\n{indent}{s}\", file=file)\ndef _get_cause(self) -&gt; str:\n\"\"\"Format `cause` as a human-readable string\"\"\"\nif self.cause is None:\nreturn 'None'\nif isinstance(self.cause, traceback.TracebackException):\nreturn \"\\n\".join(self.cause.format_exception_only())\nreturn \"\\n\".join(traceback.format_exception(type(self.cause), self.cause, None))\ndef __repr__(self) -&gt; str:\nreturn f\"WrongTypeError(expected={self.expected!r}, actual={self.actual!r}, cause={self._get_cause()!r}, info={self.info!r})\"\ndef __eq__(self, other: t.Any) -&gt; bool:\n# mostly useful for testing\nif not self.__class__ == other.__class__:\nreturn False\nreturn (\nself.expected == other.expected and\nself.actual == other.actual and\nself.info == other.info and\nself._get_cause() == other._get_cause()\n)\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongTypeError.expected","title":"<code>expected: str</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.actual","title":"<code>actual: t.Any</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.cause","title":"<code>cause: t.Optional[traceback.TracebackException] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If this was caused by an error, contains a traceback to that error</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.info","title":"<code>info: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional information to supply on an new line</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nif inside_sum:\nprint(f\"{self.expected}\", file=file)\nelse:\nprint(f\"Expected {self.expected}, instead got `{self.actual}` of type `{type(self.actual).__name__}`\", file=file)\nif self.info is not None:\nprint(f\"{indent}{self.info}\", file=file)\nif self.cause is not None:\ns = f\"{indent}\\n\".join(self.cause.format())\nprint(f\"Caused by exception:\\n{indent}{s}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongLenError","title":"<code>WrongLenError</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass WrongLenError(ErrorNode):\nexpected: str\n\"\"\"Short description of expected value type\"\"\"\nexpected_len: t.Tuple[int, int]\n\"\"\"(min, max) expected value length\"\"\"\nactual: t.Any\n\"\"\"Actual value received\"\"\"\nactual_len: int\n\"\"\"Actual length received\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nlen_range = '-'.join(map(str, self.expected_len))\nif inside_sum:\nprint(f\"{self.expected} (length {len_range})\", file=file)\nelse:\nprint(f\"Expected {self.expected} of length {len_range}, instead got `{self.actual}` of length {self.actual_len}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongLenError.expected","title":"<code>expected: str</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.WrongLenError.expected_len","title":"<code>expected_len: t.Tuple[int, int]</code>  <code>instance-attribute</code>","text":"<p>(min, max) expected value length</p>"},{"location":"api/errors/#pane.errors.WrongLenError.actual","title":"<code>actual: t.Any</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.WrongLenError.actual_len","title":"<code>actual_len: int</code>  <code>instance-attribute</code>","text":"<p>Actual length received</p>"},{"location":"api/errors/#pane.errors.WrongLenError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nlen_range = '-'.join(map(str, self.expected_len))\nif inside_sum:\nprint(f\"{self.expected} (length {len_range})\", file=file)\nelse:\nprint(f\"Expected {self.expected} of length {len_range}, instead got `{self.actual}` of length {self.actual_len}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConditionFailedError","title":"<code>ConditionFailedError</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass ConditionFailedError(ErrorNode):\nexpected: str\n\"\"\"Short description of expected value type\"\"\"\nactual: t.Any\n\"\"\"Actual value received\"\"\"\ncondition: str\n\"\"\"Name of condition which failed\"\"\"\ncause: t.Optional[traceback.TracebackException] = None\n\"\"\"If this was caused by an error, contains a traceback to that error\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nif inside_sum:\nprint(self.expected, end=\"\", file=file)\nelse:\nprint(f\"Expected {self.expected}, instead got `{self.actual}`\", end=\"\", file=file)\nif self.cause is not None:\ns = f\"{indent}\\n\".join(self.cause.format())\nprint(f\"\\nFailed to call condition '{self.condition}':\\n{indent}{s}\", file=file)\nelse:\nprint(f\" (failed condition '{self.condition}')\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConditionFailedError.expected","title":"<code>expected: str</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.actual","title":"<code>actual: t.Any</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.condition","title":"<code>condition: str</code>  <code>instance-attribute</code>","text":"<p>Name of condition which failed</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.cause","title":"<code>cause: t.Optional[traceback.TracebackException] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If this was caused by an error, contains a traceback to that error</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nif inside_sum:\nprint(self.expected, end=\"\", file=file)\nelse:\nprint(f\"Expected {self.expected}, instead got `{self.actual}`\", end=\"\", file=file)\nif self.cause is not None:\ns = f\"{indent}\\n\".join(self.cause.format())\nprint(f\"\\nFailed to call condition '{self.condition}':\\n{indent}{s}\", file=file)\nelse:\nprint(f\" (failed condition '{self.condition}')\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.DuplicateKeyError","title":"<code>DuplicateKeyError</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass DuplicateKeyError(ErrorNode):\nkey: str\n\"\"\"Offending key\"\"\"\naliases: t.Sequence[str]\n\"\"\"List of keys semantically identical to `key`\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nassert not inside_sum\nprint(f\"Duplicate key {self.key} (same as {'/'.join(self.aliases)})\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.key","title":"<code>key: str</code>  <code>instance-attribute</code>","text":"<p>Offending key</p>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.aliases","title":"<code>aliases: t.Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>List of keys semantically identical to <code>key</code></p>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\nassert not inside_sum\nprint(f\"Duplicate key {self.key} (same as {'/'.join(self.aliases)})\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ProductErrorNode","title":"<code>ProductErrorNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass ProductErrorNode(ErrorNode):\nexpected: str\n\"\"\"Short description of expected value type\"\"\"\nchildren: t.Dict[t.Union[int, str], ErrorNode]\n\"\"\"Map containing errors parsing subfields, if any\"\"\"\nactual: t.Any\n\"\"\"Actual value received\"\"\"\nmissing: t.AbstractSet[t.Union[t.Sequence[str], str]] = dataclasses.field(default_factory=set)\n\"\"\"List of missing fields/equivalent aliases to fields\"\"\"\nextra: t.AbstractSet[str] = dataclasses.field(default_factory=set)\n\"\"\"List of extra, unexpected fields\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n# fuse together non-branching productnodes\nwhile len(self.children) == 1 and not len(self.missing) and not len(self.extra):\nfield, child = next(iter(self.children.items()))\nif not isinstance(child, ProductErrorNode):\nbreak\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {f\"{field}.{k}\": v for (k, v) in child.children.items()}\nmissing = set(f\"{field}.{f}\" for f in child.missing)\nextra = set(f\"{field}.{f}\" for f in child.extra)\nself = ProductErrorNode(self.expected, children, self.actual, missing, extra)\nprint(f\"{'' if inside_sum else 'Expected '}{self.expected}\", file=file)\nfor (field, child) in self.children.items():\nprint(f\"{indent}While parsing field '{field}':\\n{indent}  \", end=\"\", file=file)\nchild.print_error(f\"{indent}  \", file=file)\nfor field in self.missing:\nif not isinstance(field, str):\nfield = '/'.join(field)\nprint(f\"{indent}  Missing required field '{field}'\", file=file)\nfor field in self.extra:\nprint(f\"{indent}  Unexpected field '{field}'\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ProductErrorNode.expected","title":"<code>expected: str</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.children","title":"<code>children: t.Dict[t.Union[int, str], ErrorNode]</code>  <code>instance-attribute</code>","text":"<p>Map containing errors parsing subfields, if any</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.actual","title":"<code>actual: t.Any</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.missing","title":"<code>missing: t.AbstractSet[t.Union[t.Sequence[str], str]] = dataclasses.field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of missing fields/equivalent aliases to fields</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.extra","title":"<code>extra: t.AbstractSet[str] = dataclasses.field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of extra, unexpected fields</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n# fuse together non-branching productnodes\nwhile len(self.children) == 1 and not len(self.missing) and not len(self.extra):\nfield, child = next(iter(self.children.items()))\nif not isinstance(child, ProductErrorNode):\nbreak\nchildren: t.Dict[t.Union[str, int], ErrorNode] = {f\"{field}.{k}\": v for (k, v) in child.children.items()}\nmissing = set(f\"{field}.{f}\" for f in child.missing)\nextra = set(f\"{field}.{f}\" for f in child.extra)\nself = ProductErrorNode(self.expected, children, self.actual, missing, extra)\nprint(f\"{'' if inside_sum else 'Expected '}{self.expected}\", file=file)\nfor (field, child) in self.children.items():\nprint(f\"{indent}While parsing field '{field}':\\n{indent}  \", end=\"\", file=file)\nchild.print_error(f\"{indent}  \", file=file)\nfor field in self.missing:\nif not isinstance(field, str):\nfield = '/'.join(field)\nprint(f\"{indent}  Missing required field '{field}'\", file=file)\nfor field in self.extra:\nprint(f\"{indent}  Unexpected field '{field}'\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.SumErrorNode","title":"<code>SumErrorNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass SumErrorNode(ErrorNode):\nchildren: t.List[ErrorNode]\n\"\"\"Map containing the errors while parsing as each variant\"\"\"\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\ndef _flatten_sum(children: t.Iterable[ErrorNode]) -&gt; t.Iterator[ErrorNode]:\nfor child in children:\nif isinstance(child, SumErrorNode):\nyield from child.children\nelse:\nyield child\nprint(f\"Expected one of:\", file=file)\nactual = None\nfor child in _flatten_sum(self.children):\nprint(f\"{indent}- \", end=\"\", file=file)\nchild.print_error(f\"{indent}  \", inside_sum=True, file=file)\nactual = getattr(child, 'actual', actual)\nprint(f\"{indent}Instead got `{actual}` of type `{type(actual).__name__}`\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.SumErrorNode.children","title":"<code>children: t.List[ErrorNode]</code>  <code>instance-attribute</code>","text":"<p>Map containing the errors while parsing as each variant</p>"},{"location":"api/errors/#pane.errors.SumErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\ndef _flatten_sum(children: t.Iterable[ErrorNode]) -&gt; t.Iterator[ErrorNode]:\nfor child in children:\nif isinstance(child, SumErrorNode):\nyield from child.children\nelse:\nyield child\nprint(f\"Expected one of:\", file=file)\nactual = None\nfor child in _flatten_sum(self.children):\nprint(f\"{indent}- \", end=\"\", file=file)\nchild.print_error(f\"{indent}  \", inside_sum=True, file=file)\nactual = getattr(child, 'actual', actual)\nprint(f\"{indent}Instead got `{actual}` of type `{type(actual).__name__}`\", file=file)\n</code></pre>"},{"location":"api/field/","title":"pane.field","text":""},{"location":"api/field/#pane.field","title":"<code>pane.field</code>","text":""},{"location":"api/field/#pane.field.RenameStyle","title":"<code>RenameStyle = t.Literal['snake', 'camel', 'pascal', 'kebab', 'scream']</code>  <code>module-attribute</code>","text":"<p>List of supported field-renaming styles</p>"},{"location":"api/field/#pane.field.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Represents a materialized dataclass field.</p> <p>Typically instantiated from a <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass Field:\n\"\"\"\n    Represents a materialized dataclass field.\n    Typically instantiated from a [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\nname: str\n\"\"\"Name of field\"\"\"\ntype: type\n\"\"\"Type of field. Must be [`Convertible`][pane.convert.Convertible].\"\"\"\nin_names: t.Sequence[str]\n\"\"\"List of names which convert to this field.\"\"\"\nout_name: str\n\"\"\"Name this field converts into.\"\"\"\ninit: bool = True\n\"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\ndefault: t.Union[t.Any, _Missing] = _MISSING\n\"\"\"Default value for field\"\"\"\ndefault_factory: t.Optional[t.Callable[[], t.Any]] = None\n\"\"\"Default value factory for field\"\"\"\nkw_only: bool = False\n\"\"\"Whether field is keyword only\"\"\"\n@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\ndef has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/field/#pane.field.Field.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of field</p>"},{"location":"api/field/#pane.field.Field.type","title":"<code>type: type</code>  <code>instance-attribute</code>","text":"<p>Type of field. Must be <code>Convertible</code>.</p>"},{"location":"api/field/#pane.field.Field.in_names","title":"<code>in_names: t.Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>List of names which convert to this field.</p>"},{"location":"api/field/#pane.field.Field.out_name","title":"<code>out_name: str</code>  <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/field/#pane.field.Field.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/field/#pane.field.Field.default","title":"<code>default: t.Union[t.Any, _Missing] = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/field/#pane.field.Field.default_factory","title":"<code>default_factory: t.Optional[t.Callable[[], t.Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/field/#pane.field.Field.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/field/#pane.field.Field.make","title":"<code>make(name, ty, in_rename=None, out_rename=None)</code>  <code>classmethod</code>","text":"Source code in <code>pane/field.py</code> <pre><code>@classmethod\ndef make(cls, name: str, ty: type,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nreturn cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n</code></pre>"},{"location":"api/field/#pane.field.Field.has_default","title":"<code>has_default()</code>","text":"<p>Return whether this field has a default value</p> Source code in <code>pane/field.py</code> <pre><code>def has_default(self) -&gt; bool:\n\"\"\"Return whether this field has a default value\"\"\"\nreturn self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec","title":"<code>FieldSpec</code>  <code>dataclass</code>","text":"<p>Represents a field specification.</p> <p>This hasn't been applied to a class yet, so some information is missing.</p> <p>In most cases, end users should use the <code>field()</code> function instead.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass FieldSpec:\n\"\"\"\n    Represents a field specification.\n    This hasn't been applied to a class yet, so some information is missing.\n    In most cases, end users should use the [`field()`][pane.field.field] function instead.\n    \"\"\"\n_: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\nrename: t.Optional[str] = None\n\"\"\"Rename this field. Affects both `in_names` and `out_name`.\"\"\"\nin_names: t.Optional[t.Sequence[str]] = None\n\"\"\"Complete list of names which convert to this field.\"\"\"\naliases: t.Optional[t.Sequence[str]] = None\n\"\"\"Additional list of names which convert to this field (excluding the name in Python).\"\"\"\nout_name: t.Optional[str] = None\n\"\"\"Name this field converts into.\"\"\"\ninit: bool = True\n\"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\ndefault: t.Union[t.Any, _Missing] = _MISSING\n\"\"\"Default value for field\"\"\"\ndefault_factory: t.Optional[t.Callable[[], t.Any]] = None\n\"\"\"Default value factory for field\"\"\"\nkw_only: bool = False\n\"\"\"Whether field is keyword only\"\"\"\nty: t.Union[type, _Missing] = _MISSING\n\"\"\"Type of field, if known. Must be Convertible.\"\"\"\ndef __post_init__(self):\nif isinstance(self.aliases, str):\nself.aliases = [self.aliases]\ndef replace_typevars(self, replacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], t.Type[t.Any]]) -&gt; Self:\n\"\"\"\n        Apply type variable replacements to `self`.\n        \"\"\"\nif self.ty is _MISSING:\nreturn dataclasses.replace(self)\nreturn dataclasses.replace(self, ty=replace_typevars(t.cast(type, self.ty), replacements))\ndef make_field(self, name: str,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n\"\"\"\n        Make a [`Field`][pane.field.Field] from this [`FieldSpec`][pane.field.FieldSpec].\n        \"\"\"\n# out_name\nif self.out_name is not None:\nout_name = self.out_name\nelif self.rename is not None:\nout_name = self.rename\nelse:\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nif sum(p is not None for p in (self.rename, self.aliases, self.in_names)) &gt; 1:\nraise TypeError(\"Can only specify one of 'rename', 'aliases', and 'in_names'\")\nif self.rename is not None:\nin_names = (self.rename,)\nelif self.aliases is not None:\nin_names = (name, *(alias for alias in self.aliases if alias != name))\nelif self.in_names is not None:\nin_names = self.in_names\nelse:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nty = t.cast(type, t.Any if self.ty is _MISSING else self.ty)\nreturn Field(name=name, type=ty, out_name=out_name, in_names=in_names,\ninit=self.init, default=self.default, default_factory=self.default_factory,\nkw_only=self.kw_only)\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec.rename","title":"<code>rename: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rename this field. Affects both <code>in_names</code> and <code>out_name</code>.</p>"},{"location":"api/field/#pane.field.FieldSpec.in_names","title":"<code>in_names: t.Optional[t.Sequence[str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Complete list of names which convert to this field.</p>"},{"location":"api/field/#pane.field.FieldSpec.aliases","title":"<code>aliases: t.Optional[t.Sequence[str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional list of names which convert to this field (excluding the name in Python).</p>"},{"location":"api/field/#pane.field.FieldSpec.out_name","title":"<code>out_name: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/field/#pane.field.FieldSpec.init","title":"<code>init: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/field/#pane.field.FieldSpec.default","title":"<code>default: t.Union[t.Any, _Missing] = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/field/#pane.field.FieldSpec.default_factory","title":"<code>default_factory: t.Optional[t.Callable[[], t.Any]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/field/#pane.field.FieldSpec.kw_only","title":"<code>kw_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/field/#pane.field.FieldSpec.ty","title":"<code>ty: t.Union[type, _Missing] = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of field, if known. Must be Convertible.</p>"},{"location":"api/field/#pane.field.FieldSpec.replace_typevars","title":"<code>replace_typevars(replacements)</code>","text":"<p>Apply type variable replacements to <code>self</code>.</p> Source code in <code>pane/field.py</code> <pre><code>def replace_typevars(self, replacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], t.Type[t.Any]]) -&gt; Self:\n\"\"\"\n    Apply type variable replacements to `self`.\n    \"\"\"\nif self.ty is _MISSING:\nreturn dataclasses.replace(self)\nreturn dataclasses.replace(self, ty=replace_typevars(t.cast(type, self.ty), replacements))\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec.make_field","title":"<code>make_field(name, in_rename=None, out_rename=None)</code>","text":"<p>Make a <code>Field</code> from this <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>def make_field(self, name: str,\nin_rename: t.Optional[t.Sequence[RenameStyle]] = None,\nout_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n\"\"\"\n    Make a [`Field`][pane.field.Field] from this [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n# out_name\nif self.out_name is not None:\nout_name = self.out_name\nelif self.rename is not None:\nout_name = self.rename\nelse:\nout_name = rename_field(name, out_rename) if out_rename is not None else name\nif sum(p is not None for p in (self.rename, self.aliases, self.in_names)) &gt; 1:\nraise TypeError(\"Can only specify one of 'rename', 'aliases', and 'in_names'\")\nif self.rename is not None:\nin_names = (self.rename,)\nelif self.aliases is not None:\nin_names = (name, *(alias for alias in self.aliases if alias != name))\nelif self.in_names is not None:\nin_names = self.in_names\nelse:\nin_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\nty = t.cast(type, t.Any if self.ty is _MISSING else self.ty)\nreturn Field(name=name, type=ty, out_name=out_name, in_names=in_names,\ninit=self.init, default=self.default, default_factory=self.default_factory,\nkw_only=self.kw_only)\n</code></pre>"},{"location":"api/field/#pane.field.rename_field","title":"<code>rename_field(field, style)</code>","text":"<p>Rename <code>field</code> to match style <code>style</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Field name to rename</p> required <code>style</code> <code>RenameStyle</code> <p>Style to match</p> required Source code in <code>pane/field.py</code> <pre><code>def rename_field(field: str, style: RenameStyle) -&gt; str:\n\"\"\"\n    Rename `field` to match style `style`.\n    Parameters:\n        field: Field name to rename\n        style: Style to match\n    \"\"\"\nreturn _CONVERT_FNS[style](_split_field_name(field))\n</code></pre>"},{"location":"api/field/#pane.field.field","title":"<code>field(*, rename=None, in_names=None, aliases=None, out_name=None, init=True, default=_MISSING, default_factory=None, kw_only=False)</code>","text":"<p>Annotate a dataclass field.</p> <p>Parameters:</p> Name Type Description Default <code>rename</code> <code>Optional[str]</code> <p>Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.</p> <code>None</code> <code>in_names</code> <code>Optional[Sequence[str]]</code> <p>List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike <code>aliases</code>).</p> <code>None</code> <code>aliases</code> <code>Optional[Sequence[str]]</code> <p>List of aliases (additional names) for this field. Includes the field name inside Python (unlike <code>in_names</code>).</p> <code>None</code> <code>out_name</code> <code>Optional[str]</code> <p>Name which this field should convert into.</p> <code>None</code> <code>init</code> <code>bool</code> <p>If <code>False</code>, this field won't be touched by <code>pane</code>, and it's up to the class to initialize it in <code>__post_init__</code>.</p> <code>True</code> <code>default</code> <code>Union[T, _Missing]</code> <p>Default value for field</p> <code>_MISSING</code> <code>default_factory</code> <code>Optional[Callable[[], T]]</code> <p>Default value factory for field</p> <code>None</code> <code>kw_only</code> <code>bool</code> <p>Whether the field is keyword-only.</p> <code>False</code> Source code in <code>pane/field.py</code> <pre><code>def field(*,\nrename: t.Optional[str] = None,\nin_names: t.Optional[t.Sequence[str]] = None,\naliases: t.Optional[t.Sequence[str]] = None,\nout_name: t.Optional[str] = None,\ninit: bool = True,\ndefault: t.Union[T, _Missing] = _MISSING,\ndefault_factory: t.Optional[t.Callable[[], T]] = None,\nkw_only: bool = False,\n) -&gt; t.Any:\n\"\"\"\n    Annotate a dataclass field.\n    Parameters:\n      rename: Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.\n      in_names: List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike `aliases`).\n      aliases: List of aliases (additional names) for this field. Includes the field name inside Python (unlike `in_names`).\n      out_name: Name which this field should convert into.\n      init: If `False`, this field won't be touched by `pane`, and it's up to the class to initialize it in `__post_init__`.\n      default: Default value for field\n      default_factory: Default value factory for field\n      kw_only: Whether the field is keyword-only.\n    \"\"\"\nreturn FieldSpec(\nrename=rename, in_names=in_names, aliases=aliases, out_name=out_name,\ninit=init, default=default, default_factory=default_factory, kw_only=kw_only\n)\n</code></pre>"},{"location":"api/types/","title":"pane.types","text":""},{"location":"api/types/#pane.types","title":"<code>pane.types</code>","text":"<p>Helper types for use with <code>pane.convert</code> and dataclasses.</p>"},{"location":"api/types/#pane.types.Num","title":"<code>Num = t.TypeVar('Num', bound=t.Union[int, float])</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.PositiveInt","title":"<code>PositiveInt = t.Annotated[int, Positive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonNegativeInt","title":"<code>NonNegativeInt = t.Annotated[int, NonNegative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NegativeInt","title":"<code>NegativeInt = t.Annotated[int, Negative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonPositiveInt","title":"<code>NonPositiveInt = t.Annotated[int, NonPositive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.PositiveFloat","title":"<code>PositiveFloat = t.Annotated[float, Positive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonNegativeFloat","title":"<code>NonNegativeFloat = t.Annotated[float, NonNegative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NegativeFloat","title":"<code>NegativeFloat = t.Annotated[float, Negative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonPositiveFloat","title":"<code>NonPositiveFloat = t.Annotated[float, NonPositive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.FiniteFloat","title":"<code>FiniteFloat = t.Annotated[float, Finite]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.ListNotEmpty","title":"<code>ListNotEmpty = t.Annotated[t.List[T], len_range(min=1)]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.Range","title":"<code>Range</code>","text":"<p>             Bases: <code>PaneBase</code>, <code>Generic[Num]</code></p> Source code in <code>pane/types.py</code> <pre><code>class Range(PaneBase, t.Generic[Num],\nin_format=('tuple', 'struct'),\nout_format='struct'):\nstart: Num\nend: Num\nn: t.Optional[NonNegativeInt] = field(default=None)\nstep: t.Optional[Num] = field(default=None, kw_only=True)\ndef __post_init__(self):\ns = sum((self.step is None, self.n is None))\nif s == 0:\nraise TypeError(\"Either 'n' or 'step' may be specified, but not both\")\nif s == 2:\nraise TypeError(\"Either 'n' or 'step' must be specified\")\nspan = self.end - self.start\nif self.step is not None:\nif math.isclose(self.step, 0.):\nraise ValueError(\"'step' should be nonzero\")\nn = 1 + math.ceil(span / self.step - 1e-6) if span &gt; 0 else 0\nobject.__setattr__(self, 'n', n)\nelse:\nassert self.n is not None\nif not isinstance(self.start, float) and span % (self.n - 1):\nraise ValueError(\"Range must be evenly divisible by 'n'\")\nstep = type(self.start)(span / (self.n - 1)) if self.n &gt; 1 else None\nobject.__setattr__(self, 'step', step)\ndef __len__(self) -&gt; int:\nreturn t.cast(int, self.n)\ndef __iter__(self) -&gt; t.Iterator[Num]:\nassert self.n is not None\nif self.n == 0:\nreturn\nval: Num = self.start\nfor _ in range(self.n - 1):\nyield val\nval = t.cast(Num, val + self.step)\nyield self.end\n</code></pre>"},{"location":"api/types/#pane.types.Range.start","title":"<code>start: Num</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.end","title":"<code>end: Num</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.n","title":"<code>n: t.Optional[NonNegativeInt] = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.step","title":"<code>step: t.Optional[Num] = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range._converter","title":"<code>_converter(*args)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; Converter[T]:\nif len(args) &gt; 0:\ncls = t.cast(t.Type[T], cls[tuple(args)])  # type: ignore\nreturn t.cast(Converter[T], PaneConverter(cls))\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_obj","title":"<code>from_obj(obj)</code>  <code>classmethod</code>","text":"<p>Convert <code>obj</code> into <code>cls</code>. Equivalent to <code>convert(obj, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to convert. Must be convertible.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_obj(cls, obj: Convertible) -&gt; Self:\n\"\"\"\n    Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n    Parameters:\n      obj: Object to convert. Must be convertible.\n    \"\"\"\nreturn convert(obj, cls)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_data","title":"<code>from_data(data)</code>  <code>classmethod</code>","text":"<p>Convert <code>data</code> into <code>cls</code>. Equivalent to <code>from_data(data, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataType</code> <p>Data to convert. Must be a data interchange type.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_data(cls, data: DataType) -&gt; Self:\n\"\"\"\n    Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n    Parameters:\n      data: Data to convert. Must be a data interchange type.\n    \"\"\"\nreturn from_data(data, cls)\n</code></pre>"},{"location":"api/types/#pane.types.Range.into_data","title":"<code>into_data()</code>","text":"<p>Convert <code>self</code> into interchange data</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self) -&gt; DataType:\n\"\"\"Convert `self` into interchange data\"\"\"\nreturn into_data(self, self.__class__)\n</code></pre>"},{"location":"api/types/#pane.types.Range.dict","title":"<code>dict(set_only=False)</code>","text":"<p>Return a dict of the fields in <code>self</code></p> <p>Parameters:</p> Name Type Description Default <code>set_only</code> <code>bool</code> <p>If <code>True</code>, return only the fields which have been set</p> <code>False</code> Source code in <code>pane/classes.py</code> <pre><code>def dict(self, set_only: bool = False) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n    Return a dict of the fields in `self`\n    Parameters:\n      set_only: If `True`, return only the fields which have been set\n    \"\"\"\nif set_only:\nreturn {\nk : getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n}\nreturn {\nfield.name: getattr(self, field.name) for field in self.__pane_info__.fields\n}\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_json","title":"<code>from_json(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_json(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport json\nwith open_file(f) as f:\nobj = json.load(f)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_jsons","title":"<code>from_jsons(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_jsons(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a JSON string `s`\n    Parameters:\n      s: JSON string to load from\n    \"\"\"\nimport json\nobj = json.loads(s)\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_yaml","title":"<code>from_yaml(f)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml(cls, f: FileOrPath) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML file `f`\n    Parameters:\n      f: File-like or path-like to load from\n    \"\"\"\nimport yaml\ntry:\nfrom yaml import CSafeLoader as Loader\nexcept ImportError:\nfrom yaml import SafeLoader as Loader\nwith open_file(f) as f:\nobj = list(yaml.load_all(f, Loader))\nreturn cls.from_data(obj)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_yamls","title":"<code>from_yamls(s)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>YAML string to load from</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yamls(cls, s: str) -&gt; Self:\n\"\"\"\n    Load `cls` from a YAML string `s`\n    Parameters:\n      s: YAML string to load from\n    \"\"\"\nfrom io import StringIO\nreturn cls.from_yaml(StringIO(s))\n</code></pre>"},{"location":"api/types/#pane.types.Range.make_unchecked","title":"<code>make_unchecked(*args, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n...\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList","title":"<code>ValueOrList</code>","text":"<p>             Bases: <code>Generic[T]</code></p> Source code in <code>pane/types.py</code> <pre><code>class ValueOrList(t.Generic[T]):\n_inner: t.Union[T, t.List[T]]\n_is_val: bool\ndef __init__(self, val: t.Union[T, t.List[T]], _is_val: bool):\nself._inner = val\nself._is_val = _is_val\n@classmethod\ndef from_val(cls, val: T) -&gt; ValueOrList[T]:\nreturn cls(val, True)\n@classmethod\ndef from_list(cls, l: t.List[T]) -&gt; ValueOrList[T]:\nreturn cls(l, False)\ndef __repr__(self) -&gt; str:\nreturn f\"ValueOrList({self._inner!r})\"\ndef __str__(self) -&gt; str:\nreturn str(self._inner)\ndef __eq__(self, other: t.Any) -&gt; bool:\nif not self.__class__ == other.__class__:\nreturn False\nreturn self._is_val == other._is_val and self._inner == other._inner\n@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; ValueOrListConverter:\narg = args[0] if len(args) &gt; 0 else t.Any\nreturn ValueOrListConverter(arg)\ndef __len__(self) -&gt; int:\nreturn 1 if self._is_val else len(t.cast(t.List[T], self._inner))\ndef map(self, f: t.Callable[[T], U]) -&gt; ValueOrList[U]:\nif self._is_val:\nreturn ValueOrList(f(t.cast(T, self._inner)), True)\nreturn ValueOrList(list(map(f, t.cast(t.List[T], self._inner))), False)\ndef __iter__(self) -&gt; t.Iterator[T]:\nif self._is_val:\nyield t.cast(T, self._inner)\nelse:\nyield from t.cast(t.List[T], self._inner)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.from_val","title":"<code>from_val(val)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef from_val(cls, val: T) -&gt; ValueOrList[T]:\nreturn cls(val, True)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.from_list","title":"<code>from_list(l)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef from_list(cls, l: t.List[T]) -&gt; ValueOrList[T]:\nreturn cls(l, False)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList._converter","title":"<code>_converter(*args)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible]) -&gt; ValueOrListConverter:\narg = args[0] if len(args) &gt; 0 else t.Any\nreturn ValueOrListConverter(arg)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.map","title":"<code>map(f)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def map(self, f: t.Callable[[T], U]) -&gt; ValueOrList[U]:\nif self._is_val:\nreturn ValueOrList(f(t.cast(T, self._inner)), True)\nreturn ValueOrList(list(map(f, t.cast(t.List[T], self._inner))), False)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter","title":"<code>ValueOrListConverter</code>","text":"<p>             Bases: <code>UnionConverter</code></p> Source code in <code>pane/types.py</code> <pre><code>class ValueOrListConverter(UnionConverter):\ndef __init__(self, ty: t.Type[Convertible]):\ntypes = t.cast(t.Sequence[t.Type[Convertible]], (ty, t.List[ty]))\nsuper().__init__(types, lambda v, i: ValueOrList(v, i == 0))\nself.ty = ty\ndef expected(self, plural: bool = False) -&gt; str:\ninner = self.converters[0].expected(plural)\nreturn f\"{inner} or sequence of {inner}\"\ndef into_data(self, val: t.Any) -&gt; DataType:\nif not isinstance(val, ValueOrList):\nreturn into_data(val)\nreturn t.cast(ValueOrList[t.Any], val).map(\nlambda v: into_data(v, self.ty)\n)._inner\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.ValueOrListConverter.types","title":"<code>types: t.Tuple[IntoConverter, ...] = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/types/#pane.types.ValueOrListConverter.converters","title":"<code>converters: t.Tuple[Converter[t.Any], ...] = tuple(map(make_converter, types))</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/types/#pane.types.ValueOrListConverter.constructor","title":"<code>constructor: t.Optional[t.Callable[[t.Any, int], t.Any]] = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/types/#pane.types.ValueOrListConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n\"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\ntry:\nreturn self.try_convert(val)\nexcept ParseInterrupt:\npass\nnode = self.collect_errors(val)\nif node is None:\nraise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n\" This is a bug of the ``Converter`` implementation.\")\nraise ConvertError(node)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.expected","title":"<code>expected(plural=False)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\ninner = self.converters[0].expected(plural)\nreturn f\"{inner} or sequence of {inner}\"\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\nif not isinstance(val, ValueOrList):\nreturn into_data(val)\nreturn t.cast(ValueOrList[t.Any], val).map(\nlambda v: into_data(v, self.ty)\n)._inner\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\nif self.constructor is None:\nreturn val\nreturn self.constructor(val, i)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n\"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\nfor (i, conv) in enumerate(self.converters):\ntry:\nval = conv.try_convert(val)\ntry:\nreturn self.construct(val, i)\nexcept Exception:\npass\nexcept ParseInterrupt:\npass\nraise ParseInterrupt\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n\"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\nfailed_children: t.List[ErrorNode] = []\nfor (i, conv) in enumerate(self.converters):\n# if one branch is successful, the whole type is successful\ntry:\nconv_val = conv.try_convert(val)\nexcept ParseInterrupt:\nfailed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\ncontinue\ntry:\nself.construct(conv_val, i)\nreturn None\nexcept Exception as e:\ntb = e.__traceback__.tb_next  # type: ignore\ntb = traceback.TracebackException(type(e), e, tb)\nfailed_children.append(WrongTypeError(self.expected(), val, tb))\nreturn SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/types/#pane.types.YAMLDocList","title":"<code>YAMLDocList</code>","text":"<p>             Bases: <code>list</code></p> <p><code>list</code> subclass representing a list of objects from YAML documents.</p> Source code in <code>pane/types.py</code> <pre><code>class YAMLDocList(list):  # type: ignore\n\"\"\"\n    `list` subclass representing a list of objects from YAML documents.\n    \"\"\"\n...\n</code></pre>"},{"location":"api/util/","title":"pane.util","text":""},{"location":"api/util/#pane.util","title":"<code>pane.util</code>","text":""},{"location":"api/util/#pane.util.FileOrPath","title":"<code>FileOrPath = t.Union[str, Path, TextIOBase, t.TextIO]</code>  <code>module-attribute</code>","text":""},{"location":"api/util/#pane.util.P","title":"<code>P = ParamSpec('P')</code>  <code>module-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache","title":"<code>KeyCache</code>","text":"<p>             Bases: <code>Generic[P, T]</code></p> Source code in <code>pane/util.py</code> <pre><code>class KeyCache(t.Generic[P, T]):\n_missing = object()\ndef __init__(self, f: t.Callable[P, T], key_f: t.Callable[[t.Any], t.Any] = id, maxsize: t.Optional[int] = None):\nself.maxsize: t.Optional[int] = maxsize\nself.key_f = key_f\nself.inner_f: t.Callable[P, T] = f\nself.cache: t.Dict[t.Tuple[t.Tuple[t.Any, ...], t.Tuple[t.Tuple[str, t.Any], ...]], t.Any] = {}\nself._root: t.List[t.Any] = []\nself._root[:] = [self._root, self._root, None, None]\nself._lock = RLock()\nself.full = self.maxsize == 0\ndef __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\nif self.maxsize is None:\nkey = (tuple(map(self.key_f, args)), tuple((k, self.key_f(v)) for (k, v) in kwargs.items()))\nresult = self.cache.get(key, self._missing)\nif result is not self._missing:\nreturn t.cast(T, result)\nresult = self.inner_f(*args, **kwargs)\nself.cache[key] = result\nreturn result\nkey = (tuple(map(self.key_f, args)), tuple((k, self.key_f(v)) for (k, v) in kwargs.items()))\nwith self._lock:\nlink = self.cache.get(key, None)\nif link is not None:\n# extract this link\nprev_link, next_link, _key, result = link\nprev_link[NEXT] = next_link\nnext_link[PREV] = prev_link\n# and move it to the end of the list\nlast = self._root[PREV]\nlast[NEXT] = self._root[PREV] = link\nlink[PREV] = last\nlink[NEXT] = self._root\nreturn t.cast(T, result)\nresult = self.inner_f(*args, **kwargs)\nwith self._lock:\nif key in self.cache:\npass\nelif self.full:\n# turn the oldest link into the new root\n# and reuse oldroot on the end of the list\noldroot = self._root\noldroot[KEY] = key\noldroot[RESULT] = result\nself._root = oldroot[NEXT]\noldkey = self._root[KEY]\noldresult = self._root[RESULT]  # type: ignore (we want to keep this around for a bit)\nself._root[KEY] = self._root[RESULT] = None\ndel self.cache[oldkey]\nself.cache[key] = oldroot\nelse:\nlast = self._root[PREV]\nlink = [last, self._root, key, result]\nlast[NEXT] = self._root[PREV] = self.cache[key] = link\nself.full = (self.maxsize is not None and len(self.cache) &gt;= self.maxsize)\nreturn result\n</code></pre>"},{"location":"api/util/#pane.util.KeyCache.maxsize","title":"<code>maxsize: t.Optional[int] = maxsize</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.key_f","title":"<code>key_f = key_f</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.inner_f","title":"<code>inner_f: t.Callable[P, T] = f</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.cache","title":"<code>cache: t.Dict[t.Tuple[t.Tuple[t.Any, ...], t.Tuple[t.Tuple[str, t.Any], ...]], t.Any] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.full","title":"<code>full = self.maxsize == 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.open_file","title":"<code>open_file(f, mode='r', newline=None, encoding='utf-8')</code>","text":"<p>Open the given file for text I/O.</p> <p>If given a path-like, opens it with the specified settings. Otherwise, make an effort to reconfigure the encoding, and check that it is readable/writable as specified.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File to open/reconfigure</p> required <code>mode</code> <code>Literal['r', 'w']</code> <p>Mode file should be opened in</p> <code>'r'</code> <code>newline</code> <code>Optional[str]</code> <p>Newline mode file should be opened in</p> <code>None</code> <code>encoding</code> <code>Optional[str]</code> <p>Encoding file should be opened in</p> <code>'utf-8'</code> Source code in <code>pane/util.py</code> <pre><code>def open_file(f: FileOrPath,\nmode: t.Literal['r', 'w'] = 'r',\nnewline: t.Optional[str] = None,\nencoding: t.Optional[str] = 'utf-8') -&gt; AbstractContextManager[TextIOBase]:\n\"\"\"\n    Open the given file for text I/O.\n    If given a path-like, opens it with the specified settings.\n    Otherwise, make an effort to reconfigure the encoding, and\n    check that it is readable/writable as specified.\n    Parameters:\n      f: File to open/reconfigure\n      mode: Mode file should be opened in\n      newline: Newline mode file should be opened in\n      encoding: Encoding file should be opened in\n    \"\"\"\nif not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\nreturn open(f, mode, newline=newline, encoding=encoding)\nif isinstance(f, TextIOWrapper):\nf.reconfigure(newline=newline, encoding=encoding)\nelif isinstance(f, t.TextIO):\nf = TextIOWrapper(f.buffer, newline=newline, encoding=encoding)\nelif isinstance(f, (BufferedIOBase, t.BinaryIO)):\nf = TextIOWrapper(t.cast(t.BinaryIO, f), newline=newline, encoding=encoding)\n_validate_file(f, mode)\nreturn nullcontext(f)  # don't close a f we didn't open\n</code></pre>"},{"location":"api/util/#pane.util.partition","title":"<code>partition(f, iter)</code>","text":"<p>Partition <code>iter</code> into values that satisfy <code>f</code> and those which don't.</p> Source code in <code>pane/util.py</code> <pre><code>def partition(f: t.Callable[[T], bool], iter: t.Iterable[T]) -&gt; t.Tuple[t.Tuple[T, ...], t.Tuple[T, ...]]:\n\"\"\"Partition `iter` into values that satisfy `f` and those which don't.\"\"\"\ntrue: t.List[T] = []\nfalse: t.List[T] = []\nfor val in iter:\nif f(val):\ntrue.append(val)\nelse:\nfalse.append(val)\nreturn (tuple(true), tuple(false))\n</code></pre>"},{"location":"api/util/#pane.util.pluralize","title":"<code>pluralize(word, plural, suffix='s', article=None)</code>","text":"<p>Pluralize <code>word</code> based on the value of <code>plural</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def pluralize(word: str, plural: t.Union[bool, int], suffix: str = 's', article: t.Optional[str] = None) -&gt; str:\n\"\"\"Pluralize `word` based on the value of `plural`.\"\"\"\nif not isinstance(plural, bool):\nplural = plural != 1\narticle = article + \" \" if article is not None and len(article) else \"\"\nreturn (word + suffix) if plural else (article + word)\n</code></pre>"},{"location":"api/util/#pane.util.list_phrase","title":"<code>list_phrase(words, conj='or')</code>","text":"<p>Form an english list phrase from <code>words</code>, using the conjunction <code>conj</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def list_phrase(words: t.Sequence[str], conj: str = 'or') -&gt; str:\n\"\"\"\n    Form an english list phrase from `words`, using the conjunction `conj`.\n    \"\"\"\nif len(words) &lt;= 2:\nreturn f\" {conj} \".join(words)\nreturn \", \".join(words[:-1]) + f\", {conj} {words[-1]}\"\n</code></pre>"},{"location":"api/util/#pane.util.remove_article","title":"<code>remove_article(s)</code>","text":"<p>Remove an article from <code>s</code>, if present.</p> Source code in <code>pane/util.py</code> <pre><code>def remove_article(s: str) -&gt; str:\n\"\"\"Remove an article from `s`, if present.\"\"\"\ns = s.lstrip()\nfor article in ('a ', 'an ', 'the '):\nif s.startswith(article):\nreturn s[len(article):]\nreturn s\n</code></pre>"},{"location":"api/util/#pane.util.collect_typevars","title":"<code>collect_typevars(args)</code>","text":"<p>Collect a list of type variables in <code>args</code></p> <p>Preserves order but removes duplicates (i.e. type variables are returned in the order they are encountered, but no type variable is returned twice).</p> <p>Loosely based on <code>typing._collect_parameters</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def collect_typevars(args: t.Any) -&gt; t.Tuple[t.Union[t.TypeVar, ParamSpec], ...]:\n\"\"\"\n    Collect a list of type variables in `args`\n    Preserves order but removes duplicates (i.e. type variables are returned\n    in the order they are encountered, but no type variable is returned twice).\n    Loosely based on `typing._collect_parameters`.\n    \"\"\"\nd: t.Dict[t.Union[t.TypeVar, ParamSpec], None] = {}  # relies on dicts preserving insertion order\n_collect_typevars(d, args)\nreturn tuple(d)\n</code></pre>"},{"location":"api/util/#pane.util.type_union","title":"<code>type_union(types)</code>","text":"Source code in <code>pane/util.py</code> <pre><code>def type_union(types: t.Iterable[type]) -&gt; type:\nreturn functools.reduce(operator.or_, types)\n</code></pre>"},{"location":"api/util/#pane.util.flatten_union_args","title":"<code>flatten_union_args(types)</code>","text":"<p>Flatten nested unions, returning a single sequence of possible union types.</p> Source code in <code>pane/util.py</code> <pre><code>def flatten_union_args(types: t.Iterable[T]) -&gt; t.Iterator[T]:\n\"\"\"Flatten nested unions, returning a single sequence of possible union types.\"\"\"\nfor ty in types:\nif t.get_origin(ty) is t.Union:\nyield from flatten_union_args(t.get_args(ty))\nelse:\nyield ty\n</code></pre>"},{"location":"api/util/#pane.util.replace_typevars","title":"<code>replace_typevars(ty, replacements)</code>","text":"<p>Apply a list of type-variable replacements to <code>ty</code>, and return the modified type.</p> Source code in <code>pane/util.py</code> <pre><code>def replace_typevars(ty: t.Any,\nreplacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], type]) -&gt; t.Any:\n\"\"\"\n    Apply a list of type-variable replacements to `ty`, and return the modified type.\n    \"\"\"\nif isinstance(ty, (t.TypeVar, ParamSpec)):\nreturn replacements.get(ty, ty)\nif isinstance(ty, t.Sequence) and not isinstance(ty, (str, bytes)):\nreturn type(ty)(replace_typevars(t, replacements) for t in ty)  # type: ignore\nbase = t.get_origin(ty) or ty\nargs = t.get_args(ty)\nif not len(args):\nreturn ty\nargs = (replace_typevars(ty, replacements) for ty in args)\nif base is t.Union:\nargs = tuple(flatten_union_args(args))\n# deduplicate union\nargs = dict.fromkeys(args).keys()\nif len(args) == 1:\n# single-element union, return as value\nreturn next(iter(args))\nreturn base[tuple(args)]  # type: ignore\n</code></pre>"},{"location":"api/util/#pane.util.get_type_hints","title":"<code>get_type_hints(cls)</code>","text":"<p>Extract a dict of type hints from <code>cls</code>. Evaluate forward refs if possible.</p> <p>This is a slightly modified version of typing.get_type_hints.</p> Source code in <code>pane/util.py</code> <pre><code>def get_type_hints(cls: type) -&gt; t.Dict[str, t.Any]:\n\"\"\"\n    Extract a dict of type hints from `cls`. Evaluate forward refs if possible.\n    This is a slightly modified version of [typing.get_type_hints]().\n    \"\"\"\nglobalns = getattr(sys.modules.get(cls.__module__, None), '__dict__', {})\nlocalns = dict(vars(cls))\nd: t.Dict[str, t.Any] = {}\nfor name, value in cls.__dict__.get('__annotations__', {}).items():\nif value is None:\nvalue = type(None)\nif isinstance(value, str):\nvalue = t.ForwardRef(value, is_argument=False, is_class=True)\nif isinstance(value, t.ForwardRef):\n# hack to handle top-level KW_ONLY\nval = value.__forward_value__ if value.__forward_evaluated__ else eval(value.__forward_code__, globalns, localns)\nif val is KW_ONLY:\nd[name] = KW_ONLY\ncontinue\n# private access inside typing module\nvalue = t._eval_type(value, globalns, localns)  # type: ignore\nd[name] = value\nreturn d\n</code></pre>"},{"location":"api/util/#pane.util.broadcast_shapes","title":"<code>broadcast_shapes(*args)</code>","text":"<p>Attempt to broadcast the given shapes together using numpy semantics.</p> <p>Defers to <code>numpy.broadcast_shapes</code> if numpy is available.</p> Source code in <code>pane/util.py</code> <pre><code>def broadcast_shapes(*args: t.Sequence[int]) -&gt; t.Tuple[int, ...]:\n\"\"\"\n    Attempt to broadcast the given shapes together using numpy semantics.\n    Defers to `numpy.broadcast_shapes` if numpy is available.\n    \"\"\"\ntry:\nimport numpy\nreturn numpy.broadcast_shapes(*map(tuple, args))\nexcept ImportError:\npass\n# our own implementation, with worse error messages\nout_shape: t.List[int] = []\nfor ax_lens in zip_longest(*(reversed(arg) for arg in args), fillvalue=1):\nbcast = max(ax_lens)\nif not all(ax_len in (1, bcast) for ax_len in ax_lens):\nshapes = [f\"'{tuple(arg)!r}'\" for arg in args]\nraise ValueError(f\"Couldn't broadcast shapes {list_phrase(shapes, 'and')}\")\nout_shape.append(bcast)\nreturn tuple(out_shape)\n</code></pre>"},{"location":"api/util/#pane.util.is_broadcastable","title":"<code>is_broadcastable(*args)</code>","text":"<p>Return whether <code>args</code> are broadcastable together using numpy semantics.</p> Source code in <code>pane/util.py</code> <pre><code>def is_broadcastable(*args: t.Sequence[int]) -&gt; bool:\n\"\"\"Return whether `args` are broadcastable together using numpy semantics.\"\"\"\ntry:\nbroadcast_shapes(*args)\nreturn True\nexcept ValueError:\nreturn False\n</code></pre>"},{"location":"api/util/#pane.util.key_cache","title":"<code>key_cache(key_f=id, *, maxsize=None)</code>","text":"Source code in <code>pane/util.py</code> <pre><code>def key_cache(key_f: t.Callable[[t.Any], t.Any] = id, *, maxsize: t.Optional[int] = None) -&gt; t.Callable[[t.Callable[P, T]], KeyCache[P, T]]:\ndef inner(f: t.Callable[P, T]) -&gt; KeyCache[P, T]:\nreturn t.cast(KeyCache[P, T], functools.update_wrapper(KeyCache(f, key_f, maxsize), f))\nreturn inner\n</code></pre>"},{"location":"using/advanced/","title":"Under the hood: Advanced usage","text":""},{"location":"using/advanced/#custom-converters","title":"Custom converters","text":"<p>Out-of-the-box, <code>pane</code> supports <code>numpy</code> arrays and datatypes, as well as types which follow the <code>t.Sequence</code>/<code>t.Mapping</code> protocol.</p> <p>However, <code>pane</code> can easily be extended to support additional types. The first step is to create a <code>Converter</code> which handles the type. The <code>Converter</code> interface is quite simple. Three functions are required: <code>expected</code>, <code>try_convert</code>, and <code>collect_errors</code>.</p> <p>Say we have a type <code>CountryCode</code>, which contains a standard country code. <code>CountryCodeConverter</code> should accept a string-like type and convert it to a <code>CountryCode</code>, making sure that the string really is a country code. (In reality, this type could be implemented as <code>t.Literal['gb', 'cn', ...]</code>)</p> <p>An example implementation of <code>CountryCodeConverter</code> is shown below:</p> <pre><code>import typing as t\nfrom pane.errors import WrongTypeError, ErrorNode\nclass CountryCodeConverter:\ncountries = {'gb', 'us', 'cn', 'uk'}\ndef __init__(self, ty: t.Type[CountryCode]):\n# type of CountrySet (could be a subclass)\nself.ty = ty\ndef expected(self, plural: bool = False):\n\"\"\"Return the value we expected (pluralized if `plural`).\"\"\"\nreturn \"country codes\" if plural else \"a country code\"\n# attempt to convert `val`.\n# in this function, we only raise ParseInterrupt, never\n# constructing an error\n# this is to save time in case another conversion branch succeeds\ndef try_convert(self, val: t.Any) -&gt; CountryCode:\n# the only data interchange type we support is `str`. Everything\n# else should error\nif not isinstance(val, str):\nraise ParseInterrupt()\n# check that `val` is a valid country code\nif val not in self.countries:\nraise ParseInterrupt()\nreturn CountryCode(val)\n# after try_convert fails, collect_errors is called\n# to make full error messages.\n# collect_errors should return an error iff try_convert raises ParseInterrupt\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\nif not isinstance(val, str):\n# every ParseInterrupt() in try_convert corresponds\n# to an error in collect_errors\nreturn WrongTypeError(self.expected(), val)\nif val not in self.countries:\nreturn WrongTypeError(self.expected(), val, info=f\"Unknown country code '{val}'\")\nreturn None\n</code></pre> <p>There are a couple ways to inform <code>pane</code> of the presence of <code>CountryCodeConverter</code>. The simplest is through the <code>HasConverter</code> protocol. Just add a class method to <code>CountryCode</code>:</p> <pre><code>class CountryCode:\n...\n@classmethod\ndef _converter(cls: t.Type[T], *args: type) -&gt; CountryCodeConverter:\nif len(args):\nraise TypeError(\"'CountryCode' doesn't support type arguments\")\nreturn CountryCodeConverter(cls)\n</code></pre> <p>Now, <code>convert()</code>, <code>from_data()</code> and dataclasses will work seamlessly with <code>CountryCode</code>.</p>"},{"location":"using/advanced/#supporting-third-party-datatypes","title":"Supporting third-party datatypes","text":"<p>Sometimes you don't have access to a type to add a method to it. In these instances, you may instead add a custom handler to <code>make_converter</code> using <code>register_converter_handler</code>. Say there's a type <code>Foo</code> that we'd like to support. First, we need to make a <code>FooConverter</code> (see Custom converters above). Next, we make a function called <code>foo_converter_handler</code>, and register it:</p> <pre><code>from pane.convert import register_converter_handler\n# called with the type to make a converter for, and any type arguments\ndef foo_converter_handler(ty: t.Any, args: t.Tuple[t.Any, ...]) -&gt; FooConverter:\nif not issubclass(ty, Foo):\nreturn NotImplemented  # not a foo type, can't handle it\nreturn FooConverter(ty, args)\nregister_converter_handler(foo_converter_handler)\n</code></pre> <p>Converter handlers are applied after basic type handlers and the <code>HasConverter</code> protocol (to increase performance), but before handlers for subclasses, <code>tuple</code>s, or <code>dict</code>s.</p>"},{"location":"using/basic/","title":"Basic type conversion: <code>convert</code> &amp; friends","text":"<p>The core of <code>pane</code> is its data conversion routines. The simplest to use is <code>convert</code>:</p> <pre><code>&gt;&gt;&gt; import typing as t\n&gt;&gt;&gt; import pane\n&gt;&gt;&gt; pane.convert(-5., float)  # simple scalar type\n-5.0\n&gt;&gt;&gt; pane.convert([1., 'mystring', 5], (float, str, int))  # tuple-like type\n(1.0, 'mystring', 5)\n&gt;&gt;&gt; pane.convert({'x': 5.0, 'y': 'mystring'}, {'x': float, 'y': str})  # struct-like type\n{'x': 5.0, 'y': 'mystring'}\n&gt;&gt;&gt; pane.convert(5, t.Union[str, int, None])  # untagged union\n5\n</code></pre> <p><code>convert</code> actually performs two separate actions. First, it calls <code>into_data</code> on a value. This attempts to convert the value into a \"data interchange type\", which is a dialect of types supported by all converters.</p> <p>After <code>into_data</code>, <code>convert</code> calls <code>from_data</code>, which attempts to convert the value into the desired type.</p> <p>Currently, the data interchange types are:  - Scalar types: str, bytes, bool, int, float, complex, and None  - Sequences: list, tuple and <code>t.Sequence</code>  - Mappings: dict and <code>t.Mapping</code></p> <p>All implementations of <code>Converter.into_data</code> must output a data interchange type, and all implementations of <code>Converter.convert</code> must handle any data interchange type (even if 'handle' just means raising an error message). Data interchange types may be added in major releases, so <code>Converter</code> implementations should be made robust to new types.</p>"},{"location":"using/condition/","title":"<code>Condition</code>: Adding extra restrictions to types","text":"<p><code>Condition</code> is <code>pane</code>'s solution to field validation. In <code>pane</code>, features are built into the type system whenever possible, increasing composibility and flexibility. So to with value restrictions. These are implemented using <code>t.Annotated</code>.</p> <p>We'll start with some examples:</p> <pre><code>&gt;&gt;&gt; import typing as t\n&gt;&gt;&gt; from pane import convert, val_range, Condition, Positive\n# built-in conditions\n&gt;&gt;&gt; convert(5.0, t.Annotated[float, Positive])\n5.0\n&gt;&gt;&gt; convert(-1.0, t.Annotated[float, Positive])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected a positive float, instead got `-1.0` (failed condition 'positive')\n&gt;&gt;&gt; convert(6.0, t.Annotated[float, val_range(max=5.0)])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected a float satisfying v &lt;= 5.0, instead got `6.0` (failed condition 'v &lt;= 5.0')\n# custom conditions\n&gt;&gt;&gt; convert([0, 1, 2, 4], t.List[t.Annotated[int, Condition(lambda v: v % 2 == 0, name='even')]])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected sequence of ints satisfying even\nWhile parsing field '1':\nExpected an int satisfying even, instead got `1` (failed condition 'even')\n</code></pre> <p>These conditions can be applied at any nesting level, not limited to top-level fields. Conditions also support the <code>&amp;</code> and <code>|</code> bitwise operators (interpreted as boolean operators).</p>"},{"location":"using/dataclasses/","title":"Dataclasses: The ultimate product type","text":"<p><code>pane</code> dataclasses work similarly to many other libraries. They aim to have a superset of the features of the standard library dataclasses. A dataclass can be made by subclassing <code>pane.PaneBase</code>:</p> <pre><code>import pane\nfrom typing import t\nclass MyDataclass(pane.PaneBase):\nx: int = 5  # basic field w/ default\ny: t.Optional[float] = None\n# remaining fields should be keyword only\n_: pane.KW_ONLY  \n# advanced field specification\nz: t.List[float] = pane.field(aliases=('w',), default_factory=list)\n</code></pre>"},{"location":"using/dataclasses/#constructors","title":"Constructors","text":"<p><code>pane</code> automatically makes constructors for you:</p> <pre><code>&gt;&gt;&gt; import inspect; inspect.signature(MyDataclass.__init__)\n&lt;Signature (x: int = 5, y: Optional[float] = None, *, z: list[float] = []) -&gt; None&gt;\n</code></pre> <p><code>MyDataclass.__init__</code> performs conversion on arguments:</p> <pre><code>&gt;&gt;&gt; MyDataclass()\nMyDataclass(x=5, y=None, z=[])\n&gt;&gt;&gt; MyDataclass(z=[5.0, 10.0, 's'])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected sequence of floats\nWhile parsing field '2':\nExpected a float, instead got `s` of type `str`\n</code></pre> <p>To bypass conversion, use <code>Mydataclass.make_unchecked</code> instead:</p> <pre><code>&gt;&gt;&gt; MyDataclass.make_unchecked(z=[5.0, 10.0, 's'])\nMyDataclass(x=5, y=None, z=[5.0, 10.0, 's'])\n</code></pre> <p><code>MyDataclass.from_obj</code>, <code>MyDataclass.from_data</code>, <code>MyDataclass.from_json</code>, and <code>MyDataclass.from_yaml</code> perform conversion from an object:</p> <pre><code># note the use of an alias for 'z'\n&gt;&gt;&gt; MyDataclass.from_data({'x': 10, 'y': 10., 'w': [10.]})\nMyDataclass(x=10, y=10.0, z=[10.0])\n&gt;&gt;&gt; from io import StringIO\n&gt;&gt;&gt; MyDataclass.from_json(StringIO('{\"x\": 10, \"y\": 10.0, \"w\": [10.0]}'))\nMyDataclass(x=10, y=10.0, z=[10.0])\n</code></pre> <p>(<code>from_json</code> and <code>from_yaml</code> take a file-like object or filename. <code>from_jsons</code> and <code>from_yamls</code> take a string).</p>"},{"location":"using/dataclasses/#member-methods","title":"Member methods","text":"<p><code>MyDataclass.into_data</code> performs the reverse operation, converting a dataclass to a data interchange type (usually a dict):</p> <pre><code>&gt;&gt;&gt; MyDataclass(x=10, y=10.0, z=[10.0]).into_data()\n{'x': 10, 'y': 10.0, 'z': [10.0]}\n</code></pre>"},{"location":"using/dataclasses/#index-of-methods","title":"Index of methods","text":"Method name Method type Description <code>__init__</code> classmethod Instantiate a dataclass from data <code>make_unchecked</code> classmethod Instantiate a dataclass from data <code>from_obj</code> classmethod Instantiate a dataclass from a convertible object <code>from_data</code> classmethod Instantiate a dataclass from interchange data <code>from_json</code> classmethod Instantiate a dataclass from a JSON file <code>from_yaml</code> classmethod Instantiate a dataclass from a YAML file <code>from_jsons</code> classmethod Instantiate a dataclass from a JSON string <code>from_yamls</code> classmethod Instantiate a dataclass from a YAML string <code>into_data</code> instance method Convert dataclass into interchange data <code>dict</code> instance method Return dataclass fields as a dict (optionally, return only set fields)"},{"location":"using/tagged/","title":"Tagged unions","text":"<p><code>pane</code> supports parsing tagged unions, which are invaluable in representing complex data types. Unlike a untagged union (represented by <code>t.Union</code>), tagged unions use a discriminating value to separate variants unambiguously.</p> <p>Tagged unions are specified with the <code>Tagged</code> annotation wrapping a <code>t.Union</code>:</p> <pre><code>import pane\nfrom pane.annotations import Tagged\nclass Variant1(pane.PaneBase):\nx: t.Literal['variant1'] = 'variant1'\ny: int = 6\nclass Variant2(pane.PaneBase):\nx: t.Literal['variant2'] = 'variant2'\ny: str = 'mystring'\nclass Variant3(pane.PaneBase):\nx: t.Literal['variant3'] = 'variant3'\ny: int = 6\nz: int = 7\nTaggedUnion = t.Annotated[t.Union[Variant1, Variant2, Variant3], Tagged('x')]\n</code></pre> <p>This specifies a tagged union with a tag (in Python) of <code>'x'</code>. Attribute <code>'x'</code> is examined for each variant type, so that every possible value is uniquely associated with a type.</p> <p>When converting a value, the tag is matched first, and then the variant corresponding to that tag:</p> <pre><code>&gt;&gt;&gt; pane.convert({'x': 'variant3'}, TaggedUnion)\nVariant3(x='variant3', y=6, z=7)\n&gt;&gt;&gt; pane.convert({'x': 'variant2', 'y': 'str'}, TaggedUnion)\nVariant2(x='variant2', y='str')\n&gt;&gt;&gt; pane.convert({'x': 'unknown'}, TaggedUnion)\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected tag 'x' one of 'variant1', 'variant2', or 'variant3', instead got `unknown` of type `str`\n</code></pre> <p>Note that if we had used an untagged union instead, we would have no way to distinguish between <code>Variant1</code> and <code>Variant3</code> in general.</p>"},{"location":"using/tagged/#tagged-union-layouts","title":"Tagged Union Layouts","text":"<p>By default, tagged unions are stored in the 'internally tagged' format, where tags are stored alongside the variant's values.</p> <p>Two other layouts are possible. First, the 'externally tagged' layout:</p> <pre><code>&gt;&gt;&gt; ExtTagged = t.Annotated[t.Union[Variant1, Variant2], Tagged('x', external=True)]\n&gt;&gt;&gt; pane.convert({'variant2': {'y': 'str'}}, ExtTagged)\nVariant2(x='variant2', y='str')\n</code></pre> <p>In this format, the tag is stored as the sole key in a mapping enclosing the variant object. The externally tagged format is often used by functional, type-safe languages such as Rust.</p> <p>The final layout is the 'adjacently tagged' layout:</p> <pre><code>&gt;&gt;&gt; AdjTagged = t.Annotated[t.Union[Variant1, Variant2], Tagged('x', external=('t', 'c'))]\n&gt;&gt;&gt; pane.convert({'t': 'variant1', 'c': {'y': 8}}, AdjTagged)\nVariant1(x='variant1', y=8)\n</code></pre> <p>In this format, the tag and content are stored alongside each other in a mapping. The tuple <code>('t', 'c')</code> specifies the keys identifying the tag and content respectively. This format is often used in Haskell.</p> <p>These tagged union layouts (along with untagged unions) are modeled after the enum representations in Rust's <code>serde</code> library.</p>"}]}