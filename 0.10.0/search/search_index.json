{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-pane","text":"<p><code>pane</code> is a modern data conversion and dataclass library for Python.</p> <p>There are many existing dataclass libraries for Python. <code>pane</code> gains in composibility, flexibility, and simplicity because it treats validating a dataclass as a special case of general type conversion. This base layer is built with robust support for product types, tagged &amp; untagged unions, and custom predicates.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Conversion between arbitrary types</li> <li>Helpful, detailed error messages</li> <li>Conversion to and from dataclasses</li> <li>Optional fields</li> <li>Field renaming</li> <li>Conversion from tuples &amp; dicts</li> <li>Dataclass inheritance</li> <li>Generic dataclasses</li> <li>Condition (field validators)</li> <li>First class typing support</li> <li>Tagged &amp; untagged unions</li> <li>Composable conversion</li> <li>Custom converters and hooks for extension</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><code>pane</code> is available from PyPI. To install:</p> <pre><code>pip install py-pane\n</code></pre> <p><code>pane</code> deliberately has very few depedencies, and has no binary dependencies.</p>"},{"location":"#supported-datatypes","title":"Supported datatypes","text":"<p><code>pane</code> aims to support a broad range of standard library and third-party datatypes. Currently, the following datatypes are supported:</p>"},{"location":"#standard-library","title":"Standard library","text":""},{"location":"#sequencecollection-types","title":"Sequence/collection types:","text":"<ul> <li><code>list</code>/<code>typing.List</code></li> <li><code>tuple</code>/<code>typing.Tuple</code>/<code>typing.Sequence</code>/<code>collections.abc.Sequence</code></li> <li><code>set</code>/<code>typing.Set</code>/<code>collections.abc.Set</code></li> <li><code>frozenset</code>/<code>typing.FrozenSet</code>/<code>collections.abc.FrozenSet</code></li> <li><code>collections.deque</code>/<code>typing.Deque</code></li> </ul>"},{"location":"#tuple-types","title":"Tuple types:","text":"<ul> <li>Heterogeneous: <code>tuple[int, str]</code>/<code>t.Tuple[int, str]</code></li> <li>Homogeneous: <code>tuple[int, ...]</code>/<code>t.Tuple[int, ...]</code></li> <li>Empty: <code>tuple[()]</code>/<code>t.Tuple[()]</code></li> </ul>"},{"location":"#mapping-types","title":"Mapping types:","text":"<ul> <li><code>dict</code>/<code>typing.Dict</code>/<code>typing.Mapping</code>/<code>typing.MutableMapping</code>/<code>collections.abc.Mapping</code>/<code>collections.abc.MutableMapping</code></li> <li><code>collections.defaultdict</code>/<code>typing.DefaultDict</code></li> <li><code>collections.OrderedDict</code>/<code>typing.OrderedDict</code></li> <li><code>collections.Counter</code></li> </ul>"},{"location":"#stringbytes-types","title":"String/bytes types:","text":"<ul> <li><code>str</code></li> <li><code>bytes</code></li> <li><code>bytearray</code></li> </ul>"},{"location":"#numeric-types","title":"Numeric types:","text":"<ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>complex</code></li> <li><code>decimal.Decimal</code></li> <li><code>fraction.Fraction</code></li> </ul>"},{"location":"#datetime-types","title":"Datetime types:","text":"<ul> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> </ul>"},{"location":"#path-like-types","title":"Path-like types:","text":"<ul> <li><code>os.PathLike</code> (currently <code>str</code> only, not <code>bytes</code>)</li> <li><code>pathlib.Path</code>/<code>pathlib.PurePath</code></li> <li><code>pathlib.WindowsPath</code>/<code>pathlib.PureWindowsPath</code></li> <li><code>pathlib.PosixPath</code>/<code>pathlib.PurePosixPath</code></li> </ul>"},{"location":"#other-scalar-types","title":"Other scalar types:","text":"<ul> <li><code>bool</code></li> <li><code>None</code></li> <li><code>re.Pattern</code>/<code>typing.Pattern</code></li> </ul>"},{"location":"#third-party-datatypes","title":"Third-party datatypes","text":"<ul> <li><code>numpy.ndarray</code>/<code>NDArray[]</code></li> </ul>"},{"location":"#supported-typing-constructs","title":"Supported typing constructs","text":"<p>In addition, <code>pane</code> attempts to fully support modern Python type hints. This includes the following:</p> <ul> <li><code>typing.Union</code></li> <li><code>typing.Optional</code></li> <li><code>typing.TypeVar</code></li> <li><code>typing.Generic</code></li> <li><code>typing.Literal</code></li> <li><code>typing.Any</code></li> <li><code>typing.Annotated</code></li> </ul>"},{"location":"#comparison-to-other-libraries","title":"Comparison to other libraries","text":"<p>Coming soon</p>"},{"location":"api/","title":"<code>pane</code> API Reference","text":"<p>Top-level exports:</p>"},{"location":"api/#pane.__all__","title":"<code>pane.__all__ = ['DataType', 'Convertible', 'from_data', 'into_data', 'convert', 'ConvertError', 'PaneBase', 'PaneOptions', 'field', 'Field', 'KW_ONLY', 'Condition', 'val_range', 'len_range', 'Positive', 'NonPositive', 'Negative', 'NonNegative', 'Empty', 'NonEmpty', 'from_json', 'from_yaml', 'from_yaml_all', 'write_json', 'write_yaml']</code>  <code>module-attribute</code>","text":""},{"location":"api/annotations/","title":"pane.annotations","text":""},{"location":"api/annotations/#pane.annotations","title":"<code>pane.annotations</code>","text":"<p>Annotations supported by <code>pane.convert()</code> and dataclasses.</p>"},{"location":"api/annotations/#pane.annotations.Positive","title":"<code>Positive = adjective_condition(lambda v: v &gt; 0, 'positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be positive</p>"},{"location":"api/annotations/#pane.annotations.Negative","title":"<code>Negative = adjective_condition(lambda v: v &lt; 0, 'negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be negative</p>"},{"location":"api/annotations/#pane.annotations.NonPositive","title":"<code>NonPositive = adjective_condition(lambda v: v &lt;= 0, 'non-positive')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-positive</p>"},{"location":"api/annotations/#pane.annotations.NonNegative","title":"<code>NonNegative = adjective_condition(lambda v: v &gt;= 0, 'non-negative')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be non-negative</p>"},{"location":"api/annotations/#pane.annotations.Finite","title":"<code>Finite = adjective_condition(math.isfinite, 'finite')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be finite</p>"},{"location":"api/annotations/#pane.annotations.Empty","title":"<code>Empty = adjective_condition(lambda v: len(v) == 0, 'empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must be empty (have no elements)</p>"},{"location":"api/annotations/#pane.annotations.NonEmpty","title":"<code>NonEmpty = adjective_condition(lambda v: len(v) != 0, 'non-empty')</code>  <code>module-attribute</code>","text":"<p><code>Condition</code> indicating value must not be empty</p>"},{"location":"api/annotations/#pane.annotations.ConvertAnnotation","title":"<code>ConvertAnnotation</code>","text":"<p>               Bases: <code>ABC</code>, <code>Hashable</code></p> <p>Abstract annotation supported by <code>pane</code>.</p> Source code in <code>pane/annotations.py</code> <pre><code>class ConvertAnnotation(abc.ABC, t.Hashable):\n    \"\"\"\n    Abstract annotation supported by `pane`.\n    \"\"\"\n    @abc.abstractmethod\n    def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n                   handlers: ConverterHandlers) -&gt; Converter[t.Any]:\n        ...\n</code></pre>"},{"location":"api/annotations/#pane.annotations.ConvertAnnotation._converter","title":"<code>_converter(inner_type, *, handlers)</code>  <code>abstractmethod</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>@abc.abstractmethod\ndef _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n               handlers: ConverterHandlers) -&gt; Converter[t.Any]:\n    ...\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Tagged","title":"<code>Tagged</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ConvertAnnotation</code></p> Source code in <code>pane/annotations.py</code> <pre><code>@dataclass(frozen=True)\nclass Tagged(ConvertAnnotation):\n    tag: str\n    \"\"\"Name of tag. This name will be searched in every Union member\"\"\"\n    external: t.Union[bool, t.Tuple[str, str]] = False\n    \"\"\"\n    Tagged unions can be stored three ways:\n     - Internally tagged (`external=False`, default). In this format, the tags are stored inside of each object: `{tag_name: tag_value, **obj}`\n     - Externally tagged (`external=True`). In this format, the tag is stored as a key outside the rest of the object: `{tag_value: obj}`\n     - Adjacently tagged (`external=(tag_key, value_key)`). In this format, the tag and value are stored under separate items: `{tag_key: tag_value, value_key: obj}`\n\n    This specification affects conversion into and out symmetrically.\n    \"\"\"\n\n    # for some reason this isn't auto-generated on python 3.9\n    def __hash__(self):\n        return hash((self.__class__.__name__, self.tag, self.external))\n\n    def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n                   handlers: ConverterHandlers) -&gt; Converter[t.Any]:\n\n        from .converters import TaggedUnionConverter\n        origin = t.get_origin(inner_type)\n        if origin is not t.Union:\n            raise TypeError(\"'Tagged' must surround a 'Union' type.\")\n        types = tuple(flatten_union_args(t.get_args(inner_type)))\n        return TaggedUnionConverter(types, tag=self.tag, external=self.external, handlers=handlers)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Tagged.tag","title":"<code>tag</code>  <code>instance-attribute</code>","text":"<p>Name of tag. This name will be searched in every Union member</p>"},{"location":"api/annotations/#pane.annotations.Tagged.external","title":"<code>external = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Tagged unions can be stored three ways <ul> <li>Internally tagged (<code>external=False</code>, default). In this format, the tags are stored inside of each object: <code>{tag_name: tag_value, **obj}</code></li> <li>Externally tagged (<code>external=True</code>). In this format, the tag is stored as a key outside the rest of the object: <code>{tag_value: obj}</code></li> <li>Adjacently tagged (<code>external=(tag_key, value_key)</code>). In this format, the tag and value are stored under separate items: <code>{tag_key: tag_value, value_key: obj}</code></li> </ul> <p>This specification affects conversion into and out symmetrically.</p>"},{"location":"api/annotations/#pane.annotations.Tagged._converter","title":"<code>_converter(inner_type, *, handlers)</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n               handlers: ConverterHandlers) -&gt; Converter[t.Any]:\n\n    from .converters import TaggedUnionConverter\n    origin = t.get_origin(inner_type)\n    if origin is not t.Union:\n        raise TypeError(\"'Tagged' must surround a 'Union' type.\")\n    types = tuple(flatten_union_args(t.get_args(inner_type)))\n    return TaggedUnionConverter(types, tag=self.tag, external=self.external, handlers=handlers)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition","title":"<code>Condition</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ConvertAnnotation</code></p> Source code in <code>pane/annotations.py</code> <pre><code>@dataclass(frozen=True)\nclass Condition(ConvertAnnotation):\n    f: t.Callable[[t.Any], bool]\n    \"\"\"\n    Condition/predicate function.\n\n    This is called with a parsed value, and should return `True` if it passes the condition.\n    \"\"\"\n    name: t.Optional[str] = None\n    \"\"\"Human-readable name of this condition\"\"\"\n    make_expected: t.Optional[t.Callable[[str, bool], str]] = None\n    \"\"\"\n    Given an inner `expected` string, and a boolean indicating plurality, this should return a\n    formatted `expected` string including the condition.\n\n    This is a low-level function that can be overrided for better error messages.\n    \"\"\"\n\n    # for some reason this isn't auto-generated on python 3.9\n    def __hash__(self):\n        return hash((\n            self.__class__.__name__, self.f, self.name,\n        ))\n\n    def __and__(self, other: Condition) -&gt; Condition:\n        return Condition.all(self, other)\n\n    def __or__(self, other: Condition) -&gt; Condition:\n        return Condition.any(self, other)\n\n    def __invert__(self) -&gt; Condition:\n        return Condition(\n            lambda val: not self.f(val),\n            f\"not {self.cond_name()}\"\n        )\n\n    @staticmethod\n    def all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n        \"\"\"\n        Create a condition by `and`ing together multiple conditions.\n\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\n        return Condition(\n            lambda val: all(cond.f(val) for cond in conditions),\n            list_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\n            make_expected\n        )\n\n    @staticmethod\n    def any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n        \"\"\"\n        Create a condition by `or`ing together multiple conditions.\n\n        Parameters:\n          conditions: Conditions to combine\n          make_expected: If specified, override `make_expected` on the result `Condition`.\n        \"\"\"\n        return Condition(\n            lambda val: any(cond.f(val) for cond in conditions),\n            list_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\n            make_expected\n        )\n\n    def cond_name(self) -&gt; str:\n        \"\"\"Get the name of this condition\"\"\"\n        return self.name or self.f.__name__\n\n    def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n                   handlers: ConverterHandlers) -&gt; ConditionalConverter[t.Any]:\n        from .converters import ConditionalConverter\n        return ConditionalConverter(\n            inner_type, self.f, self.cond_name(),\n            self.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n            handlers=handlers,\n        )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.f","title":"<code>f</code>  <code>instance-attribute</code>","text":"<p>Condition/predicate function.</p> <p>This is called with a parsed value, and should return <code>True</code> if it passes the condition.</p>"},{"location":"api/annotations/#pane.annotations.Condition.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human-readable name of this condition</p>"},{"location":"api/annotations/#pane.annotations.Condition.make_expected","title":"<code>make_expected = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Given an inner <code>expected</code> string, and a boolean indicating plurality, this should return a formatted <code>expected</code> string including the condition.</p> <p>This is a low-level function that can be overrided for better error messages.</p>"},{"location":"api/annotations/#pane.annotations.Condition.all","title":"<code>all(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>and</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef all(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n    \"\"\"\n    Create a condition by `and`ing together multiple conditions.\n\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\n    return Condition(\n        lambda val: all(cond.f(val) for cond in conditions),\n        list_phrase(tuple(cond.cond_name() for cond in conditions), 'and'),\n        make_expected\n    )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.any","title":"<code>any(*conditions, make_expected=None)</code>  <code>staticmethod</code>","text":"<p>Create a condition by <code>or</code>ing together multiple conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>Conditions to combine</p> <code>()</code> <code>make_expected</code> <code>Optional[Callable[[str, bool], str]]</code> <p>If specified, override <code>make_expected</code> on the result <code>Condition</code>.</p> <code>None</code> Source code in <code>pane/annotations.py</code> <pre><code>@staticmethod\ndef any(*conditions: Condition, make_expected: t.Optional[t.Callable[[str, bool], str]] = None) -&gt; Condition:\n    \"\"\"\n    Create a condition by `or`ing together multiple conditions.\n\n    Parameters:\n      conditions: Conditions to combine\n      make_expected: If specified, override `make_expected` on the result `Condition`.\n    \"\"\"\n    return Condition(\n        lambda val: any(cond.f(val) for cond in conditions),\n        list_phrase(tuple(cond.cond_name() for cond in conditions), 'or'),\n        make_expected\n    )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition.cond_name","title":"<code>cond_name()</code>","text":"<p>Get the name of this condition</p> Source code in <code>pane/annotations.py</code> <pre><code>def cond_name(self) -&gt; str:\n    \"\"\"Get the name of this condition\"\"\"\n    return self.name or self.f.__name__\n</code></pre>"},{"location":"api/annotations/#pane.annotations.Condition._converter","title":"<code>_converter(inner_type, *, handlers)</code>","text":"Source code in <code>pane/annotations.py</code> <pre><code>def _converter(self, inner_type: t.Union[Converter[t.Any], IntoConverter], *,\n               handlers: ConverterHandlers) -&gt; ConditionalConverter[t.Any]:\n    from .converters import ConditionalConverter\n    return ConditionalConverter(\n        inner_type, self.f, self.cond_name(),\n        self.make_expected or (lambda conv, plural: f\"{conv} satisfying {self.cond_name()}\"),\n        handlers=handlers,\n    )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.val_range","title":"<code>val_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must be between <code>min</code> and <code>max</code> (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def val_range(*, min: t.Union[int, float, None] = None, max: t.Union[int, float, None] = None) -&gt; Condition:\n    \"\"\"`Condition` indicating that a value must be between `min` and `max` (inclusive).\"\"\"\n    conds: t.List[Condition] = []\n    if min is not None:\n        conds.append(Condition(lambda v: v &gt;= min, f\"v &gt;= {min}\"))\n    if max is not None:\n        conds.append(Condition(lambda v: v &lt;= max, f\"v &lt;= {max}\"))\n    return Condition.all(*conds)\n</code></pre>"},{"location":"api/annotations/#pane.annotations.len_range","title":"<code>len_range(*, min=None, max=None)</code>","text":"<p><code>Condition</code> indicating that a value must have between <code>min</code> and <code>max</code> elements (inclusive).</p> Source code in <code>pane/annotations.py</code> <pre><code>def len_range(*, min: t.Optional[int] = None, max: t.Optional[int] = None) -&gt; Condition:\n    \"\"\"`Condition` indicating that a value must have between `min` and `max` elements (inclusive).\"\"\"\n    conds: t.List[Condition] = []\n    if min is not None:\n        conds.append(Condition(lambda v: len(v) &gt;= min, f\"at least {min} {pluralize('elem', min)}\"))\n    if max is not None:\n        conds.append(Condition(lambda v: len(v) &lt;= max, f\"at most {max} {pluralize('elem', max)}\"))\n    cond = Condition.all(*conds, make_expected=lambda exp, plural: f\"{exp} with {cond.cond_name()}\")\n    return cond\n</code></pre>"},{"location":"api/annotations/#pane.annotations.shape","title":"<code>shape(shape)</code>","text":"<p><code>Condition</code> indicating that a value must have a shape <code>shape</code>.</p> <p>Fails on objects that don't have a <code>shape</code> attribute.</p> Source code in <code>pane/annotations.py</code> <pre><code>def shape(shape: t.Sequence[int]) -&gt; Condition:\n    \"\"\"\n    `Condition` indicating that a value must have a shape `shape`.\n\n    Fails on objects that don't have a `shape` attribute.\n    \"\"\"\n    name = f\"shape {tuple(shape)}\"\n    return Condition(\n        lambda v: v.shape == shape, name,\n        lambda exp, plural: f\"{exp} with {name}\"\n    )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.broadcastable","title":"<code>broadcastable(shape)</code>","text":"<p><code>Condition</code> indicating that a value must be broadcastable to shape <code>shape</code>.</p> <p>Fails on objects that don't have a <code>shape</code> attribute.</p> Source code in <code>pane/annotations.py</code> <pre><code>def broadcastable(shape: t.Sequence[int]) -&gt; Condition:\n    \"\"\"\n    `Condition` indicating that a value must be broadcastable to shape `shape`.\n\n    Fails on objects that don't have a `shape` attribute.\n    \"\"\"\n    name = f\"broadcastable to {tuple(shape)}\"\n    return Condition(\n        lambda v: is_broadcastable(v.shape, shape), name,\n        lambda exp, plural: f\"{exp} {name}\"\n    )\n</code></pre>"},{"location":"api/annotations/#pane.annotations.adjective_condition","title":"<code>adjective_condition(f, adjective, article='a')</code>","text":"<p>Make a condition that can be expressed as a simple adjective (e.g. 'empty' or 'non-empty').</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[Any], bool]</code> <p>Condition/predicate function</p> required <code>adjective</code> <code>str</code> <p>Adjective corresponding to <code>f</code> (e.g. 'empty' or 'non-empty').</p> required <code>article</code> <code>str</code> <p>Article to put in front of <code>adjective</code> (only when not pluralized).</p> <code>'a'</code> Source code in <code>pane/annotations.py</code> <pre><code>def adjective_condition(f: t.Callable[[t.Any], bool], adjective: str, article: str = 'a') -&gt; Condition:\n    \"\"\"\n    Make a condition that can be expressed as a simple adjective (e.g. 'empty' or 'non-empty').\n\n    Parameters:\n      f: Condition/predicate function\n      adjective: Adjective corresponding to `f` (e.g. 'empty' or 'non-empty').\n      article: Article to put in front of `adjective` (only when not pluralized).\n    \"\"\"\n    return Condition(\n        f, adjective,\n        # e.g. 'positive ints' if plural else 'a positive int'\n        lambda exp, plural: f\"{adjective} {exp}\" if plural else f\"{article} {adjective} {remove_article(exp)}\"\n    )\n</code></pre>"},{"location":"api/classes/","title":"pane.classes","text":""},{"location":"api/classes/#pane.classes","title":"<code>pane.classes</code>","text":"<p>Pane dataclasses.</p>"},{"location":"api/classes/#pane.classes.PaneBaseT","title":"<code>PaneBaseT = t.TypeVar('PaneBaseT', bound='PaneBase')</code>  <code>module-attribute</code>","text":""},{"location":"api/classes/#pane.classes.ClassLayout","title":"<code>ClassLayout = t.Literal['tuple', 'struct']</code>  <code>module-attribute</code>","text":"<p>Set of known class layouts for 'in_formats' and 'out_format'.</p>"},{"location":"api/classes/#pane.classes.PANE_INFO","title":"<code>PANE_INFO = '__pane_info__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding <code>PaneInfo</code></p>"},{"location":"api/classes/#pane.classes.PANE_SET_FIELDS","title":"<code>PANE_SET_FIELDS = '__pane_set__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding a set of fields which have been set/modified</p>"},{"location":"api/classes/#pane.classes.PANE_BOUNDVARS","title":"<code>PANE_BOUNDVARS = '__pane_boundvars__'</code>  <code>module-attribute</code>","text":"<p>Name of dunder attribute holding a dictionary of bound type variables (for generic subclasses only).</p>"},{"location":"api/classes/#pane.classes.POST_INIT","title":"<code>POST_INIT = '__post_init__'</code>  <code>module-attribute</code>","text":"<p>Name of post-init method</p>"},{"location":"api/classes/#pane.classes.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Represents a materialized dataclass field.</p> <p>Typically instantiated from a <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass Field:\n    \"\"\"\n    Represents a materialized dataclass field.\n\n    Typically instantiated from a [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n\n    _: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\n    name: str\n    \"\"\"Name of field\"\"\"\n    type: t.Any\n    \"\"\"Type of field. Must be [`Convertible`][pane.convert.Convertible].\"\"\"\n    in_names: t.Sequence[str]\n    \"\"\"List of names which convert to this field.\"\"\"\n    out_name: str\n    \"\"\"Name this field converts into.\"\"\"\n    init: bool = True\n    \"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\n    default: t.Union[t.Any, _Missing] = _MISSING\n    \"\"\"Default value for field\"\"\"\n    default_factory: t.Optional[t.Callable[[], t.Any]] = None\n    \"\"\"Default value factory for field\"\"\"\n    kw_only: bool = False\n    \"\"\"Whether field is keyword only\"\"\"\n    converter: t.Optional[Converter[t.Any]] = None\n    \"\"\"Custom converter to use for this field.\"\"\"\n\n    @classmethod\n    def make(cls, name: str, ty: type,\n             in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n             out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n        in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n        out_name = rename_field(name, out_rename) if out_rename is not None else name\n        return cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n\n    def has_default(self) -&gt; bool:\n        \"\"\"Return whether this field has a default value\"\"\"\n        return self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/classes/#pane.classes.Field.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Name of field</p>"},{"location":"api/classes/#pane.classes.Field.type","title":"<code>type</code>  <code>instance-attribute</code>","text":"<p>Type of field. Must be <code>Convertible</code>.</p>"},{"location":"api/classes/#pane.classes.Field.in_names","title":"<code>in_names</code>  <code>instance-attribute</code>","text":"<p>List of names which convert to this field.</p>"},{"location":"api/classes/#pane.classes.Field.out_name","title":"<code>out_name</code>  <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/classes/#pane.classes.Field.init","title":"<code>init = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/classes/#pane.classes.Field.default","title":"<code>default = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/classes/#pane.classes.Field.default_factory","title":"<code>default_factory = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/classes/#pane.classes.Field.kw_only","title":"<code>kw_only = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/classes/#pane.classes.Field.converter","title":"<code>converter = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom converter to use for this field.</p>"},{"location":"api/classes/#pane.classes.Field.make","title":"<code>make(name, ty, in_rename=None, out_rename=None)</code>  <code>classmethod</code>","text":"Source code in <code>pane/field.py</code> <pre><code>@classmethod\ndef make(cls, name: str, ty: type,\n         in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n         out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n    in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n    out_name = rename_field(name, out_rename) if out_rename is not None else name\n    return cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n</code></pre>"},{"location":"api/classes/#pane.classes.Field.has_default","title":"<code>has_default()</code>","text":"<p>Return whether this field has a default value</p> Source code in <code>pane/field.py</code> <pre><code>def has_default(self) -&gt; bool:\n    \"\"\"Return whether this field has a default value\"\"\"\n    return self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase","title":"<code>PaneBase</code>","text":"<p>Base class for all <code>pane</code> dataclasses</p> Source code in <code>pane/classes.py</code> <pre><code>@dataclass_transform(\n    eq_default=True,\n    order_default=True,\n    frozen_default=True,\n    kw_only_default=False,\n    field_specifiers=(FieldSpec, field),\n)\nclass PaneBase:\n    \"\"\"\n    Base class for all `pane` dataclasses\n    \"\"\"\n    __slots__ = ('__pane_set__',)\n\n    __pane_info__: PaneInfo\n    \"\"\"Dunder attribute holding [`PaneInfo`][pane.classes.PaneInfo]\"\"\"\n    __pane_set__: t.Set[str]\n    \"\"\"Dunder attribute holding a set of fields which have been set/modified\"\"\"\n\n    def __init_subclass__(\n        cls,\n        *args: t.Any,\n        name: t.Optional[str] = None,\n        out_format: t.Optional[ClassLayout] = None,\n        in_format: t.Optional[t.Sequence[ClassLayout]] = None,\n        eq: t.Optional[bool] = None,\n        order: t.Optional[bool] = None,\n        frozen: t.Optional[bool] = None,\n        init: t.Optional[bool] = None,\n        kw_only: t.Optional[bool] = None,\n        rename: t.Optional[RenameStyle] = None,\n        in_rename: t.Optional[t.Union[RenameStyle, t.Sequence[RenameStyle]]] = None,\n        out_rename: t.Optional[RenameStyle] = None,\n        allow_extra: t.Optional[bool] = None,\n        custom: t.Optional[IntoConverterHandlers] = None,\n        **kwargs: t.Any,\n    ):\n        old_params = getattr(cls, '__parameters__', ())\n        super().__init_subclass__(*args, **kwargs)\n        setattr(cls, '__parameters__', old_params + getattr(cls, '__parameters__', ()))\n\n        if rename is not None:\n            if in_rename is not None or out_rename is not None:\n                raise ValueError(\"'rename' cannot be specified with 'in_rename' or 'out_rename'\")\n            in_rename = t.cast(t.Tuple[RenameStyle, ...], (rename,))\n            out_rename = rename\n        elif in_rename is not None and isinstance(in_rename, str):\n            in_rename = t.cast(t.Tuple[RenameStyle, ...], (in_rename,))\n\n        # handle option inheritance\n        opts: PaneOptions = getattr(cls, PANE_INFO).opts if hasattr(cls, PANE_INFO) else PaneOptions()\n        opts = opts.replace(\n            name=name, out_format=out_format, in_format=in_format,\n            eq=eq, order=order, frozen=frozen, init=init, allow_extra=allow_extra,\n            kw_only=kw_only, in_rename=in_rename, out_rename=out_rename,\n            class_handlers=ConverterHandlers._process(custom),\n        )\n\n        _process(cls, opts)\n\n    def __class_getitem__(cls, params: t.Union[type, t.Tuple[type, ...]]):\n        if not isinstance(params, tuple):\n            params = (params,)\n        return _make_subclass(cls, params)\n\n    def __repr__(self) -&gt; str:\n        inside = \", \".join(f\"{field.name}={getattr(self, field.name)!r}\" for field in self.__pane_info__.fields)\n        return f\"{self.__class__.__name__}({inside})\"\n\n    def __setattr__(self, name: str, value: t.Any) -&gt; None:\n        opts = self.__pane_info__.opts\n        if opts.frozen:\n            raise FrozenInstanceError(f\"cannot assign to field {name!r}\")\n        super().__setattr__(name, value)\n        set_fields: t.Set[str] = getattr(self, PANE_SET_FIELDS)\n        set_fields.add(name)\n\n    def __delattr__(self, name: str) -&gt; None:\n        raise AttributeError(f\"cannot delete field {name!r}\")\n\n    def __copy__(self):\n        return self.from_dict_unchecked(\n            {field.name: getattr(self, field.name) for field in self.__pane_info__.fields}\n        )\n\n    def __deepcopy__(self, memo: t.Any):\n        from copy import deepcopy\n        return self.from_dict_unchecked(\n            {field.name: deepcopy(getattr(self, field.name), memo) for field in self.__pane_info__.fields}\n        )\n\n    def __replace__(self, /, **changes: t.Any) -&gt; Self:\n        d = {field.name: getattr(self, field.name) for field in self.__pane_info__.fields}\n        d.update(**changes)\n        return self.__class__(**d)\n\n    @classmethod\n    def _converter(cls: t.Type[PaneBaseT], *args: t.Type[Convertible],\n                   handlers: ConverterHandlers) -&gt; Converter[PaneBaseT]:\n        if len(args) &gt; 0:\n            cls = t.cast(t.Type[PaneBaseT], cls[tuple(args)])  # type: ignore\n        return PaneConverter(cls, handlers=handlers)\n\n    @classmethod\n    def make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n        ...\n\n    @classmethod\n    def from_dict_unchecked(cls, d: t.Dict[str, t.Any]) -&gt; Self:\n        ...\n\n    @classmethod\n    def from_obj(cls, obj: Convertible, *,\n                 custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n\n        Parameters:\n          obj: Object to convert. Must be convertible.\n        \"\"\"\n        return convert(obj, cls, custom=custom)\n\n    @classmethod\n    def from_data(cls, data: DataType, *,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n\n        Parameters:\n          data: Data to convert. Must be a data interchange type.\n        \"\"\"\n        return from_data(data, cls, custom=custom)\n\n    def into_data(self, *, custom: t.Optional[IntoConverterHandlers] = None) -&gt; DataType:\n        \"\"\"Convert `self` into interchange data\"\"\"\n        return into_data(self, self.__class__, custom=custom)\n\n    def dict(self, *, set_only: bool = False, rename: t.Optional[RenameStyle] = None) -&gt; t.Dict[str, t.Any]:\n        \"\"\"\n        Return a dict of the fields in `self`\n\n        Parameters:\n          set_only: If `True`, return only the fields which have been set\n          rename: Rename fields to match the given style\n        \"\"\"\n        if set_only:\n            return {\n                rename_field(k, rename): getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n            }\n        return {\n            rename_field(field.name, rename): getattr(self, field.name) for field in self.__pane_info__.fields\n        }\n\n    @classmethod\n    def from_json(cls, f: io.FileOrPath, *,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Load `cls` from a JSON file `f`\n\n        Parameters:\n          f: File-like or path-like to load from\n          custom: Custom converters to use\n        \"\"\"\n        return io.from_json(f, cls, custom=custom)\n\n    @classmethod\n    def from_yaml(cls, f: io.FileOrPath, *,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Load `cls` from a YAML file `f`\n\n        Parameters:\n          f: File-like or path-like to load from\n          custom: Custom converters to use\n        \"\"\"\n        return io.from_yaml(f, cls, custom=custom)\n\n    @classmethod\n    def from_yaml_all(cls, f: io.FileOrPath, *,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; t.List[Self]:\n        \"\"\"\n        Load a list of `cls` from a YAML file `f`\n\n        Parameters:\n          f: File-like or path-like to load from\n          custom: Custom converters to use\n        \"\"\"\n        return io.from_yaml_all(f, cls, custom=custom)\n\n    @classmethod\n    def from_yamls(cls, s: str, *,\n                   custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Load `cls` from a YAML string `s`\n\n        Parameters:\n          s: YAML string to load from\n          custom: Custom converters to use\n        \"\"\"\n        from io import StringIO\n        return io.from_yaml(StringIO(s), cls, custom=custom)\n\n    @classmethod\n    def from_jsons(cls, s: str, *,\n                   custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n        \"\"\"\n        Load `cls` from a JSON string `s`\n\n        Parameters:\n          s: JSON string to load from\n          custom: Custom converters to use\n        \"\"\"\n        from io import StringIO\n        return io.from_json(StringIO(s), cls, custom=custom)\n\n    def write_json(self, f: io.FileOrPath, *,\n                   indent: t.Union[str, int, None] = None,\n                   sort_keys: bool = False,\n                   custom: t.Optional[IntoConverterHandlers] = None):\n        \"\"\"\n        Write data to a JSON file `f`\n\n        Parameters:\n          f: File-like or path-like to write to\n          indent: Indent to format JSON with. Defaults to None (no indentation)\n          sort_keys: Whether to sort keys prior to serialization.\n          custom: Custom converters to use\n        \"\"\"\n        io.write_json(\n            self, f, ty=self.__class__,\n            indent=indent, sort_keys=sort_keys, custom=custom\n        )\n\n    def write_yaml(self, f: io.FileOrPath, *,\n                   indent: t.Optional[int] = None, width: t.Optional[int] = None,\n                   allow_unicode: bool = True,\n                   explicit_start: bool = True, explicit_end: bool = False,\n                   default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n                   default_flow_style: t.Optional[bool] = None,\n                   sort_keys: bool = False,\n                   custom: t.Optional[IntoConverterHandlers] = None):\n        \"\"\"\n        Write data to a YAML file `f`\n\n        Parameters:\n          f: File-like or path-like to write to\n          indent: Number of spaces to indent blocks with\n          width: Maximum width of file created\n          allow_unicode: Whether to output unicode characters or escape them\n          explicit_start: Whether to include a YAML document start \"---\"\n          explicit_end: Whether to include a YAML document end \"...\"\n          default_style: Default style to use for scalar nodes.\n              See YAML documentation for more information.\n          default_flow_style: Whether to default to flow style or block style for collections.\n              See YAML documentation for more information.\n          sort_keys: Whether to sort keys prior to serialization.\n          custom: Custom converters to use\n        \"\"\"\n        io.write_yaml(\n            self, f, ty=self.__class__,\n            indent=indent, width=width,\n            allow_unicode=allow_unicode,\n            explicit_start=explicit_start, explicit_end=explicit_end,\n            default_style=default_style, default_flow_style=default_flow_style,\n            sort_keys=sort_keys, custom=custom\n        )\n\n    def into_json(self, *,\n                  indent: t.Union[str, int, None] = None,\n                  sort_keys: bool = False,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n        \"\"\"\n        Write data to a JSON string.\n\n        Parameters:\n          indent: Indent to format JSON with. Defaults to None (no indentation)\n          sort_keys: Whether to sort keys prior to serialization.\n          custom: Custom converters to use\n        \"\"\"\n        from io import StringIO\n\n        buf = StringIO()\n        io.write_json(\n            self, buf, ty=self.__class__,\n            indent=indent, sort_keys=sort_keys, custom=custom\n        )\n        return buf.getvalue()\n\n    def into_yaml(self, *,\n                  indent: t.Optional[int] = None, width: t.Optional[int] = None,\n                  allow_unicode: bool = True,\n                  explicit_start: bool = True, explicit_end: bool = False,\n                  default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n                  default_flow_style: t.Optional[bool] = None,\n                  sort_keys: bool = False,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n        \"\"\"\n        Write data to a YAML string.\n\n        Parameters:\n          indent: Number of spaces to indent blocks with\n          width: Maximum width of file created\n          allow_unicode: Whether to output unicode characters or escape them\n          explicit_start: Whether to include a YAML document start \"---\"\n          explicit_end: Whether to include a YAML document end \"...\"\n          default_style: Default style to use for scalar nodes.\n              See YAML documentation for more information.\n          default_flow_style: Whether to default to flow style or block style for collections.\n              See YAML documentation for more information.\n          sort_keys: Whether to sort keys prior to serialization.\n          custom: Custom converters to use\n        \"\"\"\n        from io import StringIO\n\n        buf = StringIO()\n        io.write_yaml(\n            self, buf, ty=self.__class__,\n            indent=indent, width=width, allow_unicode=allow_unicode,\n            explicit_start=explicit_start, explicit_end=explicit_end,\n            default_style=default_style, default_flow_style=default_flow_style,\n            sort_keys=sort_keys, custom=custom\n        )\n        return buf.getvalue()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase._converter","title":"<code>_converter(*args, handlers)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[PaneBaseT], *args: t.Type[Convertible],\n               handlers: ConverterHandlers) -&gt; Converter[PaneBaseT]:\n    if len(args) &gt; 0:\n        cls = t.cast(t.Type[PaneBaseT], cls[tuple(args)])  # type: ignore\n    return PaneConverter(cls, handlers=handlers)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.make_unchecked","title":"<code>make_unchecked(*args, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n    ...\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_dict_unchecked","title":"<code>from_dict_unchecked(d)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_dict_unchecked(cls, d: t.Dict[str, t.Any]) -&gt; Self:\n    ...\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_obj","title":"<code>from_obj(obj, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Convert <code>obj</code> into <code>cls</code>. Equivalent to <code>convert(obj, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to convert. Must be convertible.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_obj(cls, obj: Convertible, *,\n             custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n\n    Parameters:\n      obj: Object to convert. Must be convertible.\n    \"\"\"\n    return convert(obj, cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_data","title":"<code>from_data(data, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Convert <code>data</code> into <code>cls</code>. Equivalent to <code>from_data(data, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataType</code> <p>Data to convert. Must be a data interchange type.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_data(cls, data: DataType, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n\n    Parameters:\n      data: Data to convert. Must be a data interchange type.\n    \"\"\"\n    return from_data(data, cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.into_data","title":"<code>into_data(*, custom=None)</code>","text":"<p>Convert <code>self</code> into interchange data</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self, *, custom: t.Optional[IntoConverterHandlers] = None) -&gt; DataType:\n    \"\"\"Convert `self` into interchange data\"\"\"\n    return into_data(self, self.__class__, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.dict","title":"<code>dict(*, set_only=False, rename=None)</code>","text":"<p>Return a dict of the fields in <code>self</code></p> <p>Parameters:</p> Name Type Description Default <code>set_only</code> <code>bool</code> <p>If <code>True</code>, return only the fields which have been set</p> <code>False</code> <code>rename</code> <code>Optional[RenameStyle]</code> <p>Rename fields to match the given style</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def dict(self, *, set_only: bool = False, rename: t.Optional[RenameStyle] = None) -&gt; t.Dict[str, t.Any]:\n    \"\"\"\n    Return a dict of the fields in `self`\n\n    Parameters:\n      set_only: If `True`, return only the fields which have been set\n      rename: Rename fields to match the given style\n    \"\"\"\n    if set_only:\n        return {\n            rename_field(k, rename): getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n        }\n    return {\n        rename_field(field.name, rename): getattr(self, field.name) for field in self.__pane_info__.fields\n    }\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_json","title":"<code>from_json(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_json(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a JSON file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_json(f, cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_yaml","title":"<code>from_yaml(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_yaml(f, cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_yaml_all","title":"<code>from_yaml_all(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load a list of <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml_all(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; t.List[Self]:\n    \"\"\"\n    Load a list of `cls` from a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_yaml_all(f, cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_yamls","title":"<code>from_yamls(s, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>YAML string to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yamls(cls, s: str, *,\n               custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a YAML string `s`\n\n    Parameters:\n      s: YAML string to load from\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n    return io.from_yaml(StringIO(s), cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.from_jsons","title":"<code>from_jsons(s, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_jsons(cls, s: str, *,\n               custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a JSON string `s`\n\n    Parameters:\n      s: JSON string to load from\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n    return io.from_json(StringIO(s), cls, custom=custom)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.write_json","title":"<code>write_json(f, *, indent=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Union[str, int, None]</code> <p>Indent to format JSON with. Defaults to None (no indentation)</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def write_json(self, f: io.FileOrPath, *,\n               indent: t.Union[str, int, None] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a JSON file `f`\n\n    Parameters:\n      f: File-like or path-like to write to\n      indent: Indent to format JSON with. Defaults to None (no indentation)\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    io.write_json(\n        self, f, ty=self.__class__,\n        indent=indent, sort_keys=sort_keys, custom=custom\n    )\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.write_yaml","title":"<code>write_yaml(f, *, indent=None, width=None, allow_unicode=True, explicit_start=True, explicit_end=False, default_style=None, default_flow_style=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Optional[int]</code> <p>Number of spaces to indent blocks with</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>Maximum width of file created</p> <code>None</code> <code>allow_unicode</code> <code>bool</code> <p>Whether to output unicode characters or escape them</p> <code>True</code> <code>explicit_start</code> <code>bool</code> <p>Whether to include a YAML document start \"---\"</p> <code>True</code> <code>explicit_end</code> <code>bool</code> <p>Whether to include a YAML document end \"...\"</p> <code>False</code> <code>default_style</code> <code>Optional[Literal['\"', '|', '&gt;']]</code> <p>Default style to use for scalar nodes.   See YAML documentation for more information.</p> <code>None</code> <code>default_flow_style</code> <code>Optional[bool]</code> <p>Whether to default to flow style or block style for collections.   See YAML documentation for more information.</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def write_yaml(self, f: io.FileOrPath, *,\n               indent: t.Optional[int] = None, width: t.Optional[int] = None,\n               allow_unicode: bool = True,\n               explicit_start: bool = True, explicit_end: bool = False,\n               default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n               default_flow_style: t.Optional[bool] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to write to\n      indent: Number of spaces to indent blocks with\n      width: Maximum width of file created\n      allow_unicode: Whether to output unicode characters or escape them\n      explicit_start: Whether to include a YAML document start \"---\"\n      explicit_end: Whether to include a YAML document end \"...\"\n      default_style: Default style to use for scalar nodes.\n          See YAML documentation for more information.\n      default_flow_style: Whether to default to flow style or block style for collections.\n          See YAML documentation for more information.\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    io.write_yaml(\n        self, f, ty=self.__class__,\n        indent=indent, width=width,\n        allow_unicode=allow_unicode,\n        explicit_start=explicit_start, explicit_end=explicit_end,\n        default_style=default_style, default_flow_style=default_flow_style,\n        sort_keys=sort_keys, custom=custom\n    )\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.into_json","title":"<code>into_json(*, indent=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>Union[str, int, None]</code> <p>Indent to format JSON with. Defaults to None (no indentation)</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def into_json(self, *,\n              indent: t.Union[str, int, None] = None,\n              sort_keys: bool = False,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n    \"\"\"\n    Write data to a JSON string.\n\n    Parameters:\n      indent: Indent to format JSON with. Defaults to None (no indentation)\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n\n    buf = StringIO()\n    io.write_json(\n        self, buf, ty=self.__class__,\n        indent=indent, sort_keys=sort_keys, custom=custom\n    )\n    return buf.getvalue()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneBase.into_yaml","title":"<code>into_yaml(*, indent=None, width=None, allow_unicode=True, explicit_start=True, explicit_end=False, default_style=None, default_flow_style=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>Optional[int]</code> <p>Number of spaces to indent blocks with</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>Maximum width of file created</p> <code>None</code> <code>allow_unicode</code> <code>bool</code> <p>Whether to output unicode characters or escape them</p> <code>True</code> <code>explicit_start</code> <code>bool</code> <p>Whether to include a YAML document start \"---\"</p> <code>True</code> <code>explicit_end</code> <code>bool</code> <p>Whether to include a YAML document end \"...\"</p> <code>False</code> <code>default_style</code> <code>Optional[Literal['\"', '|', '&gt;']]</code> <p>Default style to use for scalar nodes.   See YAML documentation for more information.</p> <code>None</code> <code>default_flow_style</code> <code>Optional[bool]</code> <p>Whether to default to flow style or block style for collections.   See YAML documentation for more information.</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def into_yaml(self, *,\n              indent: t.Optional[int] = None, width: t.Optional[int] = None,\n              allow_unicode: bool = True,\n              explicit_start: bool = True, explicit_end: bool = False,\n              default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n              default_flow_style: t.Optional[bool] = None,\n              sort_keys: bool = False,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n    \"\"\"\n    Write data to a YAML string.\n\n    Parameters:\n      indent: Number of spaces to indent blocks with\n      width: Maximum width of file created\n      allow_unicode: Whether to output unicode characters or escape them\n      explicit_start: Whether to include a YAML document start \"---\"\n      explicit_end: Whether to include a YAML document end \"...\"\n      default_style: Default style to use for scalar nodes.\n          See YAML documentation for more information.\n      default_flow_style: Whether to default to flow style or block style for collections.\n          See YAML documentation for more information.\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n\n    buf = StringIO()\n    io.write_yaml(\n        self, buf, ty=self.__class__,\n        indent=indent, width=width, allow_unicode=allow_unicode,\n        explicit_start=explicit_start, explicit_end=explicit_end,\n        default_style=default_style, default_flow_style=default_flow_style,\n        sort_keys=sort_keys, custom=custom\n    )\n    return buf.getvalue()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneInfo","title":"<code>PaneInfo</code>  <code>dataclass</code>","text":"<p>Structure holding internal information about a <code>pane</code> dataclass</p> Source code in <code>pane/classes.py</code> <pre><code>@dataclasses.dataclass\nclass PaneInfo:\n    \"\"\"Structure holding internal information about a `pane` dataclass\"\"\"\n    opts: PaneOptions\n    \"\"\"Dataclass options\"\"\"\n    specs: t.Dict[str, FieldSpec]\n    \"\"\"\n    Dict of raw field specifications\n\n    This is used by subclasses to build [`Field`][pane.field.Field]s\n    \"\"\"\n    fields: t.Tuple[Field, ...]\n    \"\"\"\n    Tuple of processed [`Field`][pane.field.Field]s\n    \"\"\"\n    pos_args: t.Tuple[int, int]\n    \"\"\"\n    Range of allowed positional argument numbers, `[min, max]` inclusive\n    \"\"\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneInfo.opts","title":"<code>opts</code>  <code>instance-attribute</code>","text":"<p>Dataclass options</p>"},{"location":"api/classes/#pane.classes.PaneInfo.specs","title":"<code>specs</code>  <code>instance-attribute</code>","text":"<p>Dict of raw field specifications</p> <p>This is used by subclasses to build <code>Field</code>s</p>"},{"location":"api/classes/#pane.classes.PaneInfo.fields","title":"<code>fields</code>  <code>instance-attribute</code>","text":"<p>Tuple of processed <code>Field</code>s</p>"},{"location":"api/classes/#pane.classes.PaneInfo.pos_args","title":"<code>pos_args</code>  <code>instance-attribute</code>","text":"<p>Range of allowed positional argument numbers, <code>[min, max]</code> inclusive</p>"},{"location":"api/classes/#pane.classes.PaneOptions","title":"<code>PaneOptions</code>  <code>dataclass</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@dataclasses.dataclass(frozen=True)\nclass PaneOptions:\n    name: t.Optional[str] = None\n    \"\"\"Dataclass name\"\"\"\n    _: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\n    eq: bool = True\n    \"\"\"Whether to generate `__eq__`/`__ne__` methods\"\"\"\n    order: bool = True\n    \"\"\"Whether to generate `__gt__`/`__ge__`/`__lt__`/`__le__` methods\"\"\"\n    frozen: bool = True\n    \"\"\"Whether dataclass fields are frozen\"\"\"\n    init: bool = True\n    \"\"\"Whether to generate `__init__` method\"\"\"\n    kw_only: bool = False\n    \"\"\"Whether all fields should be keyword-only\"\"\"\n    out_format: ClassLayout = 'struct'\n    \"\"\"Data format to convert class into\"\"\"\n    in_format: t.Sequence[ClassLayout] = ('struct',)\n    \"\"\"Set of data formats class is convertible from\"\"\"\n    in_rename: t.Optional[t.Sequence[RenameStyle]] = None\n    \"\"\"Set of rename styles class is convertible from\"\"\"\n    out_rename: t.Optional[RenameStyle] = None\n    \"\"\"Rename style to convert class into\"\"\"\n    allow_extra: bool = False\n    \"\"\"Whether extra fields are allowed in conversion\"\"\"\n    class_handlers: t.Tuple[ConverterHandler, ...] = ()\n    \"\"\"Custom converters to use for field datatypes\"\"\"\n\n    def replace(self, **changes: t.Any):\n        \"\"\"Return `self` with the given changes applied\"\"\"\n        changes['name'] = changes.get('name', None)\n        return dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneOptions.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dataclass name</p>"},{"location":"api/classes/#pane.classes.PaneOptions.eq","title":"<code>eq = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__eq__</code>/<code>__ne__</code> methods</p>"},{"location":"api/classes/#pane.classes.PaneOptions.order","title":"<code>order = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__gt__</code>/<code>__ge__</code>/<code>__lt__</code>/<code>__le__</code> methods</p>"},{"location":"api/classes/#pane.classes.PaneOptions.frozen","title":"<code>frozen = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether dataclass fields are frozen</p>"},{"location":"api/classes/#pane.classes.PaneOptions.init","title":"<code>init = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to generate <code>__init__</code> method</p>"},{"location":"api/classes/#pane.classes.PaneOptions.kw_only","title":"<code>kw_only = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether all fields should be keyword-only</p>"},{"location":"api/classes/#pane.classes.PaneOptions.out_format","title":"<code>out_format = 'struct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data format to convert class into</p>"},{"location":"api/classes/#pane.classes.PaneOptions.in_format","title":"<code>in_format = ('struct',)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of data formats class is convertible from</p>"},{"location":"api/classes/#pane.classes.PaneOptions.in_rename","title":"<code>in_rename = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of rename styles class is convertible from</p>"},{"location":"api/classes/#pane.classes.PaneOptions.out_rename","title":"<code>out_rename = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rename style to convert class into</p>"},{"location":"api/classes/#pane.classes.PaneOptions.allow_extra","title":"<code>allow_extra = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether extra fields are allowed in conversion</p>"},{"location":"api/classes/#pane.classes.PaneOptions.class_handlers","title":"<code>class_handlers = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom converters to use for field datatypes</p>"},{"location":"api/classes/#pane.classes.PaneOptions.replace","title":"<code>replace(**changes)</code>","text":"<p>Return <code>self</code> with the given changes applied</p> Source code in <code>pane/classes.py</code> <pre><code>def replace(self, **changes: t.Any):\n    \"\"\"Return `self` with the given changes applied\"\"\"\n    changes['name'] = changes.get('name', None)\n    return dataclasses.replace(self, **{k: v for (k, v) in changes.items() if v is not None})\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter","title":"<code>PaneConverter</code>","text":"<p>               Bases: <code>Converter[PaneBaseT]</code></p> <p><code>Converter</code> for <code>pane</code> dataclasses</p> Source code in <code>pane/classes.py</code> <pre><code>class PaneConverter(Converter[PaneBaseT]):\n    \"\"\"\n    [`Converter`][pane.converters.Converter] for `pane` dataclasses\n    \"\"\"\n    def __init__(self, cls: t.Type[PaneBaseT], *,\n                 handlers: ConverterHandlers):\n        super().__init__()\n\n        self.cls = cls\n        self.name = self.cls.__name__\n        self.cls_info: PaneInfo = getattr(self.cls, PANE_INFO)\n        self.opts: PaneOptions = self.cls_info.opts\n        self.fields: t.Sequence[Field] = self.cls_info.fields\n\n        # prioritize:\n        # - field converter\n        # - custom passed to make_converter (handlers.globals)\n        # - custom passed to this class (which inherits from superclasses) (self.opts.class_handlers)\n        # - custom passed to parent (by composition) class (handlers.opts.class_handlers)\n        handlers = ConverterHandlers(handlers.globals, (*self.opts.class_handlers, *handlers.class_local))\n\n        self.field_converters: t.Sequence[Converter[t.Any]] = [\n            field.converter if field.converter is not None else make_converter(field.type, handlers)\n            for field in self.fields\n        ]\n        self.field_map: t.Dict[str, int] = {}\n\n        for (i, f) in enumerate(self.fields):\n            self.field_map[f.name] = i\n            for alias in f.in_names:\n                self.field_map[alias] = i\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"Convert dataclass `val` into data interchange, using the correct 'out_format'\"\"\"\n        assert isinstance(val, PaneBase)\n        if self.opts.out_format == 'tuple':\n            return tuple(\n                conv.into_data(getattr(val, field.name))\n                for (field, conv) in zip(self.fields, self.field_converters)\n            )\n        elif self.opts.out_format == 'struct':\n            return {\n                field.out_name: conv.into_data(getattr(val, field.name))\n                for (field, conv) in zip(self.fields, self.field_converters)\n            }\n        raise ValueError(f\"Unknown 'out_format' '{self.opts.out_format}'\")\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"Expected value for this converter\"\"\"\n        return f\"{list_phrase(self.opts.in_format)} {self.name}\"\n\n    def try_convert(self, val: t.Any) -&gt; PaneBaseT:\n        \"\"\"\n        See [`Converter.try_convert`][pane.converters.Converter.try_convert]\n\n        Dispatches to [`try_convert_tuple`][pane.classes.PaneConverter.try_convert_tuple]\n        and [`try_convert_struct`][pane.classes.PaneConverter.try_convert_struct]\n        \"\"\"\n        # based on type, try to delegate to try_convert_tuple or try_convert_struct\n        if isinstance(val, (list, tuple, t.Sequence)):\n            val = t.cast(t.Sequence[t.Any], val)\n            if 'tuple' not in self.opts.in_format:\n                raise ParseInterrupt()\n\n            return self.try_convert_tuple(t.cast(t.Sequence[t.Any], val))\n\n        elif isinstance(val, (dict, t.Mapping)):\n            if 'struct' not in self.opts.in_format:\n                raise ParseInterrupt()\n\n            return self.try_convert_struct(t.cast(t.Mapping[str, t.Any], val))\n\n        raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, WrongLenError, ProductErrorNode, None]:\n        \"\"\"\n        See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\n\n        Dispatches to [`collect_errors_tuple`][pane.classes.PaneConverter.collect_errors_tuple]\n        and [`collect_errors_struct`][pane.classes.PaneConverter.collect_errors_struct]\n        \"\"\"\n        # based on type, try to delegate to collect_errors_tuple or collect_errors_struct\n        if isinstance(val, (list, tuple, t.Sequence)):\n            if 'tuple' not in self.opts.in_format:\n                return WrongTypeError(self.expected_struct(), val)\n\n            return self.collect_errors_tuple(t.cast(t.Sequence[t.Any], val))\n\n        elif isinstance(val, (dict, t.Mapping)):\n            val = t.cast(t.Mapping[str, t.Any], val)\n            if 'struct' not in self.opts.in_format:\n                return WrongTypeError(f'tuple {self.name}', val)\n\n            return self.collect_errors_struct(t.cast(t.Mapping[str, t.Any], val))\n\n        return WrongTypeError(self.name, val)\n\n    def expected_struct(self, plural: bool = False) -&gt; str:\n        \"\"\"Expected value for the 'struct' data format\"\"\"\n        return f\"struct {self.name}\"\n\n    def try_convert_struct(self, val: t.Mapping[str, t.Any]) -&gt; PaneBaseT:\n        \"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'struct' data format\"\"\"\n        # loop through values, and handle accordingly\n        values: t.Dict[str, t.Any] = {}\n        for (k, v) in t.cast(t.Dict[str, t.Any], val).items():\n            if k not in self.field_map:\n                if not self.opts.allow_extra:\n                    raise ParseInterrupt()  # extra key\n                continue\n            field = self.fields[self.field_map[k]]\n            conv = self.field_converters[self.field_map[k]]\n\n            if field.name in values:\n                raise ParseInterrupt()  # multiple values for key\n            values[field.name] = conv.try_convert(v)\n\n        for field in filter(lambda field: field.name not in values, self.fields):\n            if field.default is not _MISSING:\n                values[field.name] = field.default\n            elif field.default_factory is not None:\n                values[field.name] = field.default_factory\n            else:\n                raise ParseInterrupt()  # missing field\n\n        try:\n            return self.cls.from_dict_unchecked(values)\n        except Exception:  # error in __post_init__\n            raise ParseInterrupt()\n\n    def collect_errors_struct(self, val: t.Mapping[str, t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n        \"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'struct' data format\"\"\"\n        values: t.Dict[str, t.Any] = {}  # converted field values. Required to check for __post_init__ errors\n        children: t.Dict[t.Union[str, int], ErrorNode] = {}  # errors in converting fields\n        extra: t.Set[str] = set()  # extra fields found\n        seen: t.Set[str] = set()   # fields seen already (used to find dupes)\n        for (k, v) in val.items():\n            if k not in self.field_map:\n                if not self.opts.allow_extra:\n                    extra.add(k)  # unknown key\n                continue\n\n            field = self.fields[self.field_map[k]]\n            conv = self.field_converters[self.field_map[k]]\n            if field.name in seen:\n                children[k] = DuplicateKeyError(k, field.in_names)\n                continue\n            seen.add(field.name)\n\n            # this is a little tricky. we need to call convert() rather\n            # than collect_errors to grab a successful value\n            try:\n                values[field.name] = conv.convert(v)\n            except ConvertError as e:\n                # then we can collect errors if that fails.\n                children[k] = e.tree\n\n        missing: t.Set[str] = set()\n        for field in self.fields:\n            if field.name not in seen and not field.has_default():\n                missing.add(field.name)\n\n        if len(missing) or len(children) or len(extra):\n            # return field errors\n            return ProductErrorNode(self.expected_struct(), children, val, missing, extra)\n        try:\n            self.cls.make_unchecked(**values)\n            return None\n        except Exception as e:  # error in __post_init__\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(f'struct {self.name}', val, tb)\n\n    def expected_tuple(self, plural: bool = False) -&gt; str:\n        \"\"\"Expected value for the 'tuple' data format\"\"\"\n        return f\"tuple {self.name}\"\n\n    def try_convert_tuple(self, val: t.Sequence[t.Any]) -&gt; PaneBaseT:\n        \"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'tuple' data format\"\"\"\n        (min_len, max_len) = self.cls_info.pos_args\n        if min_len &lt; len(val) &gt; max_len:\n            raise ParseInterrupt()\n\n        vals: t.List[t.Any] = []\n        for (conv, v) in zip(self.field_converters, val):\n            vals.append(conv.try_convert(v))\n\n        try:\n            return self.cls.make_unchecked(*vals)\n        except Exception:  # error in __post_init__\n            raise ParseInterrupt()\n\n    def collect_errors_tuple(self, val: t.Sequence[t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, WrongLenError, None]:\n        \"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'tuple' data format\"\"\"\n        (min_len, max_len) = self.cls_info.pos_args\n        if min_len &lt; len(val) &gt; max_len:\n            return WrongLenError(f'tuple {self.name}', (min_len, max_len), val, len(val))\n\n        vals: t.List[t.Any] = []\n        children: t.Dict[t.Union[str, int], ErrorNode] = {}\n        for (i, (conv, v)) in enumerate(zip(self.field_converters, val)):\n            # this is a little tricky. we need to call convert() rather\n            # than collect_errors to grab a successful value\n            try:\n                vals.append(conv.convert(v))\n            except ConvertError as e:\n                # then we can collect errors if that fails.\n                children[i] = e.tree\n\n        if len(children):\n            # return field errors\n            return ProductErrorNode(self.expected_tuple(), children, val)\n\n        try:\n            self.cls.make_unchecked(*vals)\n            return None\n        except Exception as e:  # error in __post_init__\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(f'tuple {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.cls","title":"<code>cls = cls</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.name","title":"<code>name = self.cls.__name__</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.cls_info","title":"<code>cls_info = getattr(self.cls, PANE_INFO)</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.opts","title":"<code>opts = self.cls_info.opts</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.fields","title":"<code>fields = self.cls_info.fields</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.field_converters","title":"<code>field_converters = [field.converter if field.converter is not None else make_converter(field.type, handlers) for field in self.fields]</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.field_map","title":"<code>field_map = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/classes/#pane.classes.PaneConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert dataclass <code>val</code> into data interchange, using the correct 'out_format'</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"Convert dataclass `val` into data interchange, using the correct 'out_format'\"\"\"\n    assert isinstance(val, PaneBase)\n    if self.opts.out_format == 'tuple':\n        return tuple(\n            conv.into_data(getattr(val, field.name))\n            for (field, conv) in zip(self.fields, self.field_converters)\n        )\n    elif self.opts.out_format == 'struct':\n        return {\n            field.out_name: conv.into_data(getattr(val, field.name))\n            for (field, conv) in zip(self.fields, self.field_converters)\n        }\n    raise ValueError(f\"Unknown 'out_format' '{self.opts.out_format}'\")\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>Expected value for this converter</p> Source code in <code>pane/classes.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"Expected value for this converter\"\"\"\n    return f\"{list_phrase(self.opts.in_format)} {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> <p>Dispatches to <code>try_convert_tuple</code> and <code>try_convert_struct</code></p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; PaneBaseT:\n    \"\"\"\n    See [`Converter.try_convert`][pane.converters.Converter.try_convert]\n\n    Dispatches to [`try_convert_tuple`][pane.classes.PaneConverter.try_convert_tuple]\n    and [`try_convert_struct`][pane.classes.PaneConverter.try_convert_struct]\n    \"\"\"\n    # based on type, try to delegate to try_convert_tuple or try_convert_struct\n    if isinstance(val, (list, tuple, t.Sequence)):\n        val = t.cast(t.Sequence[t.Any], val)\n        if 'tuple' not in self.opts.in_format:\n            raise ParseInterrupt()\n\n        return self.try_convert_tuple(t.cast(t.Sequence[t.Any], val))\n\n    elif isinstance(val, (dict, t.Mapping)):\n        if 'struct' not in self.opts.in_format:\n            raise ParseInterrupt()\n\n        return self.try_convert_struct(t.cast(t.Mapping[str, t.Any], val))\n\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> <p>Dispatches to <code>collect_errors_tuple</code> and <code>collect_errors_struct</code></p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, WrongLenError, ProductErrorNode, None]:\n    \"\"\"\n    See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\n\n    Dispatches to [`collect_errors_tuple`][pane.classes.PaneConverter.collect_errors_tuple]\n    and [`collect_errors_struct`][pane.classes.PaneConverter.collect_errors_struct]\n    \"\"\"\n    # based on type, try to delegate to collect_errors_tuple or collect_errors_struct\n    if isinstance(val, (list, tuple, t.Sequence)):\n        if 'tuple' not in self.opts.in_format:\n            return WrongTypeError(self.expected_struct(), val)\n\n        return self.collect_errors_tuple(t.cast(t.Sequence[t.Any], val))\n\n    elif isinstance(val, (dict, t.Mapping)):\n        val = t.cast(t.Mapping[str, t.Any], val)\n        if 'struct' not in self.opts.in_format:\n            return WrongTypeError(f'tuple {self.name}', val)\n\n        return self.collect_errors_struct(t.cast(t.Mapping[str, t.Any], val))\n\n    return WrongTypeError(self.name, val)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected_struct","title":"<code>expected_struct(plural=False)</code>","text":"<p>Expected value for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def expected_struct(self, plural: bool = False) -&gt; str:\n    \"\"\"Expected value for the 'struct' data format\"\"\"\n    return f\"struct {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert_struct","title":"<code>try_convert_struct(val)</code>","text":"<p><code>Converter.try_convert</code> for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert_struct(self, val: t.Mapping[str, t.Any]) -&gt; PaneBaseT:\n    \"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'struct' data format\"\"\"\n    # loop through values, and handle accordingly\n    values: t.Dict[str, t.Any] = {}\n    for (k, v) in t.cast(t.Dict[str, t.Any], val).items():\n        if k not in self.field_map:\n            if not self.opts.allow_extra:\n                raise ParseInterrupt()  # extra key\n            continue\n        field = self.fields[self.field_map[k]]\n        conv = self.field_converters[self.field_map[k]]\n\n        if field.name in values:\n            raise ParseInterrupt()  # multiple values for key\n        values[field.name] = conv.try_convert(v)\n\n    for field in filter(lambda field: field.name not in values, self.fields):\n        if field.default is not _MISSING:\n            values[field.name] = field.default\n        elif field.default_factory is not None:\n            values[field.name] = field.default_factory\n        else:\n            raise ParseInterrupt()  # missing field\n\n    try:\n        return self.cls.from_dict_unchecked(values)\n    except Exception:  # error in __post_init__\n        raise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors_struct","title":"<code>collect_errors_struct(val)</code>","text":"<p><code>Converter.collect_errors</code> for the 'struct' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors_struct(self, val: t.Mapping[str, t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n    \"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'struct' data format\"\"\"\n    values: t.Dict[str, t.Any] = {}  # converted field values. Required to check for __post_init__ errors\n    children: t.Dict[t.Union[str, int], ErrorNode] = {}  # errors in converting fields\n    extra: t.Set[str] = set()  # extra fields found\n    seen: t.Set[str] = set()   # fields seen already (used to find dupes)\n    for (k, v) in val.items():\n        if k not in self.field_map:\n            if not self.opts.allow_extra:\n                extra.add(k)  # unknown key\n            continue\n\n        field = self.fields[self.field_map[k]]\n        conv = self.field_converters[self.field_map[k]]\n        if field.name in seen:\n            children[k] = DuplicateKeyError(k, field.in_names)\n            continue\n        seen.add(field.name)\n\n        # this is a little tricky. we need to call convert() rather\n        # than collect_errors to grab a successful value\n        try:\n            values[field.name] = conv.convert(v)\n        except ConvertError as e:\n            # then we can collect errors if that fails.\n            children[k] = e.tree\n\n    missing: t.Set[str] = set()\n    for field in self.fields:\n        if field.name not in seen and not field.has_default():\n            missing.add(field.name)\n\n    if len(missing) or len(children) or len(extra):\n        # return field errors\n        return ProductErrorNode(self.expected_struct(), children, val, missing, extra)\n    try:\n        self.cls.make_unchecked(**values)\n        return None\n    except Exception as e:  # error in __post_init__\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(f'struct {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.expected_tuple","title":"<code>expected_tuple(plural=False)</code>","text":"<p>Expected value for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def expected_tuple(self, plural: bool = False) -&gt; str:\n    \"\"\"Expected value for the 'tuple' data format\"\"\"\n    return f\"tuple {self.name}\"\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.try_convert_tuple","title":"<code>try_convert_tuple(val)</code>","text":"<p><code>Converter.try_convert</code> for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def try_convert_tuple(self, val: t.Sequence[t.Any]) -&gt; PaneBaseT:\n    \"\"\"[`Converter.try_convert`][pane.converters.Converter.try_convert] for the 'tuple' data format\"\"\"\n    (min_len, max_len) = self.cls_info.pos_args\n    if min_len &lt; len(val) &gt; max_len:\n        raise ParseInterrupt()\n\n    vals: t.List[t.Any] = []\n    for (conv, v) in zip(self.field_converters, val):\n        vals.append(conv.try_convert(v))\n\n    try:\n        return self.cls.make_unchecked(*vals)\n    except Exception:  # error in __post_init__\n        raise ParseInterrupt()\n</code></pre>"},{"location":"api/classes/#pane.classes.PaneConverter.collect_errors_tuple","title":"<code>collect_errors_tuple(val)</code>","text":"<p><code>Converter.collect_errors</code> for the 'tuple' data format</p> Source code in <code>pane/classes.py</code> <pre><code>def collect_errors_tuple(self, val: t.Sequence[t.Any]) -&gt; t.Union[WrongTypeError, ProductErrorNode, WrongLenError, None]:\n    \"\"\"[`Converter.collect_errors`][pane.converters.Converter.collect_errors] for the 'tuple' data format\"\"\"\n    (min_len, max_len) = self.cls_info.pos_args\n    if min_len &lt; len(val) &gt; max_len:\n        return WrongLenError(f'tuple {self.name}', (min_len, max_len), val, len(val))\n\n    vals: t.List[t.Any] = []\n    children: t.Dict[t.Union[str, int], ErrorNode] = {}\n    for (i, (conv, v)) in enumerate(zip(self.field_converters, val)):\n        # this is a little tricky. we need to call convert() rather\n        # than collect_errors to grab a successful value\n        try:\n            vals.append(conv.convert(v))\n        except ConvertError as e:\n            # then we can collect errors if that fails.\n            children[i] = e.tree\n\n    if len(children):\n        # return field errors\n        return ProductErrorNode(self.expected_tuple(), children, val)\n\n    try:\n        self.cls.make_unchecked(*vals)\n        return None\n    except Exception as e:  # error in __post_init__\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(f'tuple {self.name}', val, tb)\n</code></pre>"},{"location":"api/classes/#pane.classes.field","title":"<code>field(*, rename=None, in_names=None, aliases=None, out_name=None, init=True, default=_MISSING, default_factory=None, kw_only=False, converter=None)</code>","text":"<pre><code>field(*, rename: t.Optional[str] = None, in_names: None = None, aliases: None = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: None = None, in_names: t.Sequence[str], aliases: None = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: None = None, in_names: None = None, aliases: t.Sequence[str], out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: t.Optional[str] = None, in_names: t.Optional[t.Sequence[str]] = None, aliases: t.Optional[t.Sequence[str]] = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre> <p>Annotate a dataclass field.</p> <p>Parameters:</p> Name Type Description Default <code>rename</code> <code>Optional[str]</code> <p>Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.</p> <code>None</code> <code>in_names</code> <code>Optional[Sequence[str]]</code> <p>List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike <code>aliases</code>).</p> <code>None</code> <code>aliases</code> <code>Optional[Sequence[str]]</code> <p>List of aliases (additional names) for this field. Includes the field name inside Python (unlike <code>in_names</code>).</p> <code>None</code> <code>out_name</code> <code>Optional[str]</code> <p>Name which this field should convert into.</p> <code>None</code> <code>init</code> <code>bool</code> <p>If <code>False</code>, this field won't be touched by <code>pane</code>, and it's up to the class to initialize it in <code>__post_init__</code>.</p> <code>True</code> <code>default</code> <code>Union[T, _Missing]</code> <p>Default value for field</p> <code>_MISSING</code> <code>default_factory</code> <code>Optional[Callable[[], T]]</code> <p>Default value factory for field</p> <code>None</code> <code>kw_only</code> <code>bool</code> <p>Whether the field is keyword-only.</p> <code>False</code> Source code in <code>pane/field.py</code> <pre><code>def field(*,\n    rename: t.Optional[str] = None,\n    in_names: t.Optional[t.Sequence[str]] = None,\n    aliases: t.Optional[t.Sequence[str]] = None,\n    out_name: t.Optional[str] = None,\n    init: bool = True,\n    default: t.Union[T, _Missing] = _MISSING,\n    default_factory: t.Optional[t.Callable[[], T]] = None,\n    kw_only: bool = False,\n    converter: t.Optional[Converter[T]] = None,\n) -&gt; t.Any:\n    \"\"\"\n    Annotate a dataclass field.\n\n    Parameters:\n      rename: Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.\n      in_names: List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike `aliases`).\n      aliases: List of aliases (additional names) for this field. Includes the field name inside Python (unlike `in_names`).\n      out_name: Name which this field should convert into.\n      init: If `False`, this field won't be touched by `pane`, and it's up to the class to initialize it in `__post_init__`.\n      default: Default value for field\n      default_factory: Default value factory for field\n      kw_only: Whether the field is keyword-only.\n    \"\"\"\n    return FieldSpec(\n        rename=rename, in_names=in_names, aliases=aliases, out_name=out_name,\n        init=init, default=default, default_factory=default_factory, kw_only=kw_only,\n        converter=converter\n    )\n</code></pre>"},{"location":"api/convert/","title":"pane.convert","text":""},{"location":"api/convert/#pane.convert","title":"<code>pane.convert</code>","text":"<p>High-level interface to <code>pane</code>.</p>"},{"location":"api/convert/#pane.convert.ScalarType","title":"<code>ScalarType = t.Union[str, bytes, int, bool, float, complex, None]</code>  <code>module-attribute</code>","text":""},{"location":"api/convert/#pane.convert.DataType","title":"<code>DataType = t.Union[str, bytes, int, bool, float, complex, None, t.Mapping['DataType', 'DataType'], t.Sequence['DataType'], numpy.NDArray[numpy.generic]]</code>  <code>module-attribute</code>","text":"<p>Common data interchange type. <code>into_data</code> converts to this.</p>"},{"location":"api/convert/#pane.convert.Convertible","title":"<code>Convertible = t.Union[DataType, HasConverter, t.Mapping['Convertible', 'Convertible'], t.Sequence['Convertible'], t.AbstractSet[DataType], Fraction, Decimal, datetime.datetime, datetime.date, datetime.time, os.PathLike[str], t.Pattern[str], t.Pattern[bytes], enum.Enum]</code>  <code>module-attribute</code>","text":"<p>Types supported by <code>from_data</code>.</p> <p>Consists of <code>DataType</code> + <code>HasConverter</code> + supported stdlib types.</p>"},{"location":"api/convert/#pane.convert.IntoConverter","title":"<code>IntoConverter = t.Union[t.Type[Convertible], t.Type[t.Any], t.Mapping[str, 'IntoConverter'], t.Sequence['IntoConverter']]</code>  <code>module-attribute</code>","text":"<p>Inputs supported by <code>make_converter</code>. Consists of <code>t.Type[Convertible]</code>, mappings (struct types), and sequences (tuple types).</p>"},{"location":"api/convert/#pane.convert.IntoConverterHandlers","title":"<code>IntoConverterHandlers = t.Union[ConverterHandler, t.Sequence[ConverterHandler], t.Dict[type, 'Converter[t.Any]']]</code>  <code>module-attribute</code>","text":""},{"location":"api/convert/#pane.convert.ConvertError","title":"<code>ConvertError</code>","text":"<p>               Bases: <code>Exception</code></p> <p><code>pane</code> conversion error.</p> <p><code>self.tree</code> contains a detailed error tree, and <code>str(self)</code> is a human-friendly representation of the same.</p> Source code in <code>pane/errors.py</code> <pre><code>class ConvertError(Exception):\n    \"\"\"\n    `pane` conversion error.\n\n    `self.tree` contains a detailed error tree, and `str(self)`\n    is a human-friendly representation of the same.\n    \"\"\"\n    def __init__(self, tree: ErrorNode):\n        self.tree: ErrorNode = tree\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.tree!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.tree)\n</code></pre>"},{"location":"api/convert/#pane.convert.ConvertError.tree","title":"<code>tree = tree</code>  <code>instance-attribute</code>","text":""},{"location":"api/convert/#pane.convert.Converter","title":"<code>Converter</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T_co]</code></p> <p>Base class for a converter to a given type <code>T_co</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>class Converter(abc.ABC, t.Generic[T_co]):\n    \"\"\"\n    Base class for a converter to a given type ``T_co``.\n    \"\"\"\n\n    def convert(self, val: t.Any) -&gt; T_co:\n        \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n        try:\n            return self.try_convert(val)\n        except ParseInterrupt:\n            pass\n        node = self.collect_errors(val)\n        if node is None:\n            raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                               \" This is a bug of the ``Converter`` implementation.\")\n        raise ConvertError(node)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"\n        Convert ``val`` into a data interchange format.\n\n        ``val`` *should* be of a type returned by this converter,\n        but don't count on it.\n        \"\"\"\n        return into_data(val, None)\n\n    into_data._original = True  # type: ignore\n\n    @abc.abstractmethod\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"\n        Return a descriptive string indicating the value(s) expected.\n\n        Parameters:\n          plural: Whether to pluralize the descriptive string\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def try_convert(self, val: t.Any) -&gt; T_co:\n        \"\"\"\n        Attempt to convert ``val`` to ``T``.\n        Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n        when a given parsing path reaches a dead end.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"\n        Return an error tree caused by converting ``val`` to ``T``.\n        ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"\n    Convert ``val`` into a data interchange format.\n\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\n    return into_data(val, None)\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.expected","title":"<code>expected(plural=False)</code>  <code>abstractmethod</code>","text":"<p>Return a descriptive string indicating the value(s) expected.</p> <p>Parameters:</p> Name Type Description Default <code>plural</code> <code>bool</code> <p>Whether to pluralize the descriptive string</p> <code>False</code> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n    \"\"\"\n    Return a descriptive string indicating the value(s) expected.\n\n    Parameters:\n      plural: Whether to pluralize the descriptive string\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.try_convert","title":"<code>try_convert(val)</code>  <code>abstractmethod</code>","text":"<p>Attempt to convert <code>val</code> to <code>T</code>. Should raise <code>ParseInterrupt</code> (and only <code>ParseInterrupt</code>) when a given parsing path reaches a dead end.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"\n    Attempt to convert ``val`` to ``T``.\n    Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n    when a given parsing path reaches a dead end.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/convert/#pane.convert.Converter.collect_errors","title":"<code>collect_errors(val)</code>  <code>abstractmethod</code>","text":"<p>Return an error tree caused by converting <code>val</code> to <code>T</code>. <code>collect_errors</code> should return <code>None</code> iff <code>convert</code> doesn't raise.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"\n    Return an error tree caused by converting ``val`` to ``T``.\n    ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/convert/#pane.convert.HasConverter","title":"<code>HasConverter</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol to add <code>convert</code> functionality into an arbitrary type from data.</p> Source code in <code>pane/convert.py</code> <pre><code>@t.runtime_checkable\nclass HasConverter(t.Protocol):\n    \"\"\"\n    Protocol to add [`convert`][pane.convert.convert] functionality into an arbitrary type from data.\n    \"\"\"\n\n    @classmethod\n    def _converter(cls: t.Type[T], *args: t.Type[Convertible],\n                   handlers: ConverterHandlers) -&gt; Converter[T]:\n        \"\"\"\n        Return a [`Converter`][pane.converters.Converter] capable of constructing `cls`.\n\n        Any given type arguments are passed as positional arguments.\n        This function should error when passed unknown type arguments.\n\n        `handlers` must be passed through to any sub-calls to `make_converter`.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/convert/#pane.convert.HasConverter._converter","title":"<code>_converter(*args, handlers)</code>  <code>classmethod</code>","text":"<p>Return a <code>Converter</code> capable of constructing <code>cls</code>.</p> <p>Any given type arguments are passed as positional arguments. This function should error when passed unknown type arguments.</p> <p><code>handlers</code> must be passed through to any sub-calls to <code>make_converter</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible],\n               handlers: ConverterHandlers) -&gt; Converter[T]:\n    \"\"\"\n    Return a [`Converter`][pane.converters.Converter] capable of constructing `cls`.\n\n    Any given type arguments are passed as positional arguments.\n    This function should error when passed unknown type arguments.\n\n    `handlers` must be passed through to any sub-calls to `make_converter`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/convert/#pane.convert.ConverterHandler","title":"<code>ConverterHandler</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function which may be called to create a converter. Receives two arguments, and one keyword argument <code>handlers</code>. The first argument is the base type, the second argument is a tuple of any type arguments, and the keyword argument <code>handlers</code> must be passed through to any nested calls to <code>make_converter</code>.</p> <p>May return <code>NotImplemented</code>, in which case handling will be passed to other handlers (including the default handlers).</p> Source code in <code>pane/convert.py</code> <pre><code>class ConverterHandler(t.Protocol):\n    \"\"\"\n    Function which may be called to create a converter.\n    Receives two arguments, and one keyword argument `handlers`.\n    The first argument is the base type, the second argument is a tuple of any type arguments,\n    and the keyword argument `handlers` must be passed through to any nested calls to `make_converter`.\n\n    May return `NotImplemented`, in which case handling will be passed to other handlers\n    (including the default handlers).\n    \"\"\"\n\n    def __call__(self, ty: type, args: t.Tuple[t.Any, ...], /, *,\n                 handlers: ConverterHandlers) -&gt; 'Converter[t.Any]':\n        ...\n</code></pre>"},{"location":"api/convert/#pane.convert.ConverterHandlers","title":"<code>ConverterHandlers</code>  <code>dataclass</code>","text":"Source code in <code>pane/convert.py</code> <pre><code>@dataclass(frozen=True)\nclass ConverterHandlers:\n    globals: t.Tuple[ConverterHandler, ...] = ()\n    \"\"\"Converters passed globally to convert, into_data, or from_data.\"\"\"\n    class_local: t.Tuple[ConverterHandler, ...] = ()\n    \"\"\"Converters local to a given class. These will be overriden by inner classes.\"\"\"\n\n    @classmethod\n    def make(cls, handlers: t.Optional[IntoConverterHandlers]) -&gt; Self:\n        return cls(globals=cls._process(handlers))\n\n    @staticmethod\n    def _process(handlers: t.Optional[IntoConverterHandlers]) -&gt; t.Tuple[ConverterHandler, ...]:\n        if handlers is None:\n            return ()\n\n        if isinstance(handlers, dict):\n            conv_map = handlers\n\n            def inner(ty: type, args: t.Tuple[t.Any, ...] = (), *, handlers: ConverterHandlers):\n                if ty in conv_map and len(args) == 0:\n                    return conv_map[ty]\n                return NotImplemented\n\n            return (inner,)\n\n        return tuple(handlers) if isinstance(handlers, t.Sequence) else (handlers,)\n\n    def __iter__(self) -&gt; t.Iterator[ConverterHandler]:\n        return itertools.chain(self.globals, self.class_local)\n</code></pre>"},{"location":"api/convert/#pane.convert.ConverterHandlers.globals","title":"<code>globals = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Converters passed globally to convert, into_data, or from_data.</p>"},{"location":"api/convert/#pane.convert.ConverterHandlers.class_local","title":"<code>class_local = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Converters local to a given class. These will be overriden by inner classes.</p>"},{"location":"api/convert/#pane.convert.ConverterHandlers.make","title":"<code>make(handlers)</code>  <code>classmethod</code>","text":"Source code in <code>pane/convert.py</code> <pre><code>@classmethod\ndef make(cls, handlers: t.Optional[IntoConverterHandlers]) -&gt; Self:\n    return cls(globals=cls._process(handlers))\n</code></pre>"},{"location":"api/convert/#pane.convert._make_converter_key_f","title":"<code>_make_converter_key_f(ty, handlers=ConverterHandlers())</code>","text":"Source code in <code>pane/convert.py</code> <pre><code>def _make_converter_key_f(ty: IntoConverter, handlers: ConverterHandlers = ConverterHandlers()) -&gt; t.Any:\n    return (id(ty), handlers)\n</code></pre>"},{"location":"api/convert/#pane.convert.make_converter","title":"<code>make_converter(ty, handlers=ConverterHandlers())</code>","text":"<pre><code>make_converter(ty: t.Type[T], handlers: ConverterHandlers = ...) -&gt; Converter[T]\n</code></pre><pre><code>make_converter(ty: IntoConverter, handlers: ConverterHandlers = ...) -&gt; Converter[t.Any]\n</code></pre> <p>Make a <code>Converter</code> for <code>ty</code>.</p> <p>Supports types, mappings of types, and sequences of types.</p> Source code in <code>pane/convert.py</code> <pre><code>@key_cache(_make_converter_key_f)\ndef make_converter(ty: IntoConverter, handlers: ConverterHandlers = ConverterHandlers()) -&gt; Converter[t.Any]:\n    \"\"\"\n    Make a [`Converter`][pane.convert.Converter] for `ty`.\n\n    Supports types, mappings of types, and sequences of types.\n    \"\"\"\n\n    from .converters import AnyConverter, StructConverter, SequenceConverter, UnionConverter\n    from .converters import LiteralConverter, DictConverter, TupleConverter, ScalarConverter\n    from .converters import EnumConverter, DelegateConverter, _BASIC_CONVERTERS, _BASIC_WITH_ARGS\n\n    if ty is t.Any or ty is type(t.Any):\n        return AnyConverter()\n    if isinstance(ty, t.TypeVar):\n        var_ty: IntoConverter\n\n        if ty.__bound__ is not None:  # type: ignore\n            # bound typevar\n            var_ty = ty.__bound__\n        elif len(ty.__constraints__) == 1:\n            # typevar with constraints\n            var_ty = ty.__constraints__\n        elif len(ty.__constraints__) &gt; 1:\n            # typevar with multiple constraints\n            var_ty = t.Union[ty.__constraints__]  # type: ignore\n        else:\n            # unbound typevar\n            var_ty = t.Any  # type: ignore\n\n        warnings.warn(f\"Unbound TypeVar '{ty}'. Will be interpreted as '{var_ty}'.\")\n        return make_converter(var_ty, handlers)\n    if isinstance(ty, (dict, t.Mapping)):\n        return StructConverter(type(ty), ty, handlers=handlers)  # type: ignore\n    if isinstance(ty, (tuple, t.Tuple)):\n        return TupleConverter(type(ty), ty, handlers=handlers)\n    if isinstance(ty, t.ForwardRef) or isinstance(ty, str):\n        raise TypeError(f\"Unresolved forward reference '{ty}'\")\n\n    base = t.get_origin(ty) or ty\n    args = t.get_args(ty)\n\n    # special types\n\n    # handle annotations\n    if base is t.Annotated:\n        return _annotated_converter(args[0], args[1:], handlers=handlers)\n\n    # union converter\n    if base is t.Union:\n        return UnionConverter(args, handlers=handlers)\n    # literal converter\n    if base is t.Literal:\n        return LiteralConverter(args)\n\n    if not isinstance(base, type):\n        raise TypeError(f\"Unsupported special type '{base}'\")\n\n    # passed converter handler\n    for handler in handlers:\n        try:\n            result = handler(base, args, handlers=ConverterHandlers())\n            if result is not NotImplemented:\n                return result\n        except NotImplementedError:\n            pass\n\n    # custom converter\n    if issubclass(base, HasConverter):\n        return base._converter(*args, handlers=handlers)\n\n    # simple/scalar converters\n    if base in _BASIC_CONVERTERS:\n        return _BASIC_CONVERTERS[base]\n\n    if base in _BASIC_WITH_ARGS:\n        return _BASIC_WITH_ARGS[base](*args)\n\n    # add-on handlers\n    for handler in _GLOBAL_HANDLERS:\n        try:\n            result = handler(t.cast(type, base), args, handlers=handlers)\n            if result is not NotImplemented:\n                return result\n        except NotImplementedError:\n            pass\n\n    if issubclass(base, enum.Enum):\n        return EnumConverter(base, handlers=handlers)\n\n    # pathlike converter\n    if issubclass(base, os.PathLike):\n        new_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\n        if inspect.isabstract(new_base):\n            raise TypeError(f\"No converter for abstract type '{ty}'\")\n        return ScalarConverter(new_base, (str, os.PathLike), 'a path', 'paths', str)  # type: ignore\n\n    # tuple converter\n    if issubclass(base, (tuple, t.Tuple)):\n        # treat tuple[int, ...] and tuple[()] correctly\n        if len(args) &gt; 0 and args[-1] != Ellipsis \\\n              or args == () and hasattr(ty, '__args__'):\n            if args == ((),):  # tuple[()] on python &lt;3.11\n                args = ()\n            return TupleConverter(base, args, handlers=handlers)  # type: ignore\n        # fall through to sequence converter\n\n    # homogenous sequence converter\n    # concrete t.Set/t.List/etc are already converted to set/list/etc by t.get_origin\n    if issubclass(base, (collections.abc.Sequence, collections.abc.Set)):\n        # map abstract to concrete types\n        new_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\n        if inspect.isabstract(new_base):\n            raise TypeError(f\"No converter for abstract type '{ty}'\")\n        return SequenceConverter(\n            new_base,\n            args[0] if len(args) &gt; 0 else t.Any,  # type: ignore\n            handlers=handlers\n        )  # type: ignore\n\n    # homogenous mapping converter\n    # this also handles dict subclasses like Counter &amp; OrderedDict\n    if issubclass(base, (dict, t.Mapping)):\n        # map abstract to concrete types\n        new_base = _ABSTRACT_MAPPING.get(base, base)  # type: ignore\n        if inspect.isabstract(new_base):\n            raise TypeError(f\"No converter for abstract type '{ty}'\")\n        if issubclass(new_base, collections.Counter):\n            # counter takes one type argument, handle it specially\n            return DictConverter(\n                new_base, # type: ignore\n                args[0] if len(args) &gt; 0 else t.Any,  # type: ignore\n                int, handlers=handlers\n            )\n\n        # defaultdict needs a special constructor\n        constructor: t.Optional[t.Callable[[t.Mapping[t.Any, t.Any]], collections.defaultdict[t.Any, t.Any]]]\n        constructor = (lambda d: collections.defaultdict(None, d)) if issubclass(new_base, collections.defaultdict) else None\n        return DictConverter(\n            new_base,  # type: ignore\n            args[0] if len(args) &gt; 0 else t.Any,\n            args[1] if len(args) &gt; 1 else t.Any,\n            constructor, handlers=handlers\n        )\n\n    # after we've handled common cases, look for subclasses of basic types\n    for conv_ty in _BASIC_CONVERTERS.keys():\n        if issubclass(base, conv_ty):\n            return DelegateConverter(conv_ty, base, handlers=handlers)  # type: ignore\n\n    raise TypeError(f\"No converter for type '{ty}'\")\n</code></pre>"},{"location":"api/convert/#pane.convert.register_converter_handler","title":"<code>register_converter_handler(handler)</code>","text":"<p>Register a handler for make_converter.</p> <p>This allows extending <code>pane</code> to handle third-party types, not defined by your code or by <code>pane</code>. Use sparingly, as this will add runtime to <code>make_converter</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>def register_converter_handler(handler: ConverterHandler) -&gt; None:\n    \"\"\"\n    Register a handler for make_converter.\n\n    This allows extending `pane` to handle third-party types, not\n    defined by your code or by `pane`. Use sparingly, as this will\n    add runtime to [`make_converter`][pane.convert.make_converter].\n    \"\"\"\n    _GLOBAL_HANDLERS.append(handler)\n</code></pre>"},{"location":"api/convert/#pane.convert._annotated_converter","title":"<code>_annotated_converter(ty, args, *, handlers)</code>","text":"<p>Make an annotated converter.</p> <p>Wraps <code>ty</code> in <code>args</code> from left to right. However, <code>Condition</code> annotations are handled separately (bundled together).</p> Source code in <code>pane/convert.py</code> <pre><code>def _annotated_converter(ty: IntoConverter, args: t.Sequence[t.Any], *,\n                         handlers: ConverterHandlers) -&gt; Converter[t.Any]:\n    \"\"\"\n    Make an annotated converter.\n\n    Wraps `ty` in `args` from left to right. However, [`Condition`][pane.annotations.Condition] annotations\n    are handled separately (bundled together).\n    \"\"\"\n    from .converters import Converter\n    from .annotations import Condition, ConvertAnnotation\n\n    conv: t.Union[IntoConverter, Converter[t.Any]] = ty\n\n    conditions: t.List[Condition] = []  # buffer of conditions to combine\n    for arg in args:\n        if isinstance(arg, Condition):\n            conditions.append(arg)\n            continue\n\n        if not isinstance(arg, ConvertAnnotation):\n            raise UnsupportedAnnotation(arg)\n\n        # dump list of conditions\n        if len(conditions):\n            if len(conditions) &gt; 1:\n                conv = Condition.all(*conditions)._converter(conv, handlers=handlers)\n            else:\n                conv = conditions[0]._converter(conv, handlers=handlers)\n\n        conv = arg._converter(conv, handlers=handlers)\n\n    # dump list of conditions\n    if len(conditions):\n        if len(conditions) &gt; 1:\n            conv = Condition.all(*conditions)._converter(conv, handlers=handlers)\n        else:\n            conv = conditions[0]._converter(conv, handlers=handlers)\n\n    return conv if isinstance(conv, Converter) else make_converter(conv, handlers=handlers)\n</code></pre>"},{"location":"api/convert/#pane.convert.into_data","title":"<code>into_data(val, ty=None, *, custom=None)</code>","text":"<p>Convert <code>val</code> of type <code>ty</code> into a data interchange format.</p> Source code in <code>pane/convert.py</code> <pre><code>def into_data(val: Convertible, ty: t.Optional[IntoConverter] = None, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; DataType:\n    \"\"\"\n    Convert `val` of type `ty` into a data interchange format.\n    \"\"\"\n    if ty is None:\n        if isinstance(val, _ScalarType) and custom is None:\n            # we can bypass the converter for scalar types\n            return val\n        ty = type(val)\n\n    try:\n        conv = make_converter(ty, ConverterHandlers.make(custom))\n        assert not hasattr(conv.into_data, '_original')  # hack to not use the default into_data implementation here\n    except (TypeError, AssertionError):\n        raise TypeError(f\"Can't convert type '{type(val)}' into data.\") from None\n\n    return conv.into_data(val)\n</code></pre>"},{"location":"api/convert/#pane.convert.from_data","title":"<code>from_data(val, ty, *, custom=None)</code>","text":"<p>Convert <code>val</code> from a data interchange format into type <code>ty</code>.</p> Source code in <code>pane/convert.py</code> <pre><code>def from_data(val: DataType, ty: t.Type[T], *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; T:\n    \"\"\"\n    Convert `val` from a data interchange format into type `ty`.\n    \"\"\"\n\n    if not isinstance(val, _DataType):\n        raise TypeError(f\"Type {type(val)} is not a valid data interchange type.\")\n\n    converter = make_converter(ty, ConverterHandlers.make(custom))\n    return converter.convert(val)\n</code></pre>"},{"location":"api/convert/#pane.convert.convert","title":"<code>convert(val, ty, *, custom=None)</code>","text":"<p>Convert <code>val</code> into type <code>ty</code>, passing through a data interchange format.</p> Source code in <code>pane/convert.py</code> <pre><code>def convert(val: Convertible, ty: t.Type[T], *,\n            custom: t.Optional[IntoConverterHandlers] = None) -&gt; T:\n    \"\"\"\n    Convert `val` into type `ty`, passing through a data interchange format.\n    \"\"\"\n    data = into_data(val, custom=custom)\n    return from_data(data, ty, custom=custom)\n</code></pre>"},{"location":"api/converters/","title":"pane.converters","text":""},{"location":"api/converters/#pane.converters","title":"<code>pane.converters</code>","text":"<p>Converter types, which do the hard work of recursive validation.</p>"},{"location":"api/converters/#pane.converters.NestedSequence","title":"<code>NestedSequence = t.Union[T, t.Sequence['NestedSequence[T]']]</code>  <code>module-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeT","title":"<code>DatetimeT = t.TypeVar('DatetimeT', bound=t.Union[datetime.datetime, datetime.date, datetime.time])</code>  <code>module-attribute</code>","text":""},{"location":"api/converters/#pane.converters.Converter","title":"<code>Converter</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T_co]</code></p> <p>Base class for a converter to a given type <code>T_co</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>class Converter(abc.ABC, t.Generic[T_co]):\n    \"\"\"\n    Base class for a converter to a given type ``T_co``.\n    \"\"\"\n\n    def convert(self, val: t.Any) -&gt; T_co:\n        \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n        try:\n            return self.try_convert(val)\n        except ParseInterrupt:\n            pass\n        node = self.collect_errors(val)\n        if node is None:\n            raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                               \" This is a bug of the ``Converter`` implementation.\")\n        raise ConvertError(node)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"\n        Convert ``val`` into a data interchange format.\n\n        ``val`` *should* be of a type returned by this converter,\n        but don't count on it.\n        \"\"\"\n        return into_data(val, None)\n\n    into_data._original = True  # type: ignore\n\n    @abc.abstractmethod\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"\n        Return a descriptive string indicating the value(s) expected.\n\n        Parameters:\n          plural: Whether to pluralize the descriptive string\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def try_convert(self, val: t.Any) -&gt; T_co:\n        \"\"\"\n        Attempt to convert ``val`` to ``T``.\n        Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n        when a given parsing path reaches a dead end.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"\n        Return an error tree caused by converting ``val`` to ``T``.\n        ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"\n    Convert ``val`` into a data interchange format.\n\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\n    return into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.expected","title":"<code>expected(plural=False)</code>  <code>abstractmethod</code>","text":"<p>Return a descriptive string indicating the value(s) expected.</p> <p>Parameters:</p> Name Type Description Default <code>plural</code> <code>bool</code> <p>Whether to pluralize the descriptive string</p> <code>False</code> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef expected(self, plural: bool = False) -&gt; str:\n    \"\"\"\n    Return a descriptive string indicating the value(s) expected.\n\n    Parameters:\n      plural: Whether to pluralize the descriptive string\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.try_convert","title":"<code>try_convert(val)</code>  <code>abstractmethod</code>","text":"<p>Attempt to convert <code>val</code> to <code>T</code>. Should raise <code>ParseInterrupt</code> (and only <code>ParseInterrupt</code>) when a given parsing path reaches a dead end.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef try_convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"\n    Attempt to convert ``val`` to ``T``.\n    Should raise ``ParseInterrupt`` (and only ``ParseInterrupt``)\n    when a given parsing path reaches a dead end.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/converters/#pane.converters.Converter.collect_errors","title":"<code>collect_errors(val)</code>  <code>abstractmethod</code>","text":"<p>Return an error tree caused by converting <code>val</code> to <code>T</code>. <code>collect_errors</code> should return <code>None</code> iff <code>convert</code> doesn't raise.</p> Source code in <code>pane/converters.py</code> <pre><code>@abc.abstractmethod\ndef collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"\n    Return an error tree caused by converting ``val`` to ``T``.\n    ``collect_errors`` should return ``None`` iff ``convert`` doesn't raise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter","title":"<code>AnyConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[Any]</code></p> <p>Converter for <code>t.Any</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass AnyConverter(Converter[t.Any]):\n    \"\"\"Converter for ``t.Any``.\"\"\"\n    def try_convert(self, val: t.Any) -&gt; t.Any:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        return val\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return pluralize(\"any value\", plural)\n\n    def collect_errors(self, val: t.Any) -&gt; None:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        return None\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"\n    Convert ``val`` into a data interchange format.\n\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\n    return into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    return val\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return pluralize(\"any value\", plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.AnyConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; None:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    return None\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter","title":"<code>ScalarConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[T]</code></p> <p>Converter for a simple scalar type, constructible from a list of allowed types.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass ScalarConverter(Converter[T]):\n    \"\"\"\n    Converter for a simple scalar type,\n    constructible from a list of allowed types.\n    \"\"\"\n\n    # TODO this needs to handle into_data better\n    ty: t.Type[T]\n    \"\"\"Type to convert into.\"\"\"\n    allowed: t.Union[type, t.Tuple[type, ...]]\n    \"\"\"Type or list of allowed types.\"\"\"\n    expect: t.Optional[str] = None\n    \"\"\"Singular form of expected value.\"\"\"\n    expect_plural: t.Optional[str] = None\n    \"\"\"Plural form of expected value.\"\"\"\n    _into_data_f: t.Callable[[T], DataType] = lambda v: v  # type: ignore\n\n    def __post_init__(self):\n        self.expect = self.expect or self.ty.__name__\n        self.expect_plural = self.expect_plural or self.expect\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        return self._into_data_f(val)\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return t.cast(str, self.expect_plural if plural else self.expect)\n\n    def try_convert(self, val: t.Any) -&gt; T:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if isinstance(val, self.allowed):\n            try:\n                return self.ty(val)  # type: ignore\n            except Exception:\n                raise ParseInterrupt()\n        raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if isinstance(val, self.allowed):\n            try:\n                self.ty(val)  # type: ignore\n                return None\n            except Exception as e:\n                tb = e.__traceback__.tb_next  # type: ignore\n                tb = traceback.TracebackException(type(e), e, tb)\n                return WrongTypeError(self.expected(), val, tb)\n        return WrongTypeError(f'{self.expected()}', val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.ty","title":"<code>ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.allowed","title":"<code>allowed</code>  <code>instance-attribute</code>","text":"<p>Type or list of allowed types.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.expect","title":"<code>expect = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Singular form of expected value.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.expect_plural","title":"<code>expect_plural = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plural form of expected value.</p>"},{"location":"api/converters/#pane.converters.ScalarConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    return self._into_data_f(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return t.cast(str, self.expect_plural if plural else self.expect)\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if isinstance(val, self.allowed):\n        try:\n            return self.ty(val)  # type: ignore\n        except Exception:\n            raise ParseInterrupt()\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.ScalarConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if isinstance(val, self.allowed):\n        try:\n            self.ty(val)  # type: ignore\n            return None\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n    return WrongTypeError(f'{self.expected()}', val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter","title":"<code>NoneConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[None]</code></p> <p>Converter which accepts only <code>None</code>.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass NoneConverter(Converter[None]):\n    \"\"\"\n    Converter which accepts only ``None``.\n    \"\"\"\n\n    def try_convert(self, val: t.Any) -&gt; None:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if val is None:\n            return val\n        raise ParseInterrupt()\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return pluralize(\"null value\", plural)\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if val is None:\n            return None\n        return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"\n    Convert ``val`` into a data interchange format.\n\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\n    return into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; None:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if val is None:\n        return val\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return pluralize(\"null value\", plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.NoneConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if val is None:\n        return None\n    return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter","title":"<code>LiteralConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[T_co]</code></p> <p>Converter which accepts any of a list of literal values.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass LiteralConverter(Converter[T_co]):\n    \"\"\"\n    Converter which accepts any of a list of literal values.\n    \"\"\"\n\n    vals: t.Sequence[T_co]\n\n    def try_convert(self, val: t.Any) -&gt; T_co:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if val in self.vals:\n            return val\n        raise ParseInterrupt()\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        lits = list_phrase(tuple(map(repr, self.vals)))\n        return f\"({lits})\" if plural else lits\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if val in self.vals:\n            return None\n        return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.vals","title":"<code>vals</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.LiteralConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>Convert <code>val</code> into a data interchange format.</p> <p><code>val</code> should be of a type returned by this converter, but don't count on it.</p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"\n    Convert ``val`` into a data interchange format.\n\n    ``val`` *should* be of a type returned by this converter,\n    but don't count on it.\n    \"\"\"\n    return into_data(val, None)\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if val in self.vals:\n        return val\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    lits = list_phrase(tuple(map(repr, self.vals)))\n    return f\"({lits})\" if plural else lits\n</code></pre>"},{"location":"api/converters/#pane.converters.LiteralConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if val in self.vals:\n        return None\n    return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter","title":"<code>UnionConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[Any]</code></p> <p>Converter for an untagged union of subtypes. Unions are always evaluated left-to-right.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass UnionConverter(Converter[t.Any]):\n    \"\"\"\n    Converter for an untagged union of subtypes.\n    Unions are always evaluated left-to-right.\n    \"\"\"\n    types: t.Tuple[IntoConverter, ...]\n    \"\"\"List of potential types\"\"\"\n    converters: t.Tuple[Converter[t.Any], ...]\n    \"\"\"List of type converters\"\"\"\n    constructor: t.Optional[t.Callable[[t.Any, int], t.Any]]\n    \"\"\"\n    Constructor to call with parsed value.\n    Called with ``(val, index of type in union)``\n    \"\"\"\n\n    def __init__(self, types: t.Sequence[IntoConverter], *,\n                 handlers: ConverterHandlers = ConverterHandlers(),\n                 constructor: t.Optional[t.Callable[[t.Any, int], t.Any]] = None):\n        self.types = tuple(flatten_union_args(types))\n        self.converters = tuple(make_converter(ty, handlers) for ty in types)\n        self.constructor = constructor\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        # this is tricky, because we have no type information about which variant ``val`` is.\n        # so we basically try_convert each until we find a match\n        # this works because try_convert should be idempotent\n        for conv in self.converters:\n            try:\n                conv.try_convert(val)\n            except ParseInterrupt:\n                pass\n            else:\n                return conv.into_data(val)\n        # default to regular conversion\n        return into_data(val)\n\n    def construct(self, val: t.Any, i: int) -&gt; t.Any:\n        if self.constructor is None:\n            return val\n        return self.constructor(val, i)\n\n    def try_convert(self, val: t.Any) -&gt; t.Any:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        for (i, conv) in enumerate(self.converters):\n            try:\n                val = conv.try_convert(val)\n                try:\n                    return self.construct(val, i)\n                except Exception:\n                    pass\n            except ParseInterrupt:\n                pass\n        raise ParseInterrupt\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        failed_children: t.List[ErrorNode] = []\n        for (i, conv) in enumerate(self.converters):\n            # if one branch is successful, the whole type is successful\n            try:\n                conv_val = conv.try_convert(val)\n            except ParseInterrupt:\n                failed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\n                continue\n            try:\n                self.construct(conv_val, i)\n                return None\n            except Exception as e:\n                tb = e.__traceback__.tb_next  # type: ignore\n                tb = traceback.TracebackException(type(e), e, tb)\n                failed_children.append(WrongTypeError(self.expected(), val, tb))\n        return SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.types","title":"<code>types = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/converters/#pane.converters.UnionConverter.converters","title":"<code>converters = tuple(make_converter(ty, handlers) for ty in types)</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/converters/#pane.converters.UnionConverter.constructor","title":"<code>constructor = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/converters/#pane.converters.UnionConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    # this is tricky, because we have no type information about which variant ``val`` is.\n    # so we basically try_convert each until we find a match\n    # this works because try_convert should be idempotent\n    for conv in self.converters:\n        try:\n            conv.try_convert(val)\n        except ParseInterrupt:\n            pass\n        else:\n            return conv.into_data(val)\n    # default to regular conversion\n    return into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\n    if self.constructor is None:\n        return val\n    return self.constructor(val, i)\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    for (i, conv) in enumerate(self.converters):\n        try:\n            val = conv.try_convert(val)\n            try:\n                return self.construct(val, i)\n            except Exception:\n                pass\n        except ParseInterrupt:\n            pass\n    raise ParseInterrupt\n</code></pre>"},{"location":"api/converters/#pane.converters.UnionConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    failed_children: t.List[ErrorNode] = []\n    for (i, conv) in enumerate(self.converters):\n        # if one branch is successful, the whole type is successful\n        try:\n            conv_val = conv.try_convert(val)\n        except ParseInterrupt:\n            failed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\n            continue\n        try:\n            self.construct(conv_val, i)\n            return None\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            failed_children.append(WrongTypeError(self.expected(), val, tb))\n    return SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter","title":"<code>TaggedUnionConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>UnionConverter</code></p> <p>Converter for a tagged union of subtypes.</p> <p>Tagged unions may be parsed in three ways. The default is an 'internally tagged' union, where the tag is found by looking for a given key in the given object. This is the default. An 'externally tagged' union is stored as a dict with a key and a single value <code>{tag: content}</code>. This may be specified using <code>external=True</code>. Finally, a 'adjacently tagged' union may be specified using two keys <code>external=(t, c)</code>. The union is stored as <code>{t: tag, c: content}</code></p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass TaggedUnionConverter(UnionConverter):\n    \"\"\"\n    Converter for a tagged union of subtypes.\n\n    Tagged unions may be parsed in three ways. The default\n    is an 'internally tagged' union, where the tag is found\n    by looking for a given key in the given object. This is the\n    default.\n    An 'externally tagged' union is stored as a dict with a key\n    and a single value ``{tag: content}``. This may be specified\n    using ``external=True``.\n    Finally, a 'adjacently tagged' union may be specified using\n    two keys ``external=(t, c)``. The union is stored as\n    ``{t: tag, c: content}``\n    \"\"\"\n    tag: str\n    tag_map: t.Dict[t.Any, int]\n    \"\"\"Map from tags to indices into self.types/self.converters\"\"\"\n    external: t.Union[bool, t.Tuple[str, str]] = False\n    \"\"\"\n    Tagged union representation.\n    False: internal representation\n    True: external representation\n    (t, c): adjacent representation\n    \"\"\"\n\n    def __init__(self, types: t.Sequence[t.Any], tag: str,\n                 external: t.Union[bool, t.Tuple[str, str]] = False, *,\n                 handlers: ConverterHandlers = ConverterHandlers()):\n        super().__init__(types, handlers=handlers)\n        self.tag = tag\n        self.external = external if isinstance(external, t.Sequence) else bool(external)\n\n        # look for tag in each of self.types\n        self.tag_map = {}\n        for (i, ty) in enumerate(self.types):\n            try:\n                # TODO error if used on non-literal\n                val = getattr(ty, self.tag)\n                if val in self.tag_map:\n                    raise TypeError(f\"Tag value '{val}' matches multiple types\")\n                self.tag_map[val] = i\n            except AttributeError:\n                raise AttributeError(f\"Tag '{self.tag}' not found inside type '{ty}'\")\n\n    def tag_expected(self) -&gt; str:\n        \"\"\"Return a string list of the expected/supported tags\"\"\"\n        return list_phrase(tuple(map(repr, self.tag_map.keys())))\n\n    def obj_expected(self, plural: bool = False) -&gt; str:\n        \"\"\"Return a string list of the supported objects\"\"\"\n        return list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        if self.external is False:\n            # internally tagged\n            return self.obj_expected(plural)\n        obj = self.obj_expected(False)\n        mapping = pluralize('mapping', plural, article='a')\n        tag = list_phrase(tuple(map(repr, self.tag_map.keys())))\n        if self.external is True:\n            # externally tagged\n            return f\"{mapping} '{tag}' =&gt; {obj}\"\n        else:\n            # adjacently tagged\n            (t, c) = self.external \n            return f\"{mapping} {repr(t)} =&gt; {tag}, {repr(c)} =&gt; {obj}\"\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        tag = getattr(val, self.tag)\n        inner_conv = self.converters[self.tag_map[tag]]\n        if self.external is False:\n            # internally tagged\n            return inner_conv.into_data(val)\n        if self.external is True:\n            # externally tagged\n            return {tag: inner_conv.into_data(val)}\n        # adjacently tagged\n        (t_r, c_r) = self.external\n        return {t_r: tag, c_r: inner_conv.into_data(val)}\n\n    def try_convert(self, val: t.Any) -&gt; t.Any:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if not data_is_mapping(val):\n            raise ParseInterrupt()\n        val = t.cast(t.Dict[str, t.Any], val)\n        tag: t.Any\n\n        if self.external is False:\n            try:\n                # don't give 'tag' to variants\n                val = val.copy()\n                tag = val.pop(self.tag)\n            except KeyError:\n                raise ParseInterrupt()\n        elif self.external is True:\n            if len(val) != 1:\n                raise ParseInterrupt()\n            (tag, val) = next(iter(val.items()))\n        else:\n            (t_r, c_r) = self.external\n            try:\n                if len(val) != 2:\n                    raise ParseInterrupt()\n                tag, val = val[t_r], val[c_r]\n            except KeyError:\n                raise ParseInterrupt()\n        try:\n            i = self.tag_map[tag]\n        except KeyError:\n            raise ParseInterrupt()\n        return self.converters[i].try_convert(val)\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if not data_is_mapping(val):\n            return WrongTypeError(self.expected(), val)\n        val = t.cast(t.Dict[str, t.Any], val)\n        tag: t.Any\n\n        if self.external is False:\n            try:\n                # don't give 'tag' to variants\n                val = val.copy()\n                tag = val.pop(self.tag)\n            except KeyError:\n                return WrongTypeError(f\"mapping with key '{self.tag}' =&gt; {self.tag_expected()}\", val)\n        elif self.external is True:\n            if len(val) != 1:\n                return WrongTypeError(self.expected(), val)\n            (tag, val) = next(iter(val.items()))\n        else:\n            (t_r, c_r) = self.external\n            try:\n                if len(val) != 2:\n                    raise KeyError()\n                tag, val = val[t_r], val[c_r]\n            except KeyError:\n                return WrongTypeError(f\"mapping with keys '{t_r}' and '{c_r}'\", val)\n        try:\n            i = self.tag_map[tag]\n        except KeyError:\n            return WrongTypeError(f\"tag '{self.tag}' one of {self.tag_expected()}\", tag)\n        return self.converters[i].collect_errors(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.types","title":"<code>types = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.converters","title":"<code>converters = tuple(make_converter(ty, handlers) for ty in types)</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.constructor","title":"<code>constructor = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag","title":"<code>tag = tag</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.TaggedUnionConverter.external","title":"<code>external = external if isinstance(external, t.Sequence) else bool(external)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Tagged union representation. False: internal representation True: external representation (t, c): adjacent representation</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag_map","title":"<code>tag_map = {}</code>  <code>instance-attribute</code>","text":"<p>Map from tags to indices into self.types/self.converters</p>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\n    if self.constructor is None:\n        return val\n    return self.constructor(val, i)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.tag_expected","title":"<code>tag_expected()</code>","text":"<p>Return a string list of the expected/supported tags</p> Source code in <code>pane/converters.py</code> <pre><code>def tag_expected(self) -&gt; str:\n    \"\"\"Return a string list of the expected/supported tags\"\"\"\n    return list_phrase(tuple(map(repr, self.tag_map.keys())))\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.obj_expected","title":"<code>obj_expected(plural=False)</code>","text":"<p>Return a string list of the supported objects</p> Source code in <code>pane/converters.py</code> <pre><code>def obj_expected(self, plural: bool = False) -&gt; str:\n    \"\"\"Return a string list of the supported objects\"\"\"\n    return list_phrase(tuple(conv.expected(plural) for conv in self.converters))\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    if self.external is False:\n        # internally tagged\n        return self.obj_expected(plural)\n    obj = self.obj_expected(False)\n    mapping = pluralize('mapping', plural, article='a')\n    tag = list_phrase(tuple(map(repr, self.tag_map.keys())))\n    if self.external is True:\n        # externally tagged\n        return f\"{mapping} '{tag}' =&gt; {obj}\"\n    else:\n        # adjacently tagged\n        (t, c) = self.external \n        return f\"{mapping} {repr(t)} =&gt; {tag}, {repr(c)} =&gt; {obj}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    tag = getattr(val, self.tag)\n    inner_conv = self.converters[self.tag_map[tag]]\n    if self.external is False:\n        # internally tagged\n        return inner_conv.into_data(val)\n    if self.external is True:\n        # externally tagged\n        return {tag: inner_conv.into_data(val)}\n    # adjacently tagged\n    (t_r, c_r) = self.external\n    return {t_r: tag, c_r: inner_conv.into_data(val)}\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if not data_is_mapping(val):\n        raise ParseInterrupt()\n    val = t.cast(t.Dict[str, t.Any], val)\n    tag: t.Any\n\n    if self.external is False:\n        try:\n            # don't give 'tag' to variants\n            val = val.copy()\n            tag = val.pop(self.tag)\n        except KeyError:\n            raise ParseInterrupt()\n    elif self.external is True:\n        if len(val) != 1:\n            raise ParseInterrupt()\n        (tag, val) = next(iter(val.items()))\n    else:\n        (t_r, c_r) = self.external\n        try:\n            if len(val) != 2:\n                raise ParseInterrupt()\n            tag, val = val[t_r], val[c_r]\n        except KeyError:\n            raise ParseInterrupt()\n    try:\n        i = self.tag_map[tag]\n    except KeyError:\n        raise ParseInterrupt()\n    return self.converters[i].try_convert(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TaggedUnionConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if not data_is_mapping(val):\n        return WrongTypeError(self.expected(), val)\n    val = t.cast(t.Dict[str, t.Any], val)\n    tag: t.Any\n\n    if self.external is False:\n        try:\n            # don't give 'tag' to variants\n            val = val.copy()\n            tag = val.pop(self.tag)\n        except KeyError:\n            return WrongTypeError(f\"mapping with key '{self.tag}' =&gt; {self.tag_expected()}\", val)\n    elif self.external is True:\n        if len(val) != 1:\n            return WrongTypeError(self.expected(), val)\n        (tag, val) = next(iter(val.items()))\n    else:\n        (t_r, c_r) = self.external\n        try:\n            if len(val) != 2:\n                raise KeyError()\n            tag, val = val[t_r], val[c_r]\n        except KeyError:\n            return WrongTypeError(f\"mapping with keys '{t_r}' and '{c_r}'\", val)\n    try:\n        i = self.tag_map[tag]\n    except KeyError:\n        return WrongTypeError(f\"tag '{self.tag}' one of {self.tag_expected()}\", tag)\n    return self.converters[i].collect_errors(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter","title":"<code>StructConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Converter[T]</code></p> <p>Converter for a simple, hetereogeneous struct-like type, constructible from a dict.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass StructConverter(Converter[T]):\n    \"\"\"\n    Converter for a simple, hetereogeneous struct-like type, constructible from a dict.\n    \"\"\"\n\n    ty: t.Type[T]\n    \"\"\"Type to convert into. Must be constructible from a dict/mapping.\"\"\"\n    fields: t.Mapping[str, IntoConverter]\n    \"\"\"List of fields and their types\"\"\"\n    name: t.Optional[str] = None\n    \"\"\"Optional name of struct\"\"\"\n\n    _: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\n\n    handlers: ConverterHandlers = ConverterHandlers()\n\n    opt_fields: t.Set[str] = dataclasses.field(default_factory=set[str])\n    \"\"\"Set of fields which are optional\"\"\"\n    field_converters: t.Dict[str, Converter[t.Any]] = dataclasses.field(init=False)\n    \"\"\"Dict of sub-converters for each field\"\"\"\n\n    def __post_init__(self):\n        self.field_converters = {k: make_converter(v, self.handlers) for (k, v) in self.fields.items()}\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        name = f\" {self.name}\" if self.name is not None else \"\"\n        return f\"{pluralize('struct', plural)}{name}\"\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        assert data_is_mapping(val)\n        d: t.Dict[DataType, DataType] = {}\n        for (k, v) in t.cast(t.Mapping[str, t.Any], val).items():\n            if (ty := self.fields.get(k)) is not None and ty not in (t.Any, type(t.Any)):\n                if (conv := self.field_converters.get(k)) is not None:\n                    d[k] = conv.into_data(v)\n                    continue\n            d[k] = make_converter(t.cast(t.Type[t.Any], type(v)), self.handlers).into_data(v)\n        return d\n\n    def try_convert(self, val: t.Any) -&gt; T:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if not data_is_mapping(val):\n            raise ParseInterrupt()\n        val = t.cast(t.Dict[str, t.Any], val)\n        d: t.Dict[str, t.Any] = {}\n        for (k, v) in val.items():\n            if k not in self.fields:\n                raise ParseInterrupt()  # unknown field\n            d[k] = self.field_converters[k].try_convert(v)\n        missing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\n        if len(missing):\n            raise ParseInterrupt()\n        return self.ty(d)  # type: ignore\n\n    def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if not data_is_mapping(val):\n            return WrongTypeError(self.expected(), val)\n        val = t.cast(t.Dict[str, t.Any], val)\n\n        children: t.Dict[t.Union[str, int], t.Any] = {}\n        extra: t.Set[str] = set()\n        for (k, v) in val.items():\n            if k not in self.fields:\n                extra.add(k)\n                continue\n            if (node := self.field_converters[k].collect_errors(v)) is not None:\n                children[k] = node\n        missing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\n        if len(children) or len(missing) or len(extra):\n            return ProductErrorNode(self.expected(), children, val, missing, extra)\n        return None\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.ty","title":"<code>ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from a dict/mapping.</p>"},{"location":"api/converters/#pane.converters.StructConverter.fields","title":"<code>fields</code>  <code>instance-attribute</code>","text":"<p>List of fields and their types</p>"},{"location":"api/converters/#pane.converters.StructConverter.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional name of struct</p>"},{"location":"api/converters/#pane.converters.StructConverter.handlers","title":"<code>handlers = ConverterHandlers()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.StructConverter.opt_fields","title":"<code>opt_fields = dataclasses.field(default_factory=set[str])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set of fields which are optional</p>"},{"location":"api/converters/#pane.converters.StructConverter.field_converters","title":"<code>field_converters = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dict of sub-converters for each field</p>"},{"location":"api/converters/#pane.converters.StructConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    name = f\" {self.name}\" if self.name is not None else \"\"\n    return f\"{pluralize('struct', plural)}{name}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    assert data_is_mapping(val)\n    d: t.Dict[DataType, DataType] = {}\n    for (k, v) in t.cast(t.Mapping[str, t.Any], val).items():\n        if (ty := self.fields.get(k)) is not None and ty not in (t.Any, type(t.Any)):\n            if (conv := self.field_converters.get(k)) is not None:\n                d[k] = conv.into_data(v)\n                continue\n        d[k] = make_converter(t.cast(t.Type[t.Any], type(v)), self.handlers).into_data(v)\n    return d\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if not data_is_mapping(val):\n        raise ParseInterrupt()\n    val = t.cast(t.Dict[str, t.Any], val)\n    d: t.Dict[str, t.Any] = {}\n    for (k, v) in val.items():\n        if k not in self.fields:\n            raise ParseInterrupt()  # unknown field\n        d[k] = self.field_converters[k].try_convert(v)\n    missing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\n    if len(missing):\n        raise ParseInterrupt()\n    return self.ty(d)  # type: ignore\n</code></pre>"},{"location":"api/converters/#pane.converters.StructConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[WrongTypeError, ProductErrorNode, None]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if not data_is_mapping(val):\n        return WrongTypeError(self.expected(), val)\n    val = t.cast(t.Dict[str, t.Any], val)\n\n    children: t.Dict[t.Union[str, int], t.Any] = {}\n    extra: t.Set[str] = set()\n    for (k, v) in val.items():\n        if k not in self.fields:\n            extra.add(k)\n            continue\n        if (node := self.field_converters[k].collect_errors(v)) is not None:\n            children[k] = node\n    missing = set(self.fields.keys()) - set(val.keys()) - self.opt_fields\n    if len(children) or len(missing) or len(extra):\n        return ProductErrorNode(self.expected(), children, val, missing, extra)\n    return None\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter","title":"<code>TupleConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>Converter[T]</code></p> <p>Converter for a simple, heterogeneous tuple-like type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass TupleConverter(t.Generic[T], Converter[T]):\n    \"\"\"Converter for a simple, heterogeneous tuple-like type\"\"\"\n    ty: t.Type[T]\n    \"\"\"Type to convert into. Must be constructible from an iterable\"\"\"\n    converters: t.Tuple[Converter[t.Any], ...]\n    \"\"\"List of sub-converters for each field\"\"\"\n\n    def __init__(self, ty: t.Type[T], types: t.Sequence[IntoConverter], *,\n                 handlers: ConverterHandlers = ConverterHandlers()):\n        self.ty = ty\n        self.converters = tuple(make_converter(ty, handlers) for ty in types)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        return tuple(\n            conv.into_data(v)\n            for (v, conv) in zip(t.cast(t.Sequence[t.Any], val), self.converters)\n        )\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return f\"{pluralize('tuple', plural)} of length {len(self.converters)}\"\n\n    def try_convert(self, val: t.Any) -&gt; T:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if not data_is_sequence(val):\n            raise ParseInterrupt\n        if len(val) != len(self.converters):\n            raise ParseInterrupt\n\n        return self.ty(conv.try_convert(v) for (conv, v) in zip(self.converters, val))  # type: ignore\n\n    def collect_errors(self, val: t.Any) -&gt; t.Union[None, ProductErrorNode, WrongTypeError]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if not data_is_sequence(val) or len(val) != len(self.converters):\n            return WrongTypeError(self.expected(), val)\n        children: _ProductErrorChildren = {}\n        for (i, (conv, v)) in enumerate(zip(self.converters, val)):\n            node = conv.collect_errors(v)\n            if node is not None:\n                children[i] = node\n        if len(children) == 0:\n            return None\n        return ProductErrorNode(self.expected(), children, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from an iterable</p>"},{"location":"api/converters/#pane.converters.TupleConverter.converters","title":"<code>converters = tuple(make_converter(ty, handlers) for ty in types)</code>  <code>instance-attribute</code>","text":"<p>List of sub-converters for each field</p>"},{"location":"api/converters/#pane.converters.TupleConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    return tuple(\n        conv.into_data(v)\n        for (v, conv) in zip(t.cast(t.Sequence[t.Any], val), self.converters)\n    )\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return f\"{pluralize('tuple', plural)} of length {len(self.converters)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if not data_is_sequence(val):\n        raise ParseInterrupt\n    if len(val) != len(self.converters):\n        raise ParseInterrupt\n\n    return self.ty(conv.try_convert(v) for (conv, v) in zip(self.converters, val))  # type: ignore\n</code></pre>"},{"location":"api/converters/#pane.converters.TupleConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, ProductErrorNode, WrongTypeError]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if not data_is_sequence(val) or len(val) != len(self.converters):\n        return WrongTypeError(self.expected(), val)\n    children: _ProductErrorChildren = {}\n    for (i, (conv, v)) in enumerate(zip(self.converters, val)):\n        node = conv.collect_errors(v)\n        if node is not None:\n            children[i] = node\n    if len(children) == 0:\n        return None\n    return ProductErrorNode(self.expected(), children, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter","title":"<code>DictConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[FromDataK, FromDataV]</code>, <code>Converter[Mapping[FromDataK, FromDataV]]</code></p> <p>Converter for a homogenous dict-like type.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass DictConverter(t.Generic[FromDataK, FromDataV], Converter[t.Mapping[FromDataK, FromDataV]]):\n    \"\"\"Converter for a homogenous dict-like type.\"\"\"\n    ty: t.Type[t.Mapping[FromDataK, FromDataV]]\n    \"\"\"Type to convert into. Must be constructible from a dict (unless `constructor` is specified)\"\"\"\n    k_conv: Converter[FromDataK]\n    \"\"\"Sub-converter for keys\"\"\"\n    v_conv: Converter[FromDataV]\n    \"\"\"Sub-converter for values\"\"\"\n    constructor: t.Callable[[t.Dict[t.Any, t.Any]], t.Mapping[FromDataK, FromDataV]]\n    handlers: ConverterHandlers\n\n    def __init__(self, ty: t.Type[t.Dict[t.Any, t.Any]],\n                 k: t.Type[FromDataK] = type(t.Any), v: t.Type[FromDataV] = type(t.Any),  # type: ignore\n                 constructor: t.Optional[t.Callable[[t.Dict[t.Any, t.Any]], t.Mapping[FromDataK, FromDataV]]] = None,\n                 *, handlers: ConverterHandlers = ConverterHandlers()):\n        self.ty = ty\n        self.k_conv = make_converter(k, handlers)\n        self.v_conv = make_converter(v, handlers)\n        self.constructor = self.ty if constructor is None else constructor\n        self.handlers = handlers\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        if isinstance(self.k_conv, AnyConverter):\n            def _k_into_data(k: t.Any) -&gt; DataType:\n                return make_converter(t.cast(t.Type[t.Any], type(k)), self.handlers).into_data(k)\n        else:\n            def _k_into_data(k: t.Any) -&gt; DataType:\n                return self.k_conv.into_data(k)\n\n        if isinstance(self.v_conv, AnyConverter):\n            def _v_into_data(v: t.Any) -&gt; DataType:\n                return make_converter(t.cast(t.Type[t.Any], type(v)), self.handlers).into_data(v)\n        else:\n            def _v_into_data(v: t.Any) -&gt; DataType:\n                return self.v_conv.into_data(v)\n\n        return {\n            _k_into_data(k): _v_into_data(v)\n            for (k, v) in t.cast(t.Mapping[FromDataK, FromDataV], val).items()\n        }\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return f\"{pluralize('mapping', plural)} of {self.k_conv.expected(True)} =&gt; {self.v_conv.expected(True)}\"\n\n    def try_convert(self, val: t.Any) -&gt; t.Mapping[FromDataK, FromDataV]:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if not data_is_mapping(val):\n            raise ParseInterrupt()\n\n        d = {self.k_conv.try_convert(k): self.v_conv.try_convert(v) for (k, v) in val.items()}\n        # TODO catch errors here\n        return self.constructor(d)\n\n    def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if not data_is_mapping(val):\n            return WrongTypeError(self.expected(), val)\n\n        nodes: _ProductErrorChildren = {}\n        for (k, v) in val.items():\n            if (node := self.k_conv.collect_errors(k)) is not None:\n                nodes[str(k)] = node  # TODO split bad fields from bad values\n            if (node := self.v_conv.collect_errors(v)) is not None:\n                nodes[str(k)] = node\n        if len(nodes):\n            return ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from a dict (unless <code>constructor</code> is specified)</p>"},{"location":"api/converters/#pane.converters.DictConverter.k_conv","title":"<code>k_conv = make_converter(k, handlers)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for keys</p>"},{"location":"api/converters/#pane.converters.DictConverter.v_conv","title":"<code>v_conv = make_converter(v, handlers)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for values</p>"},{"location":"api/converters/#pane.converters.DictConverter.constructor","title":"<code>constructor = self.ty if constructor is None else constructor</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DictConverter.handlers","title":"<code>handlers = handlers</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DictConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    if isinstance(self.k_conv, AnyConverter):\n        def _k_into_data(k: t.Any) -&gt; DataType:\n            return make_converter(t.cast(t.Type[t.Any], type(k)), self.handlers).into_data(k)\n    else:\n        def _k_into_data(k: t.Any) -&gt; DataType:\n            return self.k_conv.into_data(k)\n\n    if isinstance(self.v_conv, AnyConverter):\n        def _v_into_data(v: t.Any) -&gt; DataType:\n            return make_converter(t.cast(t.Type[t.Any], type(v)), self.handlers).into_data(v)\n    else:\n        def _v_into_data(v: t.Any) -&gt; DataType:\n            return self.v_conv.into_data(v)\n\n    return {\n        _k_into_data(k): _v_into_data(v)\n        for (k, v) in t.cast(t.Mapping[FromDataK, FromDataV], val).items()\n    }\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return f\"{pluralize('mapping', plural)} of {self.k_conv.expected(True)} =&gt; {self.v_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Mapping[FromDataK, FromDataV]:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if not data_is_mapping(val):\n        raise ParseInterrupt()\n\n    d = {self.k_conv.try_convert(k): self.v_conv.try_convert(v) for (k, v) in val.items()}\n    # TODO catch errors here\n    return self.constructor(d)\n</code></pre>"},{"location":"api/converters/#pane.converters.DictConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if not data_is_mapping(val):\n        return WrongTypeError(self.expected(), val)\n\n    nodes: _ProductErrorChildren = {}\n    for (k, v) in val.items():\n        if (node := self.k_conv.collect_errors(k)) is not None:\n            nodes[str(k)] = node  # TODO split bad fields from bad values\n        if (node := self.v_conv.collect_errors(v)) is not None:\n            nodes[str(k)] = node\n    if len(nodes):\n        return ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter","title":"<code>SequenceConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[FromDataT]</code>, <code>Converter[Sequence[FromDataT]]</code></p> <p>Converter for a homogenous sequence-like type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass SequenceConverter(t.Generic[FromDataT], Converter[t.Sequence[FromDataT]]):\n    \"\"\"Converter for a homogenous sequence-like type\"\"\"\n    ty: type\n    \"\"\"Type to convert into. Must be constructible from an iterator.\"\"\"\n    v_conv: Converter[FromDataT]\n    \"\"\"Sub-converter for values\"\"\"\n    constructor: t.Callable[[t.Iterable[t.Any]], t.Sequence[t.Any]]\n    handlers: ConverterHandlers\n\n    def __init__(self, ty: t.Type[t.Sequence[t.Any]], v: t.Type[FromDataT] = t.cast(t.Type[t.Any], type(t.Any)), *,\n                 handlers: ConverterHandlers = ConverterHandlers(),\n                 constructor: t.Optional[t.Callable[[t.Iterable[t.Any]], t.Sequence[t.Any]]] = None):\n        self.ty = ty\n        self.v_conv = make_converter(v, handlers)\n        self.handlers = handlers\n        self.constructor = self.ty if constructor is None else constructor\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        # construct tuple from a tuple, or a list otherwise\n        constructor = t.cast(t.Callable[[t.Iterable[t.Any]], t.Sequence[t.Any]], tuple if self.constructor is tuple else list)\n        if self.ty in (t.Any, type(t.Any)):\n            # also need to infer member types\n            return constructor(\n                make_converter(type(v), self.handlers).into_data(v)\n                for v in t.cast(t.Sequence[FromDataT], val)\n            )\n        return constructor(\n            self.v_conv.into_data(v)\n            for v in t.cast(t.Sequence[FromDataT], val)\n        )\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return f\"{pluralize('sequence', plural)} of {self.v_conv.expected(True)}\"\n\n    def try_convert(self, val: t.Any) -&gt; t.Sequence[FromDataT]:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if not data_is_sequence(val):\n            raise ParseInterrupt\n        try:\n            return self.constructor(self.v_conv.try_convert(v) for v in val)  # type: ignore\n        except Exception:\n            raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if not data_is_sequence(val):\n            return WrongTypeError(self.expected(), val)\n\n        nodes: t.Dict[t.Union[int, str], ErrorNode] = {}\n        vals: t.List[FromDataT] = []\n        for (i, v) in enumerate(val):\n            try:\n                vals.append(self.v_conv.convert(v))\n            except ConvertError as e:\n                nodes[i] = e.tree\n\n        if len(nodes):\n            return ProductErrorNode(self.expected(), nodes, val)\n        # try to construct val\n        try:\n            self.constructor(iter(vals))\n            return None\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":"<p>Type to convert into. Must be constructible from an iterator.</p>"},{"location":"api/converters/#pane.converters.SequenceConverter.v_conv","title":"<code>v_conv = make_converter(v, handlers)</code>  <code>instance-attribute</code>","text":"<p>Sub-converter for values</p>"},{"location":"api/converters/#pane.converters.SequenceConverter.handlers","title":"<code>handlers = handlers</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.SequenceConverter.constructor","title":"<code>constructor = self.ty if constructor is None else constructor</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.SequenceConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    # construct tuple from a tuple, or a list otherwise\n    constructor = t.cast(t.Callable[[t.Iterable[t.Any]], t.Sequence[t.Any]], tuple if self.constructor is tuple else list)\n    if self.ty in (t.Any, type(t.Any)):\n        # also need to infer member types\n        return constructor(\n            make_converter(type(v), self.handlers).into_data(v)\n            for v in t.cast(t.Sequence[FromDataT], val)\n        )\n    return constructor(\n        self.v_conv.into_data(v)\n        for v in t.cast(t.Sequence[FromDataT], val)\n    )\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return f\"{pluralize('sequence', plural)} of {self.v_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Sequence[FromDataT]:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if not data_is_sequence(val):\n        raise ParseInterrupt\n    try:\n        return self.constructor(self.v_conv.try_convert(v) for v in val)  # type: ignore\n    except Exception:\n        raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.SequenceConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Union[None, WrongTypeError, ProductErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if not data_is_sequence(val):\n        return WrongTypeError(self.expected(), val)\n\n    nodes: t.Dict[t.Union[int, str], ErrorNode] = {}\n    vals: t.List[FromDataT] = []\n    for (i, v) in enumerate(val):\n        try:\n            vals.append(self.v_conv.convert(v))\n        except ConvertError as e:\n            nodes[i] = e.tree\n\n    if len(nodes):\n        return ProductErrorNode(self.expected(), nodes, val)\n    # try to construct val\n    try:\n        self.constructor(iter(vals))\n        return None\n    except Exception as e:\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter","title":"<code>NestedSequenceConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T, U]</code>, <code>Converter[T]</code></p> <p>Converter which delegates to a sub-converter, and then attempts to construct a different type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass NestedSequenceConverter(t.Generic[T, U], Converter[T]):\n    \"\"\"\n    Converter which delegates to a sub-converter, and then attempts\n    to construct a different type\n    \"\"\"\n    val_type: t.Type[U]\n    \"\"\"Inner type to convert to\"\"\"\n    constructor: t.Callable[[NestedSequence[U]], T]\n    \"\"\"Constructor to call.\"\"\"\n\n    handlers: ConverterHandlers = ConverterHandlers()\n\n    ragged: bool = False\n    \"\"\"Whether to accept ragged arrays.\"\"\"\n    into_data_f: t.Optional[t.Callable[[t.Any], DataType]] = None\n\n    val_conv: Converter[U] = dataclasses.field(init=False)\n    \"\"\"[`Converter`][pane.converters.Converter] for value type\"\"\"\n\n    def __post_init__(self):\n        self.val_conv = make_converter(self.val_type, self.handlers)\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        word = 'nested sequence' if self.ragged else 'n-d array'\n        return f\"{pluralize(word, plural, article='a')} of {self.val_conv.expected(True)}\"\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        if self.into_data_f is not None:\n            return self.into_data_f(val)\n        return self._into_data(val)\n\n    def _into_data(self, val: t.Any) -&gt; DataType:\n        if data_is_iterable(val):\n            return list(map(self._into_data, val))\n        if self.val_type in (t.Any, t.cast(t.Type[t.Any], type(t.Any))):\n            return make_converter(t.cast(t.Type[t.Any], type(val)), self.handlers).into_data(val)\n        return self.val_conv.into_data(val)\n\n    @staticmethod\n    def _check_shape(val: NestedSequence[t.Any], dim: int = 0) -&gt; t.Tuple[int, ...]:\n        if not data_is_sequence(val):\n            # single value\n            return ()\n        shapes = [NestedSequenceConverter._check_shape(v, dim+1) for v in val]\n        if len(shapes) == 0:\n            return (0,)\n        shape = shapes[0]\n        if not all(s == shape for s in shapes):\n            raise ValueError(f\"shape mismatch at dim {dim}. Sub-shapes: {shapes}\")\n        new_shape = (len(shapes), *shape)\n        return new_shape\n\n    def try_convert(self, val: t.Any) -&gt; T:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        result = self._try_convert(val)\n        if not self.ragged:\n            try:\n                self._check_shape(result)\n            except ValueError:\n                raise ParseInterrupt()\n        return self.constructor(result)\n\n    def _try_convert(self, val: t.Any) -&gt; NestedSequence[U]:\n        if not data_is_sequence(val):\n            # single value\n            return self.val_conv.try_convert(val)\n        vals = list(map(self._try_convert, val))\n        return t.cast(NestedSequence[U], vals)\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if (node := self._collect_errors(val)) is not None:\n            return node\n        val = self._try_convert(val)\n        if not self.ragged:\n            try:\n                self._check_shape(val)\n            except ValueError as e:\n                return WrongTypeError(self.expected(), val, info=e.args[0])\n        try:\n            self.constructor(val)\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n\n    def _collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        if not data_is_sequence(val):\n            return self.val_conv.collect_errors(val)\n        nodes: _ProductErrorChildren = {}\n        for (i, v) in enumerate(val):\n            if (node := self._collect_errors(v)) is not None:\n                nodes[i] = node\n        if len(nodes):\n            return ProductErrorNode(self.expected(), nodes, val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.val_type","title":"<code>val_type</code>  <code>instance-attribute</code>","text":"<p>Inner type to convert to</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.constructor","title":"<code>constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call.</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.handlers","title":"<code>handlers = ConverterHandlers()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.NestedSequenceConverter.ragged","title":"<code>ragged = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to accept ragged arrays.</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.into_data_f","title":"<code>into_data_f = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.NestedSequenceConverter.val_conv","title":"<code>val_conv = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p><code>Converter</code> for value type</p>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    word = 'nested sequence' if self.ragged else 'n-d array'\n    return f\"{pluralize(word, plural, article='a')} of {self.val_conv.expected(True)}\"\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    if self.into_data_f is not None:\n        return self.into_data_f(val)\n    return self._into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    result = self._try_convert(val)\n    if not self.ragged:\n        try:\n            self._check_shape(result)\n        except ValueError:\n            raise ParseInterrupt()\n    return self.constructor(result)\n</code></pre>"},{"location":"api/converters/#pane.converters.NestedSequenceConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if (node := self._collect_errors(val)) is not None:\n        return node\n    val = self._try_convert(val)\n    if not self.ragged:\n        try:\n            self._check_shape(val)\n        except ValueError as e:\n            return WrongTypeError(self.expected(), val, info=e.args[0])\n    try:\n        self.constructor(val)\n    except Exception as e:\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter","title":"<code>ConditionalConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[FromDataT]</code>, <code>Converter[FromDataT]</code></p> <p>Converter which applies an arbitrary pre-condition to the converted value.</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass ConditionalConverter(t.Generic[FromDataT], Converter[FromDataT]):\n    \"\"\"\n    Converter which applies an arbitrary pre-condition to the converted value.\n    \"\"\"\n    inner_type: t.Union[Converter[FromDataT], IntoConverter]\n    \"\"\"Inner type to apply condition to\"\"\"\n    condition: t.Callable[[FromDataT], bool]\n    \"\"\"Function to evaluate condition\"\"\"\n    condition_name: str\n    \"\"\"Human-readable name of condition\"\"\"\n    make_expected: t.Callable[[str, bool], str]\n    \"\"\"Function which takes ``(expected, plural)`` and makes a compound ``expected``.\"\"\"\n    handlers: ConverterHandlers = ConverterHandlers()\n\n    inner: Converter[FromDataT] = dataclasses.field(init=False)\n    \"\"\"Inner sub-converter\"\"\"\n\n    def __post_init__(self):\n        if isinstance(self.inner_type, Converter):\n            self.inner = self.inner_type\n        else:\n            self.inner = make_converter(t.cast(t.Type[FromDataT], self.inner_type), self.handlers)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        return self.inner.into_data(val)\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return self.make_expected(self.inner.expected(plural), plural)\n\n    def try_convert(self, val: t.Any) -&gt; FromDataT:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        val = self.inner.try_convert(val)\n        try:\n            if self.condition(val):\n                return val\n        except Exception:\n            pass\n        raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        try:\n            conv_val = self.inner.try_convert(val)\n        except ParseInterrupt:\n            # TODO with_expected() here\n            return self.inner.collect_errors(val)\n        try:\n            # condition failed\n            if not self.condition(conv_val):\n                return ConditionFailedError(self.expected(), val, self.condition_name)\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return ConditionFailedError(self.expected(), val, self.condition_name, tb)\n        return None\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.inner_type","title":"<code>inner_type</code>  <code>instance-attribute</code>","text":"<p>Inner type to apply condition to</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.condition","title":"<code>condition</code>  <code>instance-attribute</code>","text":"<p>Function to evaluate condition</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.condition_name","title":"<code>condition_name</code>  <code>instance-attribute</code>","text":"<p>Human-readable name of condition</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.make_expected","title":"<code>make_expected</code>  <code>instance-attribute</code>","text":"<p>Function which takes <code>(expected, plural)</code> and makes a compound <code>expected</code>.</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.handlers","title":"<code>handlers = ConverterHandlers()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.ConditionalConverter.inner","title":"<code>inner = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner sub-converter</p>"},{"location":"api/converters/#pane.converters.ConditionalConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    return self.inner.into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return self.make_expected(self.inner.expected(plural), plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; FromDataT:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    val = self.inner.try_convert(val)\n    try:\n        if self.condition(val):\n            return val\n    except Exception:\n        pass\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.ConditionalConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    try:\n        conv_val = self.inner.try_convert(val)\n    except ParseInterrupt:\n        # TODO with_expected() here\n        return self.inner.collect_errors(val)\n    try:\n        # condition failed\n        if not self.condition(conv_val):\n            return ConditionFailedError(self.expected(), val, self.condition_name)\n    except Exception as e:\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return ConditionFailedError(self.expected(), val, self.condition_name, tb)\n    return None\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter","title":"<code>EnumConverter</code>","text":"<p>               Bases: <code>Converter[Enum]</code></p> Source code in <code>pane/converters.py</code> <pre><code>class EnumConverter(Converter[enum.Enum]):\n    def __init__(self, ty: t.Type[enum.Enum], handlers: ConverterHandlers = ConverterHandlers()):\n        from pane.convert import _DataType  # type: ignore\n        if issubclass(ty, enum.Flag):\n            raise TypeError(\"Flag enums are not currently supported\")\n        self.ty: t.Type[enum.Enum] = ty\n\n        members = ty.__members__.values()\n        try:\n            self.val_map = {member.value: member for member in members}\n        except TypeError:\n            raise TypeError(\"All enum members must be hashable\")\n\n        self.member_vals = tuple(self.val_map.keys())\n        if not all(isinstance(val, _DataType) for val in self.member_vals):\n            raise TypeError(\"All enum members must be data-interchange types\")\n\n        self.inner_ty = type_union(map(type, self.member_vals))\n        self.inner_conv: Converter[t.Any] = make_converter(self.inner_ty, handlers)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        if isinstance(val, self.ty):\n            return val.value  # guaranteed to be data-interchange type\n        return into_data(val)\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        vs = list_phrase(tuple(map(str, self.member_vals)))\n        return f\"{pluralize('member', plural)} of enum '{self.ty.__name__}' ({vs})\"\n\n    def try_convert(self, val: t.Any) -&gt; enum.Enum:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        val = self.inner_conv.try_convert(val)\n        try:\n            return self.val_map[val]\n        except KeyError:\n            raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        try:\n            val = self.inner_conv.try_convert(val)\n        except ParseInterrupt:\n            return self.inner_conv.collect_errors(val)\n        try:\n            self.val_map[val]\n            return None\n        except KeyError:\n            return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.val_map","title":"<code>val_map = {member.value: memberfor member in members}</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.member_vals","title":"<code>member_vals = tuple(self.val_map.keys())</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.inner_ty","title":"<code>inner_ty = type_union(map(type, self.member_vals))</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.inner_conv","title":"<code>inner_conv = make_converter(self.inner_ty, handlers)</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.EnumConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    if isinstance(val, self.ty):\n        return val.value  # guaranteed to be data-interchange type\n    return into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    vs = list_phrase(tuple(map(str, self.member_vals)))\n    return f\"{pluralize('member', plural)} of enum '{self.ty.__name__}' ({vs})\"\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; enum.Enum:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    val = self.inner_conv.try_convert(val)\n    try:\n        return self.val_map[val]\n    except KeyError:\n        raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.EnumConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    try:\n        val = self.inner_conv.try_convert(val)\n    except ParseInterrupt:\n        return self.inner_conv.collect_errors(val)\n    try:\n        self.val_map[val]\n        return None\n    except KeyError:\n        return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter","title":"<code>DelegateConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T, U]</code>, <code>Converter[T]</code></p> <p>Converter which delegates to a sub-converter, and then attempts to construct a different type</p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass\nclass DelegateConverter(t.Generic[T, U], Converter[T]):\n    \"\"\"\n    Converter which delegates to a sub-converter, and then attempts\n    to construct a different type\n    \"\"\"\n    from_type: t.Type[U]\n    \"\"\"Inner type to convert to\"\"\"\n    constructor: t.Callable[[U], T]\n    \"\"\"Constructor for outer type\"\"\"\n    expect: t.Optional[str] = None\n    \"\"\"Expected value. Defaults to inner expected value.\"\"\"\n    expect_plural: t.Optional[str] = None\n    \"\"\"Plural expected value. Defaults to inner expected value.\"\"\"\n    handlers: ConverterHandlers = ConverterHandlers()\n\n    inner: Converter[U] = dataclasses.field(init=False)\n    \"\"\"Inner sub-converter\"\"\"\n\n    def __post_init__(self):\n        self.inner = make_converter(self.from_type, self.handlers)\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n        # TODO: this is a hack, because we can't easily convert T back to U\n        try:\n            return self.inner.into_data(val)\n        except Exception:\n            pass\n        return into_data(val)\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        if not plural and self.expect:\n            return self.expect\n        if plural and self.expect_plural:\n            return self.expect_plural\n        return self.inner.expected(plural)\n\n    def try_convert(self, val: t.Any) -&gt; T:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        val = self.inner.try_convert(val)\n        try:\n            return self.constructor(val)\n        except Exception:\n            raise ParseInterrupt from None\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        try:\n            conv_val = self.inner.try_convert(val)\n        except ParseInterrupt:\n            # TODO with_expected() here\n            return self.inner.collect_errors(val)\n        try:\n            self.constructor(conv_val)\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.from_type","title":"<code>from_type</code>  <code>instance-attribute</code>","text":"<p>Inner type to convert to</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.constructor","title":"<code>constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor for outer type</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.expect","title":"<code>expect = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected value. Defaults to inner expected value.</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.expect_plural","title":"<code>expect_plural = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plural expected value. Defaults to inner expected value.</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.handlers","title":"<code>handlers = ConverterHandlers()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DelegateConverter.inner","title":"<code>inner = dataclasses.field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner sub-converter</p>"},{"location":"api/converters/#pane.converters.DelegateConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.into_data","title":"<code>into_data(val)</code>","text":"<p>See <code>Converter.into_data</code></p> Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    \"\"\"See [`Converter.into_data`][pane.converters.Converter.into_data]\"\"\"\n    # TODO: this is a hack, because we can't easily convert T back to U\n    try:\n        return self.inner.into_data(val)\n    except Exception:\n        pass\n    return into_data(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    if not plural and self.expect:\n        return self.expect\n    if plural and self.expect_plural:\n        return self.expect_plural\n    return self.inner.expected(plural)\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; T:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    val = self.inner.try_convert(val)\n    try:\n        return self.constructor(val)\n    except Exception:\n        raise ParseInterrupt from None\n</code></pre>"},{"location":"api/converters/#pane.converters.DelegateConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    try:\n        conv_val = self.inner.try_convert(val)\n    except ParseInterrupt:\n        # TODO with_expected() here\n        return self.inner.collect_errors(val)\n    try:\n        self.constructor(conv_val)\n    except Exception as e:\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(self.expected(), val, tb)\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter","title":"<code>PatternConverter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[AnyStr]</code>, <code>Converter[Pattern[AnyStr]]</code></p> Source code in <code>pane/converters.py</code> <pre><code>@dataclasses.dataclass(init=False)\nclass PatternConverter(t.Generic[t.AnyStr], Converter[re.Pattern[t.AnyStr]]):\n    ty: t.Type[t.AnyStr]\n    ty_conv: Converter[t.AnyStr]\n\n    def __init__(self, ty: t.Type[t.AnyStr] = str, *args: t.Any,\n                 handlers: ConverterHandlers = ConverterHandlers()):\n        if len(args) &gt; 0:\n            raise TypeError(\"PatternConverter takes only one type argument\")\n        self.ty = ty\n        if not issubclass(ty, (str, bytes)):\n            raise TypeError(f\"Pattern only accepts a 'str' or 'bytes' type argument, instead got '{ty!r}'\")\n        self.ty_conv = make_converter(self.ty, handlers)\n\n    def into_data(self, val: t.Any) -&gt; t.AnyStr:\n        assert isinstance(val, re.Pattern)\n        return t.cast(re.Pattern[t.AnyStr], val).pattern\n\n    def expected(self, plural: bool = False) -&gt; str:\n        ty = 'bytes' if self.ty is bytes else 'string'\n        return pluralize(f'{ty} regex pattern', plural, article='a')\n\n    def try_convert(self, val: t.Any) -&gt; re.Pattern[t.AnyStr]:\n        if isinstance(val, re.Pattern):\n            val = t.cast(re.Pattern[t.Any], val).pattern\n        s = self.ty_conv.try_convert(val)\n        try:\n            return re.compile(s)\n        except Exception:\n            raise ParseInterrupt from None\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        if isinstance(val, re.Pattern):\n            val = t.cast(re.Pattern[t.Any], val).pattern\n        try:\n            s = self.ty_conv.try_convert(val)\n        except ParseInterrupt:\n            return WrongTypeError(self.expected(), val)\n        try:\n            re.compile(s)\n        except re.error as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n        return None\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.PatternConverter.ty_conv","title":"<code>ty_conv = make_converter(self.ty, handlers)</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.PatternConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; t.AnyStr:\n    assert isinstance(val, re.Pattern)\n    return t.cast(re.Pattern[t.AnyStr], val).pattern\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.expected","title":"<code>expected(plural=False)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    ty = 'bytes' if self.ty is bytes else 'string'\n    return pluralize(f'{ty} regex pattern', plural, article='a')\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.try_convert","title":"<code>try_convert(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; re.Pattern[t.AnyStr]:\n    if isinstance(val, re.Pattern):\n        val = t.cast(re.Pattern[t.Any], val).pattern\n    s = self.ty_conv.try_convert(val)\n    try:\n        return re.compile(s)\n    except Exception:\n        raise ParseInterrupt from None\n</code></pre>"},{"location":"api/converters/#pane.converters.PatternConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    if isinstance(val, re.Pattern):\n        val = t.cast(re.Pattern[t.Any], val).pattern\n    try:\n        s = self.ty_conv.try_convert(val)\n    except ParseInterrupt:\n        return WrongTypeError(self.expected(), val)\n    try:\n        re.compile(s)\n    except re.error as e:\n        tb = e.__traceback__.tb_next  # type: ignore\n        tb = traceback.TracebackException(type(e), e, tb)\n        return WrongTypeError(self.expected(), val, tb)\n    return None\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter","title":"<code>DatetimeConverter</code>","text":"<p>               Bases: <code>Converter[DatetimeT]</code>, <code>Generic[DatetimeT]</code></p> <p>Converter for a simple scalar type, constructible from a list of allowed types.</p> Source code in <code>pane/converters.py</code> <pre><code>class DatetimeConverter(Converter[DatetimeT], t.Generic[DatetimeT]):\n    \"\"\"\n    Converter for a simple scalar type,\n    constructible from a list of allowed types.\n    \"\"\"\n    _date_types: t.Tuple[type, ...] = (datetime.date, datetime.time, datetime.datetime)\n    _expected: t.Mapping[type, str] = {\n        datetime.date: \"date\",\n        datetime.datetime: \"datetime\",\n        datetime.time: \"time\",\n    }\n\n    def __init__(self, ty: t.Type[DatetimeT]):\n        self.ty = ty\n        self.super_ty: t.Type[DatetimeT]\n        if ty in self._date_types:\n            self.super_ty = t.cast(t.Type[DatetimeT], ty)\n            return\n        for date_ty in self._date_types:\n            if issubclass(ty, date_ty):\n                self.super_ty = t.cast(t.Type[DatetimeT], date_ty)\n                return\n        raise TypeError(f\"Only types {list_phrase([repr(str(ty)) for ty in self._date_types])} are supported\")\n\n    def __eq__(self, other: t.Any) -&gt; bool:\n        return type(self) is type(other) and self.ty is other.ty\n\n    def expected(self, plural: bool = False) -&gt; str:\n        \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n        return pluralize(self._expected[self.super_ty], plural, article='a')\n\n    def into_data(self, val: t.Any) -&gt; str:\n        if isinstance(val, (datetime.time, datetime.date, datetime.datetime)):\n            return val.isoformat()\n        return str(val)\n\n    #                input type:\n    # output type:     date    datetime  time    str\n    #          date     id     .date()   error  parse\n    #      datetime   combine     id     error  parse\n    #          time    error   .timetz()  id    parse\n\n    def from_datetime(self, dt: datetime.datetime) -&gt; DatetimeT:\n        d: t.Mapping[type, t.Callable[[datetime.datetime], DatetimeT]] = {\n            # datetime to datetime\n            datetime.datetime: lambda dt: t.cast(DatetimeT, dt),\n            # datetime to time\n            datetime.time: lambda dt: t.cast(DatetimeT, dt.time()),\n            # datetime to date\n            datetime.date: lambda dt: t.cast(DatetimeT, dt.date()),\n        }\n        return d[self.super_ty](dt)\n\n    def from_date(self, dt: datetime.date) -&gt; DatetimeT:\n        def err(val: t.Any):\n            raise TypeError()\n\n        d: t.Mapping[type, t.Callable[[datetime.date], DatetimeT]] = {\n            # date to datetime\n            datetime.datetime: lambda date: t.cast(DatetimeT, datetime.datetime.combine(date, datetime.time())),\n            # date to date\n            datetime.date: lambda date: t.cast(DatetimeT, date),\n            datetime.time: err,\n        }\n        return d[self.super_ty](dt)\n\n    def try_convert(self, val: t.Any) -&gt; DatetimeT:\n        \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n        if isinstance(val, str):\n            # parse string\n            try:\n                return t.cast(DatetimeT, self.ty.fromisoformat(val))\n            except ValueError:\n                raise ParseInterrupt() from None\n        if isinstance(val, datetime.datetime):\n            # from datetime, to datetime, date, or time\n            return self.from_datetime(val)\n        elif isinstance(val, datetime.time):\n            # from time, to time only\n            if self.super_ty == datetime.time:\n                return t.cast(DatetimeT, val)\n        elif isinstance(val, datetime.date):\n            # from date, to date or datetime\n            if self.super_ty != datetime.time:\n                return self.from_date(val)\n        raise ParseInterrupt()\n\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n        \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n        if isinstance(val, str):\n            # parse string\n            try:\n                self.ty.fromisoformat(val)\n                return None\n            except ValueError as e:\n                tb = e.__traceback__.tb_next  # type: ignore\n                tb = traceback.TracebackException(type(e), e, tb)\n                return WrongTypeError(self.expected(), val, tb)\n        if isinstance(val, datetime.datetime):\n            return None\n        elif isinstance(val, datetime.time):\n            if self.super_ty == datetime.time:\n                return None\n        elif isinstance(val, datetime.date):\n            if self.super_ty != datetime.time:\n                return None\n        return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeConverter.super_ty","title":"<code>super_ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/converters/#pane.converters.DatetimeConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.expected","title":"<code>expected(plural=False)</code>","text":"<p>See <code>Converter.expected</code></p> Source code in <code>pane/converters.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    \"\"\"See [`Converter.expected`][pane.converters.Converter.expected]\"\"\"\n    return pluralize(self._expected[self.super_ty], plural, article='a')\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; str:\n    if isinstance(val, (datetime.time, datetime.date, datetime.datetime)):\n        return val.isoformat()\n    return str(val)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.from_datetime","title":"<code>from_datetime(dt)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def from_datetime(self, dt: datetime.datetime) -&gt; DatetimeT:\n    d: t.Mapping[type, t.Callable[[datetime.datetime], DatetimeT]] = {\n        # datetime to datetime\n        datetime.datetime: lambda dt: t.cast(DatetimeT, dt),\n        # datetime to time\n        datetime.time: lambda dt: t.cast(DatetimeT, dt.time()),\n        # datetime to date\n        datetime.date: lambda dt: t.cast(DatetimeT, dt.date()),\n    }\n    return d[self.super_ty](dt)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.from_date","title":"<code>from_date(dt)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def from_date(self, dt: datetime.date) -&gt; DatetimeT:\n    def err(val: t.Any):\n        raise TypeError()\n\n    d: t.Mapping[type, t.Callable[[datetime.date], DatetimeT]] = {\n        # date to datetime\n        datetime.datetime: lambda date: t.cast(DatetimeT, datetime.datetime.combine(date, datetime.time())),\n        # date to date\n        datetime.date: lambda date: t.cast(DatetimeT, date),\n        datetime.time: err,\n    }\n    return d[self.super_ty](dt)\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; DatetimeT:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    if isinstance(val, str):\n        # parse string\n        try:\n            return t.cast(DatetimeT, self.ty.fromisoformat(val))\n        except ValueError:\n            raise ParseInterrupt() from None\n    if isinstance(val, datetime.datetime):\n        # from datetime, to datetime, date, or time\n        return self.from_datetime(val)\n    elif isinstance(val, datetime.time):\n        # from time, to time only\n        if self.super_ty == datetime.time:\n            return t.cast(DatetimeT, val)\n    elif isinstance(val, datetime.date):\n        # from date, to date or datetime\n        if self.super_ty != datetime.time:\n            return self.from_date(val)\n    raise ParseInterrupt()\n</code></pre>"},{"location":"api/converters/#pane.converters.DatetimeConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[WrongTypeError]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    if isinstance(val, str):\n        # parse string\n        try:\n            self.ty.fromisoformat(val)\n            return None\n        except ValueError as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            return WrongTypeError(self.expected(), val, tb)\n    if isinstance(val, datetime.datetime):\n        return None\n    elif isinstance(val, datetime.time):\n        if self.super_ty == datetime.time:\n            return None\n    elif isinstance(val, datetime.date):\n        if self.super_ty != datetime.time:\n            return None\n    return WrongTypeError(self.expected(), val)\n</code></pre>"},{"location":"api/converters/#pane.converters.data_is_sequence","title":"<code>data_is_sequence(val)</code>","text":"<p>Return whether <code>val</code> is a sequence-like data type.</p> Source code in <code>pane/converters.py</code> <pre><code>def data_is_sequence(val: t.Any) -&gt; TypeGuard[t.Sequence[t.Any]]:\n    \"\"\"Return whether `val` is a sequence-like data type.\"\"\"\n    return isinstance(val, t.Sequence) and not isinstance(val, (str, bytes, bytearray))\n</code></pre>"},{"location":"api/converters/#pane.converters.data_is_iterable","title":"<code>data_is_iterable(val)</code>","text":"<p>Return whether <code>val</code> is an iterable (not str or bytes) data type.</p> Source code in <code>pane/converters.py</code> <pre><code>def data_is_iterable(val: t.Any) -&gt; TypeGuard[t.Sequence[t.Any]]:\n    \"\"\"Return whether `val` is an iterable (not str or bytes) data type.\"\"\"\n    return isinstance(val, t.Iterable) and not isinstance(val, (str, bytes, bytearray))\n</code></pre>"},{"location":"api/converters/#pane.converters.data_is_mapping","title":"<code>data_is_mapping(val)</code>","text":"<p>Return whether <code>val</code> is a mapping-like data type.</p> Source code in <code>pane/converters.py</code> <pre><code>def data_is_mapping(val: t.Any) -&gt; TypeGuard[t.Mapping[t.Any, t.Any]]:\n    \"\"\"Return whether `val` is a mapping-like data type.\"\"\"\n    return isinstance(val, (dict, t.Mapping))\n</code></pre>"},{"location":"api/errors/","title":"pane.errors","text":""},{"location":"api/errors/#pane.errors","title":"<code>pane.errors</code>","text":"<p>Error types for <code>pane</code> library.</p>"},{"location":"api/errors/#pane.errors.ParseInterrupt","title":"<code>ParseInterrupt</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised by <code>Converter</code>s to indicate that a given parsing path has failed (without materializing a detailed error message).</p> Source code in <code>pane/errors.py</code> <pre><code>class ParseInterrupt(Exception):\n    \"\"\"\n    Raised by [`Converter`][pane.converters.Converter]s to indicate that a given parsing path has failed\n    (without materializing a detailed error message).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/errors/#pane.errors.UnsupportedAnnotation","title":"<code>UnsupportedAnnotation</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a given <code>t.Annotated</code> isn't understood by <code>pane</code>.</p> Source code in <code>pane/errors.py</code> <pre><code>class UnsupportedAnnotation(Exception):\n    \"\"\"\n    Raised when a given [`t.Annotated`][typing.Annotated] isn't understood by `pane`.\n    \"\"\"\n    def __init__(self, obj: t.Any):\n        self.obj: t.Any = obj\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.obj!r})\"\n\n    def __str__(self) -&gt; str:\n        return f\"Unsupported annotation: {self.obj!r}\"\n</code></pre>"},{"location":"api/errors/#pane.errors.UnsupportedAnnotation.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pane.errors.ConvertError","title":"<code>ConvertError</code>","text":"<p>               Bases: <code>Exception</code></p> <p><code>pane</code> conversion error.</p> <p><code>self.tree</code> contains a detailed error tree, and <code>str(self)</code> is a human-friendly representation of the same.</p> Source code in <code>pane/errors.py</code> <pre><code>class ConvertError(Exception):\n    \"\"\"\n    `pane` conversion error.\n\n    `self.tree` contains a detailed error tree, and `str(self)`\n    is a human-friendly representation of the same.\n    \"\"\"\n    def __init__(self, tree: ErrorNode):\n        self.tree: ErrorNode = tree\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.tree!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.tree)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConvertError.tree","title":"<code>tree = tree</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pane.errors.ErrorNode","title":"<code>ErrorNode</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract node in a conversion error tree</p> Source code in <code>pane/errors.py</code> <pre><code>class ErrorNode(abc.ABC):\n    \"\"\"\n    Abstract node in a conversion error tree\n    \"\"\"\n\n    @abc.abstractmethod\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        \"\"\"\n        Print a description of this error to `file`.\n\n        Parameters:\n          indent: String to indent all extra lines we print\n          inside_sum: Whether we are printing inside a [`SumErrorNode`][pane.errors.SumErrorNode] \n                      and so should omit printing the actual value we got)\n          file: File-like object to print text to\n        \"\"\"\n        ...\n\n    def __str__(self) -&gt; str:\n        buf = StringIO()\n        self.print_error(file=buf)\n        return buf.getvalue().rstrip('\\n')\n</code></pre>"},{"location":"api/errors/#pane.errors.ErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>  <code>abstractmethod</code>","text":"<p>Print a description of this error to <code>file</code>.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>str</code> <p>String to indent all extra lines we print</p> <code>''</code> <code>inside_sum</code> <code>bool</code> <p>Whether we are printing inside a <code>SumErrorNode</code>            and so should omit printing the actual value we got)</p> <code>False</code> <code>file</code> <code>TextIO</code> <p>File-like object to print text to</p> <code>stdout</code> Source code in <code>pane/errors.py</code> <pre><code>@abc.abstractmethod\ndef print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    \"\"\"\n    Print a description of this error to `file`.\n\n    Parameters:\n      indent: String to indent all extra lines we print\n      inside_sum: Whether we are printing inside a [`SumErrorNode`][pane.errors.SumErrorNode] \n                  and so should omit printing the actual value we got)\n      file: File-like object to print text to\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongTypeError","title":"<code>WrongTypeError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass WrongTypeError(ErrorNode):\n    expected: str\n    \"\"\"Short description of expected value type\"\"\"\n    actual: t.Any\n    \"\"\"Actual value received\"\"\"\n    cause: t.Optional[traceback.TracebackException] = None\n    \"\"\"If this was caused by an error, contains a traceback to that error\"\"\"\n    info: t.Optional[str] = None\n    \"\"\"Additional information to supply on an new line\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        if inside_sum:\n            print(f\"{self.expected}\", file=file)\n        else:\n            print(f\"Expected {self.expected}, instead got `{self.actual}` of type `{type(self.actual).__name__}`\", file=file)\n        if self.info is not None:\n            print(f\"{indent}{self.info}\", file=file)\n        if self.cause is not None:\n            s = f\"{indent}\\n\".join(self.cause.format())\n            print(f\"Caused by exception:\\n{indent}{s}\", file=file)\n\n    def _get_cause(self) -&gt; str:\n        \"\"\"Format `cause` as a human-readable string\"\"\"\n        if self.cause is None:\n            return 'None'\n        if isinstance(self.cause, traceback.TracebackException):\n            return \"\\n\".join(self.cause.format_exception_only())\n        return \"\\n\".join(traceback.format_exception(type(self.cause), self.cause, None))\n\n    def __repr__(self) -&gt; str:\n        return f\"WrongTypeError(expected={self.expected!r}, actual={self.actual!r}, cause={self._get_cause()!r}, info={self.info!r})\"\n\n    def __eq__(self, other: t.Any) -&gt; bool:\n        # mostly useful for testing\n        if not self.__class__ == other.__class__:\n            return False\n\n        return (\n            self.expected == other.expected and\n            self.actual == other.actual and\n            self.info == other.info and\n            self._get_cause() == other._get_cause()\n        )\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongTypeError.expected","title":"<code>expected</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.actual","title":"<code>actual</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.cause","title":"<code>cause = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If this was caused by an error, contains a traceback to that error</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.info","title":"<code>info = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional information to supply on an new line</p>"},{"location":"api/errors/#pane.errors.WrongTypeError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    if inside_sum:\n        print(f\"{self.expected}\", file=file)\n    else:\n        print(f\"Expected {self.expected}, instead got `{self.actual}` of type `{type(self.actual).__name__}`\", file=file)\n    if self.info is not None:\n        print(f\"{indent}{self.info}\", file=file)\n    if self.cause is not None:\n        s = f\"{indent}\\n\".join(self.cause.format())\n        print(f\"Caused by exception:\\n{indent}{s}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongLenError","title":"<code>WrongLenError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass WrongLenError(ErrorNode):\n    expected: str\n    \"\"\"Short description of expected value type\"\"\"\n    expected_len: t.Tuple[int, int]\n    \"\"\"(min, max) expected value length\"\"\"\n    actual: t.Any\n    \"\"\"Actual value received\"\"\"\n    actual_len: int\n    \"\"\"Actual length received\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        len_range = '-'.join(map(str, self.expected_len))\n        if inside_sum:\n            print(f\"{self.expected} (length {len_range})\", file=file)\n        else:\n            print(f\"Expected {self.expected} of length {len_range}, instead got `{self.actual}` of length {self.actual_len}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.WrongLenError.expected","title":"<code>expected</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.WrongLenError.expected_len","title":"<code>expected_len</code>  <code>instance-attribute</code>","text":"<p>(min, max) expected value length</p>"},{"location":"api/errors/#pane.errors.WrongLenError.actual","title":"<code>actual</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.WrongLenError.actual_len","title":"<code>actual_len</code>  <code>instance-attribute</code>","text":"<p>Actual length received</p>"},{"location":"api/errors/#pane.errors.WrongLenError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    len_range = '-'.join(map(str, self.expected_len))\n    if inside_sum:\n        print(f\"{self.expected} (length {len_range})\", file=file)\n    else:\n        print(f\"Expected {self.expected} of length {len_range}, instead got `{self.actual}` of length {self.actual_len}\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConditionFailedError","title":"<code>ConditionFailedError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass ConditionFailedError(ErrorNode):\n    expected: str\n    \"\"\"Short description of expected value type\"\"\"\n    actual: t.Any\n    \"\"\"Actual value received\"\"\"\n    condition: str\n    \"\"\"Name of condition which failed\"\"\"\n    cause: t.Optional[traceback.TracebackException] = None\n    \"\"\"If this was caused by an error, contains a traceback to that error\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        if inside_sum:\n            print(self.expected, end=\"\", file=file)\n        else:\n            print(f\"Expected {self.expected}, instead got `{self.actual}`\", end=\"\", file=file)\n        if self.cause is not None:\n            s = f\"{indent}\\n\".join(self.cause.format())\n            print(f\"\\nFailed to call condition '{self.condition}':\\n{indent}{s}\", file=file)\n        else:\n            print(f\" (failed condition '{self.condition}')\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ConditionFailedError.expected","title":"<code>expected</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.actual","title":"<code>actual</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.condition","title":"<code>condition</code>  <code>instance-attribute</code>","text":"<p>Name of condition which failed</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.cause","title":"<code>cause = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If this was caused by an error, contains a traceback to that error</p>"},{"location":"api/errors/#pane.errors.ConditionFailedError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    if inside_sum:\n        print(self.expected, end=\"\", file=file)\n    else:\n        print(f\"Expected {self.expected}, instead got `{self.actual}`\", end=\"\", file=file)\n    if self.cause is not None:\n        s = f\"{indent}\\n\".join(self.cause.format())\n        print(f\"\\nFailed to call condition '{self.condition}':\\n{indent}{s}\", file=file)\n    else:\n        print(f\" (failed condition '{self.condition}')\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.DuplicateKeyError","title":"<code>DuplicateKeyError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass DuplicateKeyError(ErrorNode):\n    key: str\n    \"\"\"Offending key\"\"\"\n    aliases: t.Sequence[str]\n    \"\"\"List of keys semantically identical to `key`\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        assert not inside_sum\n        print(f\"Duplicate key {self.key} (same as {'/'.join(self.aliases)})\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.key","title":"<code>key</code>  <code>instance-attribute</code>","text":"<p>Offending key</p>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.aliases","title":"<code>aliases</code>  <code>instance-attribute</code>","text":"<p>List of keys semantically identical to <code>key</code></p>"},{"location":"api/errors/#pane.errors.DuplicateKeyError.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    assert not inside_sum\n    print(f\"Duplicate key {self.key} (same as {'/'.join(self.aliases)})\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ProductErrorNode","title":"<code>ProductErrorNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass ProductErrorNode(ErrorNode):\n    expected: str\n    \"\"\"Short description of expected value type\"\"\"\n    children: t.Dict[t.Union[int, str], ErrorNode]\n    \"\"\"Map containing errors parsing subfields, if any\"\"\"\n    actual: t.Any\n    \"\"\"Actual value received\"\"\"\n    missing: t.AbstractSet[t.Union[t.Sequence[str], str]] = dataclasses.field(default_factory=set[t.Union[t.Sequence[str], str]])\n    \"\"\"List of missing fields/equivalent aliases to fields\"\"\"\n    extra: t.AbstractSet[str] = dataclasses.field(default_factory=set[str])\n    \"\"\"List of extra, unexpected fields\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        # fuse together non-branching productnodes\n        while len(self.children) == 1 and not len(self.missing) and not len(self.extra):\n            field, child = next(iter(self.children.items()))\n            if not isinstance(child, ProductErrorNode):\n                break\n            children: t.Dict[t.Union[str, int], ErrorNode] = {f\"{field}.{k}\": v for (k, v) in child.children.items()}\n            missing = set(f\"{field}.{f}\" for f in child.missing)\n            extra = set(f\"{field}.{f}\" for f in child.extra)\n            self = ProductErrorNode(self.expected, children, self.actual, missing, extra)\n\n        print(f\"{'' if inside_sum else 'Expected '}{self.expected}\", file=file)\n        for (field, child) in self.children.items():\n            print(f\"{indent}While parsing field '{field}':\\n{indent}  \", end=\"\", file=file)\n            child.print_error(f\"{indent}  \", file=file)\n\n        for field in self.missing:\n            if not isinstance(field, str):\n                field = '/'.join(field)\n            print(f\"{indent}  Missing required field '{field}'\", file=file)\n\n        for field in self.extra:\n            print(f\"{indent}  Unexpected field '{field}'\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.ProductErrorNode.expected","title":"<code>expected</code>  <code>instance-attribute</code>","text":"<p>Short description of expected value type</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.children","title":"<code>children</code>  <code>instance-attribute</code>","text":"<p>Map containing errors parsing subfields, if any</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.actual","title":"<code>actual</code>  <code>instance-attribute</code>","text":"<p>Actual value received</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.missing","title":"<code>missing = dataclasses.field(default_factory=set[t.Union[t.Sequence[str], str]])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of missing fields/equivalent aliases to fields</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.extra","title":"<code>extra = dataclasses.field(default_factory=set[str])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of extra, unexpected fields</p>"},{"location":"api/errors/#pane.errors.ProductErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    # fuse together non-branching productnodes\n    while len(self.children) == 1 and not len(self.missing) and not len(self.extra):\n        field, child = next(iter(self.children.items()))\n        if not isinstance(child, ProductErrorNode):\n            break\n        children: t.Dict[t.Union[str, int], ErrorNode] = {f\"{field}.{k}\": v for (k, v) in child.children.items()}\n        missing = set(f\"{field}.{f}\" for f in child.missing)\n        extra = set(f\"{field}.{f}\" for f in child.extra)\n        self = ProductErrorNode(self.expected, children, self.actual, missing, extra)\n\n    print(f\"{'' if inside_sum else 'Expected '}{self.expected}\", file=file)\n    for (field, child) in self.children.items():\n        print(f\"{indent}While parsing field '{field}':\\n{indent}  \", end=\"\", file=file)\n        child.print_error(f\"{indent}  \", file=file)\n\n    for field in self.missing:\n        if not isinstance(field, str):\n            field = '/'.join(field)\n        print(f\"{indent}  Missing required field '{field}'\", file=file)\n\n    for field in self.extra:\n        print(f\"{indent}  Unexpected field '{field}'\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.SumErrorNode","title":"<code>SumErrorNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ErrorNode</code></p> Source code in <code>pane/errors.py</code> <pre><code>@dataclasses.dataclass\nclass SumErrorNode(ErrorNode):\n    children: t.List[ErrorNode]\n    \"\"\"Map containing the errors while parsing as each variant\"\"\"\n\n    def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n        def _flatten_sum(children: t.Iterable[ErrorNode]) -&gt; t.Iterator[ErrorNode]:\n            for child in children:\n                if isinstance(child, SumErrorNode):\n                    yield from child.children\n                else:\n                    yield child\n\n        print(\"Expected one of:\", file=file)\n        actual = None\n        for child in _flatten_sum(self.children):\n            print(f\"{indent}- \", end=\"\", file=file)\n            child.print_error(f\"{indent}  \", inside_sum=True, file=file)\n            actual = getattr(child, 'actual', actual)\n        print(f\"{indent}Instead got `{actual}` of type `{type(actual).__name__}`\", file=file)\n</code></pre>"},{"location":"api/errors/#pane.errors.SumErrorNode.children","title":"<code>children</code>  <code>instance-attribute</code>","text":"<p>Map containing the errors while parsing as each variant</p>"},{"location":"api/errors/#pane.errors.SumErrorNode.print_error","title":"<code>print_error(indent='', inside_sum=False, file=sys.stdout)</code>","text":"Source code in <code>pane/errors.py</code> <pre><code>def print_error(self, indent: str = \"\", inside_sum: bool = False, file: t.TextIO = sys.stdout):\n    def _flatten_sum(children: t.Iterable[ErrorNode]) -&gt; t.Iterator[ErrorNode]:\n        for child in children:\n            if isinstance(child, SumErrorNode):\n                yield from child.children\n            else:\n                yield child\n\n    print(\"Expected one of:\", file=file)\n    actual = None\n    for child in _flatten_sum(self.children):\n        print(f\"{indent}- \", end=\"\", file=file)\n        child.print_error(f\"{indent}  \", inside_sum=True, file=file)\n        actual = getattr(child, 'actual', actual)\n    print(f\"{indent}Instead got `{actual}` of type `{type(actual).__name__}`\", file=file)\n</code></pre>"},{"location":"api/field/","title":"pane.field","text":""},{"location":"api/field/#pane.field","title":"<code>pane.field</code>","text":""},{"location":"api/field/#pane.field.RenameStyle","title":"<code>RenameStyle = t.Literal['snake', 'camel', 'pascal', 'kebab', 'scream']</code>  <code>module-attribute</code>","text":"<p>List of supported field-renaming styles</p>"},{"location":"api/field/#pane.field.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Represents a materialized dataclass field.</p> <p>Typically instantiated from a <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass Field:\n    \"\"\"\n    Represents a materialized dataclass field.\n\n    Typically instantiated from a [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n\n    _: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\n    name: str\n    \"\"\"Name of field\"\"\"\n    type: t.Any\n    \"\"\"Type of field. Must be [`Convertible`][pane.convert.Convertible].\"\"\"\n    in_names: t.Sequence[str]\n    \"\"\"List of names which convert to this field.\"\"\"\n    out_name: str\n    \"\"\"Name this field converts into.\"\"\"\n    init: bool = True\n    \"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\n    default: t.Union[t.Any, _Missing] = _MISSING\n    \"\"\"Default value for field\"\"\"\n    default_factory: t.Optional[t.Callable[[], t.Any]] = None\n    \"\"\"Default value factory for field\"\"\"\n    kw_only: bool = False\n    \"\"\"Whether field is keyword only\"\"\"\n    converter: t.Optional[Converter[t.Any]] = None\n    \"\"\"Custom converter to use for this field.\"\"\"\n\n    @classmethod\n    def make(cls, name: str, ty: type,\n             in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n             out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n        in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n        out_name = rename_field(name, out_rename) if out_rename is not None else name\n        return cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n\n    def has_default(self) -&gt; bool:\n        \"\"\"Return whether this field has a default value\"\"\"\n        return self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/field/#pane.field.Field.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Name of field</p>"},{"location":"api/field/#pane.field.Field.type","title":"<code>type</code>  <code>instance-attribute</code>","text":"<p>Type of field. Must be <code>Convertible</code>.</p>"},{"location":"api/field/#pane.field.Field.in_names","title":"<code>in_names</code>  <code>instance-attribute</code>","text":"<p>List of names which convert to this field.</p>"},{"location":"api/field/#pane.field.Field.out_name","title":"<code>out_name</code>  <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/field/#pane.field.Field.init","title":"<code>init = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/field/#pane.field.Field.default","title":"<code>default = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/field/#pane.field.Field.default_factory","title":"<code>default_factory = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/field/#pane.field.Field.kw_only","title":"<code>kw_only = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/field/#pane.field.Field.converter","title":"<code>converter = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom converter to use for this field.</p>"},{"location":"api/field/#pane.field.Field.make","title":"<code>make(name, ty, in_rename=None, out_rename=None)</code>  <code>classmethod</code>","text":"Source code in <code>pane/field.py</code> <pre><code>@classmethod\ndef make(cls, name: str, ty: type,\n         in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n         out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n    in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n    out_name = rename_field(name, out_rename) if out_rename is not None else name\n    return cls(name=name, type=ty, in_names=in_names, out_name=out_name)\n</code></pre>"},{"location":"api/field/#pane.field.Field.has_default","title":"<code>has_default()</code>","text":"<p>Return whether this field has a default value</p> Source code in <code>pane/field.py</code> <pre><code>def has_default(self) -&gt; bool:\n    \"\"\"Return whether this field has a default value\"\"\"\n    return self.default is not _MISSING or self.default_factory is not None\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec","title":"<code>FieldSpec</code>  <code>dataclass</code>","text":"<p>Represents a field specification.</p> <p>This hasn't been applied to a class yet, so some information is missing.</p> <p>In most cases, end users should use the <code>field()</code> function instead.</p> Source code in <code>pane/field.py</code> <pre><code>@dataclasses.dataclass\nclass FieldSpec:\n    \"\"\"\n    Represents a field specification.\n\n    This hasn't been applied to a class yet, so some information is missing.\n\n    In most cases, end users should use the [`field()`][pane.field.field] function instead.\n    \"\"\"\n\n    _: KW_ONLY = dataclasses.field(init=False, repr=False, compare=False)\n    rename: t.Optional[str] = None\n    \"\"\"Rename this field. Affects both `in_names` and `out_name`.\"\"\"\n    in_names: t.Optional[t.Sequence[str]] = None\n    \"\"\"Complete list of names which convert to this field.\"\"\"\n    aliases: t.Optional[t.Sequence[str]] = None\n    \"\"\"Additional list of names which convert to this field (excluding the name in Python).\"\"\"\n    out_name: t.Optional[str] = None\n    \"\"\"Name this field converts into.\"\"\"\n    init: bool = True\n    \"\"\"Whether to add this field to __init__ methods (and conversion)\"\"\"\n    default: t.Union[t.Any, _Missing] = _MISSING\n    \"\"\"Default value for field\"\"\"\n    default_factory: t.Optional[t.Callable[[], t.Any]] = None\n    \"\"\"Default value factory for field\"\"\"\n    kw_only: bool = False\n    \"\"\"Whether field is keyword only\"\"\"\n    ty: t.Union[t.Any, _Missing] = _MISSING\n    \"\"\"Type of field, if known. Must be Convertible.\"\"\"\n    converter: t.Optional[Converter[t.Any]] = None\n    \"\"\"Custom converter to use for this field.\"\"\"\n\n    def __post_init__(self):\n        if isinstance(self.aliases, str):\n            self.aliases = [self.aliases]\n\n    def replace_typevars(self, replacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], t.Type[t.Any]]) -&gt; Self:\n        \"\"\"\n        Apply type variable replacements to `self`.\n        \"\"\"\n        if self.ty is _MISSING:\n            return dataclasses.replace(self)\n        return dataclasses.replace(self, ty=replace_typevars(t.cast(type, self.ty), replacements))\n\n    def make_field(self, name: str,\n                   in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n                   out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n        \"\"\"\n        Make a [`Field`][pane.field.Field] from this [`FieldSpec`][pane.field.FieldSpec].\n        \"\"\"\n        # out_name\n        if self.out_name is not None:\n            out_name = self.out_name\n        elif self.rename is not None:\n            out_name = self.rename\n        else:\n            out_name = rename_field(name, out_rename) if out_rename is not None else name\n\n        if sum(p is not None for p in (self.rename, self.aliases, self.in_names)) &gt; 1:\n            raise TypeError(\"Can only specify one of 'rename', 'aliases', and 'in_names'\")\n\n        if self.rename is not None:\n            in_names = (self.rename,)\n        elif self.aliases is not None:\n            in_names = (name, *(alias for alias in self.aliases if alias != name))\n        elif self.in_names is not None:\n            in_names = self.in_names\n        else:\n            in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n\n        ty = t.cast(type, t.Any if self.ty is _MISSING else self.ty)\n        return Field(name=name, type=ty, out_name=out_name, in_names=in_names,\n                     init=self.init, default=self.default, default_factory=self.default_factory,\n                     kw_only=self.kw_only, converter=self.converter)\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec.rename","title":"<code>rename = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rename this field. Affects both <code>in_names</code> and <code>out_name</code>.</p>"},{"location":"api/field/#pane.field.FieldSpec.in_names","title":"<code>in_names = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Complete list of names which convert to this field.</p>"},{"location":"api/field/#pane.field.FieldSpec.aliases","title":"<code>aliases = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional list of names which convert to this field (excluding the name in Python).</p>"},{"location":"api/field/#pane.field.FieldSpec.out_name","title":"<code>out_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name this field converts into.</p>"},{"location":"api/field/#pane.field.FieldSpec.init","title":"<code>init = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add this field to init methods (and conversion)</p>"},{"location":"api/field/#pane.field.FieldSpec.default","title":"<code>default = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value for field</p>"},{"location":"api/field/#pane.field.FieldSpec.default_factory","title":"<code>default_factory = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default value factory for field</p>"},{"location":"api/field/#pane.field.FieldSpec.kw_only","title":"<code>kw_only = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether field is keyword only</p>"},{"location":"api/field/#pane.field.FieldSpec.ty","title":"<code>ty = _MISSING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of field, if known. Must be Convertible.</p>"},{"location":"api/field/#pane.field.FieldSpec.converter","title":"<code>converter = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom converter to use for this field.</p>"},{"location":"api/field/#pane.field.FieldSpec.replace_typevars","title":"<code>replace_typevars(replacements)</code>","text":"<p>Apply type variable replacements to <code>self</code>.</p> Source code in <code>pane/field.py</code> <pre><code>def replace_typevars(self, replacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], t.Type[t.Any]]) -&gt; Self:\n    \"\"\"\n    Apply type variable replacements to `self`.\n    \"\"\"\n    if self.ty is _MISSING:\n        return dataclasses.replace(self)\n    return dataclasses.replace(self, ty=replace_typevars(t.cast(type, self.ty), replacements))\n</code></pre>"},{"location":"api/field/#pane.field.FieldSpec.make_field","title":"<code>make_field(name, in_rename=None, out_rename=None)</code>","text":"<p>Make a <code>Field</code> from this <code>FieldSpec</code>.</p> Source code in <code>pane/field.py</code> <pre><code>def make_field(self, name: str,\n               in_rename: t.Optional[t.Sequence[RenameStyle]] = None,\n               out_rename: t.Optional[RenameStyle] = None) -&gt; Field:\n    \"\"\"\n    Make a [`Field`][pane.field.Field] from this [`FieldSpec`][pane.field.FieldSpec].\n    \"\"\"\n    # out_name\n    if self.out_name is not None:\n        out_name = self.out_name\n    elif self.rename is not None:\n        out_name = self.rename\n    else:\n        out_name = rename_field(name, out_rename) if out_rename is not None else name\n\n    if sum(p is not None for p in (self.rename, self.aliases, self.in_names)) &gt; 1:\n        raise TypeError(\"Can only specify one of 'rename', 'aliases', and 'in_names'\")\n\n    if self.rename is not None:\n        in_names = (self.rename,)\n    elif self.aliases is not None:\n        in_names = (name, *(alias for alias in self.aliases if alias != name))\n    elif self.in_names is not None:\n        in_names = self.in_names\n    else:\n        in_names = tuple(rename_field(name, style) for style in in_rename) if in_rename is not None else (name,)\n\n    ty = t.cast(type, t.Any if self.ty is _MISSING else self.ty)\n    return Field(name=name, type=ty, out_name=out_name, in_names=in_names,\n                 init=self.init, default=self.default, default_factory=self.default_factory,\n                 kw_only=self.kw_only, converter=self.converter)\n</code></pre>"},{"location":"api/field/#pane.field.rename_field","title":"<code>rename_field(field, style=None)</code>","text":"<p>Rename <code>field</code> to match style <code>style</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Field name to rename</p> required <code>style</code> <code>Optional[RenameStyle]</code> <p>Style to match</p> <code>None</code> Source code in <code>pane/field.py</code> <pre><code>def rename_field(field: str, style: t.Optional[RenameStyle] = None) -&gt; str:\n    \"\"\"\n    Rename `field` to match style `style`.\n\n    Parameters:\n        field: Field name to rename\n        style: Style to match\n    \"\"\"\n    if style is None:\n        return field\n\n    return _CONVERT_FNS[style](_split_field_name(field))\n</code></pre>"},{"location":"api/field/#pane.field.field","title":"<code>field(*, rename=None, in_names=None, aliases=None, out_name=None, init=True, default=_MISSING, default_factory=None, kw_only=False, converter=None)</code>","text":"<pre><code>field(*, rename: t.Optional[str] = None, in_names: None = None, aliases: None = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: None = None, in_names: t.Sequence[str], aliases: None = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: None = None, in_names: None = None, aliases: t.Sequence[str], out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre><pre><code>field(*, rename: t.Optional[str] = None, in_names: t.Optional[t.Sequence[str]] = None, aliases: t.Optional[t.Sequence[str]] = None, out_name: t.Optional[str] = None, init: bool = True, default: t.Union[T, _Missing] = _MISSING, default_factory: t.Optional[t.Callable[[], T]] = None, kw_only: bool = False, converter: t.Optional[Converter[T]] = None) -&gt; t.Any\n</code></pre> <p>Annotate a dataclass field.</p> <p>Parameters:</p> Name Type Description Default <code>rename</code> <code>Optional[str]</code> <p>Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.</p> <code>None</code> <code>in_names</code> <code>Optional[Sequence[str]]</code> <p>List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike <code>aliases</code>).</p> <code>None</code> <code>aliases</code> <code>Optional[Sequence[str]]</code> <p>List of aliases (additional names) for this field. Includes the field name inside Python (unlike <code>in_names</code>).</p> <code>None</code> <code>out_name</code> <code>Optional[str]</code> <p>Name which this field should convert into.</p> <code>None</code> <code>init</code> <code>bool</code> <p>If <code>False</code>, this field won't be touched by <code>pane</code>, and it's up to the class to initialize it in <code>__post_init__</code>.</p> <code>True</code> <code>default</code> <code>Union[T, _Missing]</code> <p>Default value for field</p> <code>_MISSING</code> <code>default_factory</code> <code>Optional[Callable[[], T]]</code> <p>Default value factory for field</p> <code>None</code> <code>kw_only</code> <code>bool</code> <p>Whether the field is keyword-only.</p> <code>False</code> Source code in <code>pane/field.py</code> <pre><code>def field(*,\n    rename: t.Optional[str] = None,\n    in_names: t.Optional[t.Sequence[str]] = None,\n    aliases: t.Optional[t.Sequence[str]] = None,\n    out_name: t.Optional[str] = None,\n    init: bool = True,\n    default: t.Union[T, _Missing] = _MISSING,\n    default_factory: t.Optional[t.Callable[[], T]] = None,\n    kw_only: bool = False,\n    converter: t.Optional[Converter[T]] = None,\n) -&gt; t.Any:\n    \"\"\"\n    Annotate a dataclass field.\n\n    Parameters:\n      rename: Name to rename this field as. Used for both input and output. Useful when a field name should be different inside vs. outside of Python.\n      in_names: List of names which should convert into this field. If specified, the field name inside Python will be excluded (unlike `aliases`).\n      aliases: List of aliases (additional names) for this field. Includes the field name inside Python (unlike `in_names`).\n      out_name: Name which this field should convert into.\n      init: If `False`, this field won't be touched by `pane`, and it's up to the class to initialize it in `__post_init__`.\n      default: Default value for field\n      default_factory: Default value factory for field\n      kw_only: Whether the field is keyword-only.\n    \"\"\"\n    return FieldSpec(\n        rename=rename, in_names=in_names, aliases=aliases, out_name=out_name,\n        init=init, default=default, default_factory=default_factory, kw_only=kw_only,\n        converter=converter\n    )\n</code></pre>"},{"location":"api/io/","title":"pane.io","text":""},{"location":"api/io/#pane.io","title":"<code>pane.io</code>","text":""},{"location":"api/io/#pane.io.FileOrPath","title":"<code>FileOrPath = t.Union[str, Path, TextIOBase, t.TextIO]</code>  <code>module-attribute</code>","text":""},{"location":"api/io/#pane.io.from_json","title":"<code>from_json(f, ty, *, custom=None)</code>","text":"<p>Load an object of type <code>ty</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/io.py</code> <pre><code>def from_json(f: FileOrPath, ty: t.Type[T], *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; T:\n    \"\"\"\n    Load an object of type `ty` from a JSON file `f`\n\n    Parameters:\n        f: File-like or path-like to load from\n        custom: Custom converters to use\n    \"\"\"\n    import json\n    with open_file(f) as f:\n        obj = json.load(f)\n    return from_data(obj, ty, custom=custom)\n</code></pre>"},{"location":"api/io/#pane.io.from_yaml","title":"<code>from_yaml(f, ty, *, custom=None)</code>","text":"<p>Load an object of type <code>ty</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/io.py</code> <pre><code>def from_yaml(f: FileOrPath, ty: t.Type[T], *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; T:\n    \"\"\"\n    Load an object of type `ty` from a YAML file `f`\n\n    Parameters:\n        f: File-like or path-like to load from\n        custom: Custom converters to use\n    \"\"\"\n    import yaml\n    try:\n        from yaml import CSafeLoader as Loader\n    except ImportError:\n        from yaml import SafeLoader as Loader\n\n    with open_file(f) as f:\n        obj = t.cast(t.Any, yaml.load(f, Loader))  # type: ignore\n\n    return from_data(obj, ty, custom=custom)\n</code></pre>"},{"location":"api/io/#pane.io.from_yaml_all","title":"<code>from_yaml_all(f, ty, *, custom=None)</code>","text":"<p>Load an object of type <code>ty</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/io.py</code> <pre><code>def from_yaml_all(f: FileOrPath, ty: t.Type[T], *,\n                  custom: t.Optional[IntoConverterHandlers] = None) -&gt; t.List[T]:\n    \"\"\"\n    Load an object of type `ty` from a YAML file `f`\n\n    Parameters:\n        f: File-like or path-like to load from\n        custom: Custom converters to use\n    \"\"\"\n    import yaml\n    try:\n        from yaml import CSafeLoader as Loader\n    except ImportError:\n        from yaml import SafeLoader as Loader\n\n    with open_file(f) as f:\n        obj = t.cast(t.List[t.Any], list(yaml.load_all(f, Loader)))  # type: ignore\n\n    return from_data(obj, t.List[ty], custom=custom)\n</code></pre>"},{"location":"api/io/#pane.io.write_json","title":"<code>write_json(obj, f, *, ty=None, indent=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to write</p> required <code>ty</code> <code>Optional[IntoConverter]</code> <p>Type of object</p> <code>None</code> <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Union[str, int, None]</code> <p>Indent to format JSON with. Defaults to None (no indentation)</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/io.py</code> <pre><code>def write_json(obj: Convertible, f: FileOrPath, *,\n               ty: t.Optional[IntoConverter] = None,\n               indent: t.Union[str, int, None] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a JSON file `f`\n\n    Parameters:\n      obj: Object to write\n      ty: Type of object\n      f: File-like or path-like to write to\n      indent: Indent to format JSON with. Defaults to None (no indentation)\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    import json\n\n    with open_file(f, 'w') as f:\n        json.dump(\n            into_data(obj, ty, custom=custom),\n            f, indent=indent, sort_keys=sort_keys\n        )\n</code></pre>"},{"location":"api/io/#pane.io.write_yaml","title":"<code>write_yaml(obj, f, *, ty=None, indent=None, width=None, allow_unicode=True, explicit_start=True, explicit_end=False, default_style=None, default_flow_style=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to write</p> required <code>ty</code> <code>Optional[IntoConverter]</code> <p>Type of object</p> <code>None</code> <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Optional[int]</code> <p>Number of spaces to indent blocks with</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>Maximum width of file created</p> <code>None</code> <code>allow_unicode</code> <code>bool</code> <p>Whether to output unicode characters or escape them</p> <code>True</code> <code>explicit_start</code> <code>bool</code> <p>Whether to include a YAML document start \"---\"</p> <code>True</code> <code>explicit_end</code> <code>bool</code> <p>Whether to include a YAML document end \"...\"</p> <code>False</code> <code>default_style</code> <code>Optional[Literal['\"', '|', '&gt;']]</code> <p>Default style to use for scalar nodes.   See YAML documentation for more information.</p> <code>None</code> <code>default_flow_style</code> <code>Optional[bool]</code> <p>Whether to default to flow style or block style for collections.   See YAML documentation for more information.</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/io.py</code> <pre><code>def write_yaml(obj: Convertible, f: FileOrPath, *,\n               ty: t.Optional[IntoConverter] = None,\n               indent: t.Optional[int] = None,\n               width: t.Optional[int] = None,\n               allow_unicode: bool = True,\n               explicit_start: bool = True, explicit_end: bool = False,\n               default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n               default_flow_style: t.Optional[bool] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a YAML file `f`\n\n    Parameters:\n      obj: Object to write\n      ty: Type of object\n      f: File-like or path-like to write to\n      indent: Number of spaces to indent blocks with\n      width: Maximum width of file created\n      allow_unicode: Whether to output unicode characters or escape them\n      explicit_start: Whether to include a YAML document start \"---\"\n      explicit_end: Whether to include a YAML document end \"...\"\n      default_style: Default style to use for scalar nodes.\n          See YAML documentation for more information.\n      default_flow_style: Whether to default to flow style or block style for collections.\n          See YAML documentation for more information.\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    import yaml\n    try:\n        from yaml import CSafeDumper as Dumper\n    except ImportError:\n        from yaml import SafeDumper as Dumper\n\n    with open_file(f, 'w') as f:\n        yaml.dump(  # type: ignore\n            into_data(obj, ty, custom=custom), f, Dumper=Dumper,\n            indent=indent, width=width, allow_unicode=allow_unicode,\n            explicit_start=explicit_start, explicit_end=explicit_end,\n            default_style=default_style, default_flow_style=default_flow_style,\n            sort_keys=sort_keys\n        )\n</code></pre>"},{"location":"api/io/#pane.io.open_file","title":"<code>open_file(f, mode='r', newline=None, encoding='utf-8')</code>","text":"<p>Open the given file for text I/O.</p> <p>If given a path-like, opens it with the specified settings. Otherwise, make an effort to reconfigure the encoding, and check that it is readable/writable as specified.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File to open/reconfigure</p> required <code>mode</code> <code>Literal['r', 'w']</code> <p>Mode file should be opened in</p> <code>'r'</code> <code>newline</code> <code>Optional[str]</code> <p>Newline mode file should be opened in</p> <code>None</code> <code>encoding</code> <code>Optional[str]</code> <p>Encoding file should be opened in</p> <code>'utf-8'</code> Source code in <code>pane/io.py</code> <pre><code>def open_file(f: FileOrPath,\n              mode: t.Literal['r', 'w'] = 'r',\n              newline: t.Optional[str] = None,\n              encoding: t.Optional[str] = 'utf-8') -&gt; AbstractContextManager[TextIOBase]:\n    \"\"\"\n    Open the given file for text I/O.\n\n    If given a path-like, opens it with the specified settings.\n    Otherwise, make an effort to reconfigure the encoding, and\n    check that it is readable/writable as specified.\n\n    Parameters:\n      f: File to open/reconfigure\n      mode: Mode file should be opened in\n      newline: Newline mode file should be opened in\n      encoding: Encoding file should be opened in\n    \"\"\"\n    if not isinstance(f, (IOBase, t.BinaryIO, t.TextIO)):\n        return open(f, mode, newline=newline, encoding=encoding)\n\n    if isinstance(f, TextIOWrapper):\n        f.reconfigure(newline=newline, encoding=encoding)\n    elif isinstance(f, t.TextIO):\n        f = TextIOWrapper(f.buffer, newline=newline, encoding=encoding)\n    elif isinstance(f, (BufferedIOBase, t.BinaryIO)):\n        f = TextIOWrapper(t.cast(t.BinaryIO, f), newline=newline, encoding=encoding)\n\n    _validate_file(t.cast(TextIOBase, f), mode)\n    return nullcontext(t.cast(TextIOBase, f))  # don't close a f we didn't open\n</code></pre>"},{"location":"api/types/","title":"pane.types","text":""},{"location":"api/types/#pane.types","title":"<code>pane.types</code>","text":"<p>Helper types for use with <code>pane.convert</code> and dataclasses.</p>"},{"location":"api/types/#pane.types.Num","title":"<code>Num = t.TypeVar('Num', bound=t.Union[int, float])</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.PositiveInt","title":"<code>PositiveInt = t.Annotated[int, Positive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonNegativeInt","title":"<code>NonNegativeInt = t.Annotated[int, NonNegative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NegativeInt","title":"<code>NegativeInt = t.Annotated[int, Negative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonPositiveInt","title":"<code>NonPositiveInt = t.Annotated[int, NonPositive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.PositiveFloat","title":"<code>PositiveFloat = t.Annotated[float, Positive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonNegativeFloat","title":"<code>NonNegativeFloat = t.Annotated[float, NonNegative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NegativeFloat","title":"<code>NegativeFloat = t.Annotated[float, Negative]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.NonPositiveFloat","title":"<code>NonPositiveFloat = t.Annotated[float, NonPositive]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.FiniteFloat","title":"<code>FiniteFloat = t.Annotated[float, Finite]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.ListNotEmpty","title":"<code>ListNotEmpty = t.Annotated[t.List[T], len_range(min=1)]</code>  <code>module-attribute</code>","text":""},{"location":"api/types/#pane.types.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>PaneBase</code>, <code>Generic[Num]</code></p> Source code in <code>pane/types.py</code> <pre><code>class Range(PaneBase, t.Generic[Num],\n            in_format=('tuple', 'struct'),\n            out_format='struct'):\n    start: Num\n    end: Num\n\n    n: t.Optional[NonNegativeInt] = field(default=None)\n    step: t.Optional[Num] = field(default=None, kw_only=True)\n\n    def __post_init__(self):\n        s = sum((self.step is None, self.n is None))\n        if s == 0:\n            raise TypeError(\"Either 'n' or 'step' may be specified, but not both\")\n        if s == 2:\n            raise TypeError(\"Either 'n' or 'step' must be specified\")\n        span = self.end - self.start\n        if self.step is not None:\n            if math.isclose(self.step, 0.):\n                raise ValueError(\"'step' should be nonzero\")\n            n = 1 + math.ceil(span / self.step - 1e-6) if span &gt; 0 else 0\n            object.__setattr__(self, 'n', n)\n        else:\n            assert self.n is not None\n            if not isinstance(self.start, float) and span % (self.n - 1):\n                raise ValueError(\"Range must be evenly divisible by 'n'\")\n            step = type(self.start)(span / (self.n - 1)) if self.n &gt; 1 else None\n            object.__setattr__(self, 'step', step)\n\n    def __len__(self) -&gt; int:\n        return t.cast(int, self.n)\n\n    def __iter__(self) -&gt; t.Iterator[Num]:\n        assert self.n is not None\n        if self.n == 0:\n            return\n        val: Num = self.start\n        for _ in range(self.n - 1):\n            yield val\n            val = t.cast(Num, val + self.step)\n        yield self.end\n</code></pre>"},{"location":"api/types/#pane.types.Range.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.n","title":"<code>n = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range.step","title":"<code>step = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.Range._converter","title":"<code>_converter(*args, handlers)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[PaneBaseT], *args: t.Type[Convertible],\n               handlers: ConverterHandlers) -&gt; Converter[PaneBaseT]:\n    if len(args) &gt; 0:\n        cls = t.cast(t.Type[PaneBaseT], cls[tuple(args)])  # type: ignore\n    return PaneConverter(cls, handlers=handlers)\n</code></pre>"},{"location":"api/types/#pane.types.Range.make_unchecked","title":"<code>make_unchecked(*args, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef make_unchecked(cls, *args: t.Any, **kwargs: t.Any) -&gt; Self:\n    ...\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_dict_unchecked","title":"<code>from_dict_unchecked(d)</code>  <code>classmethod</code>","text":"Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_dict_unchecked(cls, d: t.Dict[str, t.Any]) -&gt; Self:\n    ...\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_obj","title":"<code>from_obj(obj, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Convert <code>obj</code> into <code>cls</code>. Equivalent to <code>convert(obj, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Convertible</code> <p>Object to convert. Must be convertible.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_obj(cls, obj: Convertible, *,\n             custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Convert `obj` into `cls`. Equivalent to `convert(obj, cls)`\n\n    Parameters:\n      obj: Object to convert. Must be convertible.\n    \"\"\"\n    return convert(obj, cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_data","title":"<code>from_data(data, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Convert <code>data</code> into <code>cls</code>. Equivalent to <code>from_data(data, cls)</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataType</code> <p>Data to convert. Must be a data interchange type.</p> required Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_data(cls, data: DataType, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Convert `data` into `cls`. Equivalent to `from_data(data, cls)`\n\n    Parameters:\n      data: Data to convert. Must be a data interchange type.\n    \"\"\"\n    return from_data(data, cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.into_data","title":"<code>into_data(*, custom=None)</code>","text":"<p>Convert <code>self</code> into interchange data</p> Source code in <code>pane/classes.py</code> <pre><code>def into_data(self, *, custom: t.Optional[IntoConverterHandlers] = None) -&gt; DataType:\n    \"\"\"Convert `self` into interchange data\"\"\"\n    return into_data(self, self.__class__, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.dict","title":"<code>dict(*, set_only=False, rename=None)</code>","text":"<p>Return a dict of the fields in <code>self</code></p> <p>Parameters:</p> Name Type Description Default <code>set_only</code> <code>bool</code> <p>If <code>True</code>, return only the fields which have been set</p> <code>False</code> <code>rename</code> <code>Optional[RenameStyle]</code> <p>Rename fields to match the given style</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def dict(self, *, set_only: bool = False, rename: t.Optional[RenameStyle] = None) -&gt; t.Dict[str, t.Any]:\n    \"\"\"\n    Return a dict of the fields in `self`\n\n    Parameters:\n      set_only: If `True`, return only the fields which have been set\n      rename: Rename fields to match the given style\n    \"\"\"\n    if set_only:\n        return {\n            rename_field(k, rename): getattr(self, k) for k in getattr(self, PANE_SET_FIELDS)\n        }\n    return {\n        rename_field(field.name, rename): getattr(self, field.name) for field in self.__pane_info__.fields\n    }\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_json","title":"<code>from_json(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_json(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a JSON file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_json(f, cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_yaml","title":"<code>from_yaml(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_yaml(f, cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_yaml_all","title":"<code>from_yaml_all(f, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load a list of <code>cls</code> from a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yaml_all(cls, f: io.FileOrPath, *,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; t.List[Self]:\n    \"\"\"\n    Load a list of `cls` from a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to load from\n      custom: Custom converters to use\n    \"\"\"\n    return io.from_yaml_all(f, cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_yamls","title":"<code>from_yamls(s, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a YAML string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>YAML string to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_yamls(cls, s: str, *,\n               custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a YAML string `s`\n\n    Parameters:\n      s: YAML string to load from\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n    return io.from_yaml(StringIO(s), cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.from_jsons","title":"<code>from_jsons(s, *, custom=None)</code>  <code>classmethod</code>","text":"<p>Load <code>cls</code> from a JSON string <code>s</code></p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string to load from</p> required <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>@classmethod\ndef from_jsons(cls, s: str, *,\n               custom: t.Optional[IntoConverterHandlers] = None) -&gt; Self:\n    \"\"\"\n    Load `cls` from a JSON string `s`\n\n    Parameters:\n      s: JSON string to load from\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n    return io.from_json(StringIO(s), cls, custom=custom)\n</code></pre>"},{"location":"api/types/#pane.types.Range.write_json","title":"<code>write_json(f, *, indent=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a JSON file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Union[str, int, None]</code> <p>Indent to format JSON with. Defaults to None (no indentation)</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def write_json(self, f: io.FileOrPath, *,\n               indent: t.Union[str, int, None] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a JSON file `f`\n\n    Parameters:\n      f: File-like or path-like to write to\n      indent: Indent to format JSON with. Defaults to None (no indentation)\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    io.write_json(\n        self, f, ty=self.__class__,\n        indent=indent, sort_keys=sort_keys, custom=custom\n    )\n</code></pre>"},{"location":"api/types/#pane.types.Range.write_yaml","title":"<code>write_yaml(f, *, indent=None, width=None, allow_unicode=True, explicit_start=True, explicit_end=False, default_style=None, default_flow_style=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a YAML file <code>f</code></p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>FileOrPath</code> <p>File-like or path-like to write to</p> required <code>indent</code> <code>Optional[int]</code> <p>Number of spaces to indent blocks with</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>Maximum width of file created</p> <code>None</code> <code>allow_unicode</code> <code>bool</code> <p>Whether to output unicode characters or escape them</p> <code>True</code> <code>explicit_start</code> <code>bool</code> <p>Whether to include a YAML document start \"---\"</p> <code>True</code> <code>explicit_end</code> <code>bool</code> <p>Whether to include a YAML document end \"...\"</p> <code>False</code> <code>default_style</code> <code>Optional[Literal['\"', '|', '&gt;']]</code> <p>Default style to use for scalar nodes.   See YAML documentation for more information.</p> <code>None</code> <code>default_flow_style</code> <code>Optional[bool]</code> <p>Whether to default to flow style or block style for collections.   See YAML documentation for more information.</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def write_yaml(self, f: io.FileOrPath, *,\n               indent: t.Optional[int] = None, width: t.Optional[int] = None,\n               allow_unicode: bool = True,\n               explicit_start: bool = True, explicit_end: bool = False,\n               default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n               default_flow_style: t.Optional[bool] = None,\n               sort_keys: bool = False,\n               custom: t.Optional[IntoConverterHandlers] = None):\n    \"\"\"\n    Write data to a YAML file `f`\n\n    Parameters:\n      f: File-like or path-like to write to\n      indent: Number of spaces to indent blocks with\n      width: Maximum width of file created\n      allow_unicode: Whether to output unicode characters or escape them\n      explicit_start: Whether to include a YAML document start \"---\"\n      explicit_end: Whether to include a YAML document end \"...\"\n      default_style: Default style to use for scalar nodes.\n          See YAML documentation for more information.\n      default_flow_style: Whether to default to flow style or block style for collections.\n          See YAML documentation for more information.\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    io.write_yaml(\n        self, f, ty=self.__class__,\n        indent=indent, width=width,\n        allow_unicode=allow_unicode,\n        explicit_start=explicit_start, explicit_end=explicit_end,\n        default_style=default_style, default_flow_style=default_flow_style,\n        sort_keys=sort_keys, custom=custom\n    )\n</code></pre>"},{"location":"api/types/#pane.types.Range.into_json","title":"<code>into_json(*, indent=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>Union[str, int, None]</code> <p>Indent to format JSON with. Defaults to None (no indentation)</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def into_json(self, *,\n              indent: t.Union[str, int, None] = None,\n              sort_keys: bool = False,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n    \"\"\"\n    Write data to a JSON string.\n\n    Parameters:\n      indent: Indent to format JSON with. Defaults to None (no indentation)\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n\n    buf = StringIO()\n    io.write_json(\n        self, buf, ty=self.__class__,\n        indent=indent, sort_keys=sort_keys, custom=custom\n    )\n    return buf.getvalue()\n</code></pre>"},{"location":"api/types/#pane.types.Range.into_yaml","title":"<code>into_yaml(*, indent=None, width=None, allow_unicode=True, explicit_start=True, explicit_end=False, default_style=None, default_flow_style=None, sort_keys=False, custom=None)</code>","text":"<p>Write data to a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>Optional[int]</code> <p>Number of spaces to indent blocks with</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>Maximum width of file created</p> <code>None</code> <code>allow_unicode</code> <code>bool</code> <p>Whether to output unicode characters or escape them</p> <code>True</code> <code>explicit_start</code> <code>bool</code> <p>Whether to include a YAML document start \"---\"</p> <code>True</code> <code>explicit_end</code> <code>bool</code> <p>Whether to include a YAML document end \"...\"</p> <code>False</code> <code>default_style</code> <code>Optional[Literal['\"', '|', '&gt;']]</code> <p>Default style to use for scalar nodes.   See YAML documentation for more information.</p> <code>None</code> <code>default_flow_style</code> <code>Optional[bool]</code> <p>Whether to default to flow style or block style for collections.   See YAML documentation for more information.</p> <code>None</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort keys prior to serialization.</p> <code>False</code> <code>custom</code> <code>Optional[IntoConverterHandlers]</code> <p>Custom converters to use</p> <code>None</code> Source code in <code>pane/classes.py</code> <pre><code>def into_yaml(self, *,\n              indent: t.Optional[int] = None, width: t.Optional[int] = None,\n              allow_unicode: bool = True,\n              explicit_start: bool = True, explicit_end: bool = False,\n              default_style: t.Optional[t.Literal['\"', '|', '&gt;']] = None,\n              default_flow_style: t.Optional[bool] = None,\n              sort_keys: bool = False,\n              custom: t.Optional[IntoConverterHandlers] = None) -&gt; str:\n    \"\"\"\n    Write data to a YAML string.\n\n    Parameters:\n      indent: Number of spaces to indent blocks with\n      width: Maximum width of file created\n      allow_unicode: Whether to output unicode characters or escape them\n      explicit_start: Whether to include a YAML document start \"---\"\n      explicit_end: Whether to include a YAML document end \"...\"\n      default_style: Default style to use for scalar nodes.\n          See YAML documentation for more information.\n      default_flow_style: Whether to default to flow style or block style for collections.\n          See YAML documentation for more information.\n      sort_keys: Whether to sort keys prior to serialization.\n      custom: Custom converters to use\n    \"\"\"\n    from io import StringIO\n\n    buf = StringIO()\n    io.write_yaml(\n        self, buf, ty=self.__class__,\n        indent=indent, width=width, allow_unicode=allow_unicode,\n        explicit_start=explicit_start, explicit_end=explicit_end,\n        default_style=default_style, default_flow_style=default_flow_style,\n        sort_keys=sort_keys, custom=custom\n    )\n    return buf.getvalue()\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList","title":"<code>ValueOrList</code>","text":"<p>               Bases: <code>Generic[T]</code></p> Source code in <code>pane/types.py</code> <pre><code>class ValueOrList(t.Generic[T]):\n    _inner: t.Union[T, t.List[T]]\n    _is_val: bool\n\n    def __init__(self, val: t.Union[T, t.List[T]], _is_val: bool):\n        self._inner = val\n        self._is_val = _is_val\n\n    @classmethod\n    def from_val(cls, val: T) -&gt; ValueOrList[T]:\n        return cls(val, True)\n\n    @classmethod\n    def from_list(cls, list_val: t.List[T]) -&gt; ValueOrList[T]:\n        return cls(list_val, False)\n\n    def __repr__(self) -&gt; str:\n        return f\"ValueOrList({self._inner!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self._inner)\n\n    def __eq__(self, other: t.Any) -&gt; bool:\n        if not self.__class__ == other.__class__:\n            return False\n        return self._is_val == other._is_val and self._inner == other._inner\n\n    @classmethod\n    def _converter(cls: t.Type[T], *args: t.Type[Convertible],\n                   handlers: ConverterHandlers) -&gt; ValueOrListConverter:\n        arg = t.cast(t.Type[Convertible], args[0] if len(args) &gt; 0 else t.Any)\n        return ValueOrListConverter(arg, handlers=handlers)\n\n    def __len__(self) -&gt; int:\n        return 1 if self._is_val else len(t.cast(t.List[T], self._inner))\n\n    def map(self, f: t.Callable[[T], U]) -&gt; ValueOrList[U]:\n        if self._is_val:\n            return ValueOrList(f(t.cast(T, self._inner)), True)\n        return ValueOrList(list(map(f, t.cast(t.List[T], self._inner))), False)\n\n    def __iter__(self) -&gt; t.Iterator[T]:\n        if self._is_val:\n            yield t.cast(T, self._inner)\n        else:\n            yield from t.cast(t.List[T], self._inner)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.from_val","title":"<code>from_val(val)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef from_val(cls, val: T) -&gt; ValueOrList[T]:\n    return cls(val, True)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.from_list","title":"<code>from_list(list_val)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef from_list(cls, list_val: t.List[T]) -&gt; ValueOrList[T]:\n    return cls(list_val, False)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList._converter","title":"<code>_converter(*args, handlers)</code>  <code>classmethod</code>","text":"Source code in <code>pane/types.py</code> <pre><code>@classmethod\ndef _converter(cls: t.Type[T], *args: t.Type[Convertible],\n               handlers: ConverterHandlers) -&gt; ValueOrListConverter:\n    arg = t.cast(t.Type[Convertible], args[0] if len(args) &gt; 0 else t.Any)\n    return ValueOrListConverter(arg, handlers=handlers)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrList.map","title":"<code>map(f)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def map(self, f: t.Callable[[T], U]) -&gt; ValueOrList[U]:\n    if self._is_val:\n        return ValueOrList(f(t.cast(T, self._inner)), True)\n    return ValueOrList(list(map(f, t.cast(t.List[T], self._inner))), False)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter","title":"<code>ValueOrListConverter</code>","text":"<p>               Bases: <code>UnionConverter</code></p> Source code in <code>pane/types.py</code> <pre><code>class ValueOrListConverter(UnionConverter):\n    def __init__(self, ty: t.Type[Convertible], handlers: ConverterHandlers):\n        types = t.cast(t.Sequence[t.Type[Convertible]], (ty, t.List[ty]))\n        super().__init__(types, constructor=lambda v, i: ValueOrList(v, i == 0), handlers=handlers)\n        self.ty = ty\n\n    def expected(self, plural: bool = False) -&gt; str:\n        inner = self.converters[0].expected(plural)\n        return f\"{inner} or sequence of {inner}\"\n\n    def into_data(self, val: t.Any) -&gt; DataType:\n        if not isinstance(val, ValueOrList):\n            return into_data(val)\n        return t.cast(ValueOrList[t.Any], val).map(\n            lambda v: into_data(v, self.ty)\n        )._inner\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.types","title":"<code>types = tuple(flatten_union_args(types))</code>  <code>instance-attribute</code>","text":"<p>List of potential types</p>"},{"location":"api/types/#pane.types.ValueOrListConverter.converters","title":"<code>converters = tuple(make_converter(ty, handlers) for ty in types)</code>  <code>instance-attribute</code>","text":"<p>List of type converters</p>"},{"location":"api/types/#pane.types.ValueOrListConverter.constructor","title":"<code>constructor = constructor</code>  <code>instance-attribute</code>","text":"<p>Constructor to call with parsed value. Called with <code>(val, index of type in union)</code></p>"},{"location":"api/types/#pane.types.ValueOrListConverter.ty","title":"<code>ty = ty</code>  <code>instance-attribute</code>","text":""},{"location":"api/types/#pane.types.ValueOrListConverter.convert","title":"<code>convert(val)</code>","text":"<p>Convert <code>val</code> to <code>T_co</code>. Raises a <code>ConvertError</code> on failure.</p> Source code in <code>pane/converters.py</code> <pre><code>def convert(self, val: t.Any) -&gt; T_co:\n    \"\"\"Convert ``val`` to ``T_co``. Raises a ``ConvertError`` on failure.\"\"\"\n    try:\n        return self.try_convert(val)\n    except ParseInterrupt:\n        pass\n    node = self.collect_errors(val)\n    if node is None:\n        raise RuntimeError(\"convert() raised but ``collect_errors`` returned ``None``.\"\n                           \" This is a bug of the ``Converter`` implementation.\")\n    raise ConvertError(node)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.try_convert","title":"<code>try_convert(val)</code>","text":"<p>See <code>Converter.try_convert</code></p> Source code in <code>pane/converters.py</code> <pre><code>def try_convert(self, val: t.Any) -&gt; t.Any:\n    \"\"\"See [`Converter.try_convert`][pane.converters.Converter.try_convert]\"\"\"\n    for (i, conv) in enumerate(self.converters):\n        try:\n            val = conv.try_convert(val)\n            try:\n                return self.construct(val, i)\n            except Exception:\n                pass\n        except ParseInterrupt:\n            pass\n    raise ParseInterrupt\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.collect_errors","title":"<code>collect_errors(val)</code>","text":"<p>See <code>Converter.collect_errors</code></p> Source code in <code>pane/converters.py</code> <pre><code>def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n    \"\"\"See [`Converter.collect_errors`][pane.converters.Converter.collect_errors]\"\"\"\n    failed_children: t.List[ErrorNode] = []\n    for (i, conv) in enumerate(self.converters):\n        # if one branch is successful, the whole type is successful\n        try:\n            conv_val = conv.try_convert(val)\n        except ParseInterrupt:\n            failed_children.append(t.cast(t.Union[ProductErrorNode, WrongTypeError], conv.collect_errors(val)))\n            continue\n        try:\n            self.construct(conv_val, i)\n            return None\n        except Exception as e:\n            tb = e.__traceback__.tb_next  # type: ignore\n            tb = traceback.TracebackException(type(e), e, tb)\n            failed_children.append(WrongTypeError(self.expected(), val, tb))\n    return SumErrorNode(failed_children)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.construct","title":"<code>construct(val, i)</code>","text":"Source code in <code>pane/converters.py</code> <pre><code>def construct(self, val: t.Any, i: int) -&gt; t.Any:\n    if self.constructor is None:\n        return val\n    return self.constructor(val, i)\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.expected","title":"<code>expected(plural=False)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def expected(self, plural: bool = False) -&gt; str:\n    inner = self.converters[0].expected(plural)\n    return f\"{inner} or sequence of {inner}\"\n</code></pre>"},{"location":"api/types/#pane.types.ValueOrListConverter.into_data","title":"<code>into_data(val)</code>","text":"Source code in <code>pane/types.py</code> <pre><code>def into_data(self, val: t.Any) -&gt; DataType:\n    if not isinstance(val, ValueOrList):\n        return into_data(val)\n    return t.cast(ValueOrList[t.Any], val).map(\n        lambda v: into_data(v, self.ty)\n    )._inner\n</code></pre>"},{"location":"api/types/#pane.types.YAMLDocList","title":"<code>YAMLDocList</code>","text":"<p>               Bases: <code>list</code></p> <p><code>list</code> subclass representing a list of objects from YAML documents.</p> Source code in <code>pane/types.py</code> <pre><code>class YAMLDocList(list):  # type: ignore\n    \"\"\"\n    `list` subclass representing a list of objects from YAML documents.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/util/","title":"pane.util","text":""},{"location":"api/util/#pane.util","title":"<code>pane.util</code>","text":""},{"location":"api/util/#pane.util.P","title":"<code>P = ParamSpec('P')</code>  <code>module-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache","title":"<code>KeyCache</code>","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>pane/util.py</code> <pre><code>class KeyCache(t.Generic[P, T]):\n    _missing = object()\n\n    def __init__(self, f: t.Callable[P, T], key_f: t.Callable[P, t.Any], maxsize: t.Optional[int] = None):\n        self.maxsize: t.Optional[int] = maxsize\n        self.key_f: t.Callable[P, t.Any] = key_f\n        self.inner_f: t.Callable[P, T] = f\n        self.cache: t.Dict[t.Tuple[t.Tuple[t.Any, ...], t.Tuple[t.Tuple[str, t.Any], ...]], t.Any] = {}\n\n        self._root: t.List[t.Any] = []\n        self._root[:] = [self._root, self._root, None, None]\n        self._lock = RLock()\n\n        self.full = self.maxsize == 0\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        if self.maxsize is None:\n            key = self.key_f(*args, **kwargs)\n            result = self.cache.get(key, self._missing)\n            if result is not self._missing:\n                return t.cast(T, result)\n            result = self.inner_f(*args, **kwargs)\n            self.cache[key] = result\n            return result\n\n        key = self.key_f(*args, **kwargs)\n        with self._lock:\n            link = self.cache.get(key, None)\n            if link is not None:\n                # extract this link\n                prev_link, next_link, _key, result = link\n                prev_link[NEXT] = next_link\n                next_link[PREV] = prev_link\n\n                # and move it to the end of the list\n                last = self._root[PREV]\n                last[NEXT] = self._root[PREV] = link\n                link[PREV] = last\n                link[NEXT] = self._root\n                return t.cast(T, result)\n\n        result = self.inner_f(*args, **kwargs)\n        with self._lock:\n            if key in self.cache:\n                pass\n            elif self.full:\n                # turn the oldest link into the new root\n                # and reuse oldroot on the end of the list\n                oldroot = self._root\n                oldroot[KEY] = key\n                oldroot[RESULT] = result\n\n                self._root = oldroot[NEXT]\n                oldkey = self._root[KEY]\n                oldresult = self._root[RESULT]  # type: ignore # noqa: F841 (we want to keep this around for a bit)\n                self._root[KEY] = self._root[RESULT] = None\n                del self.cache[oldkey]\n                self.cache[key] = oldroot\n            else:\n                last = self._root[PREV]\n                link = [last, self._root, key, result]\n                last[NEXT] = self._root[PREV] = self.cache[key] = link\n                self.full = (len(self.cache) &gt;= self.maxsize)\n        return result\n</code></pre>"},{"location":"api/util/#pane.util.KeyCache.maxsize","title":"<code>maxsize = maxsize</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.key_f","title":"<code>key_f = key_f</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.inner_f","title":"<code>inner_f = f</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.cache","title":"<code>cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.KeyCache.full","title":"<code>full = self.maxsize == 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/util/#pane.util.partition","title":"<code>partition(f, iter)</code>","text":"<p>Partition <code>iter</code> into values that satisfy <code>f</code> and those which don't.</p> Source code in <code>pane/util.py</code> <pre><code>def partition(f: t.Callable[[T], bool], iter: t.Iterable[T]) -&gt; t.Tuple[t.Tuple[T, ...], t.Tuple[T, ...]]:\n    \"\"\"Partition `iter` into values that satisfy `f` and those which don't.\"\"\"\n    true: t.List[T] = []\n    false: t.List[T] = []\n    for val in iter:\n        if f(val):\n            true.append(val)\n        else:\n            false.append(val)\n    return (tuple(true), tuple(false))\n</code></pre>"},{"location":"api/util/#pane.util.pluralize","title":"<code>pluralize(word, plural, suffix='s', article=None)</code>","text":"<p>Pluralize <code>word</code> based on the value of <code>plural</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def pluralize(word: str, plural: t.Union[bool, int], suffix: str = 's', article: t.Optional[str] = None) -&gt; str:\n    \"\"\"Pluralize `word` based on the value of `plural`.\"\"\"\n    if not isinstance(plural, bool):\n        plural = plural != 1\n    article = article + \" \" if article is not None and len(article) else \"\"\n    return (word + suffix) if plural else (article + word)\n</code></pre>"},{"location":"api/util/#pane.util.list_phrase","title":"<code>list_phrase(words, conj='or')</code>","text":"<p>Form an english list phrase from <code>words</code>, using the conjunction <code>conj</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def list_phrase(words: t.Sequence[str], conj: str = 'or') -&gt; str:\n    \"\"\"\n    Form an english list phrase from `words`, using the conjunction `conj`.\n    \"\"\"\n    if len(words) &lt;= 2:\n        return f\" {conj} \".join(words)\n    return \", \".join(words[:-1]) + f\", {conj} {words[-1]}\"\n</code></pre>"},{"location":"api/util/#pane.util.remove_article","title":"<code>remove_article(s)</code>","text":"<p>Remove an article from <code>s</code>, if present.</p> Source code in <code>pane/util.py</code> <pre><code>def remove_article(s: str) -&gt; str:\n    \"\"\"Remove an article from `s`, if present.\"\"\"\n    s = s.lstrip()\n    for article in ('a ', 'an ', 'the '):\n        if s.startswith(article):\n            return s[len(article):]\n    return s\n</code></pre>"},{"location":"api/util/#pane.util.collect_typevars","title":"<code>collect_typevars(args)</code>","text":"<p>Collect a list of type variables in <code>args</code></p> <p>Preserves order but removes duplicates (i.e. type variables are returned in the order they are encountered, but no type variable is returned twice).</p> <p>Loosely based on <code>typing._collect_parameters</code>.</p> Source code in <code>pane/util.py</code> <pre><code>def collect_typevars(args: t.Any) -&gt; t.Tuple[t.Union[t.TypeVar, ParamSpec], ...]:\n    \"\"\"\n    Collect a list of type variables in `args`\n\n    Preserves order but removes duplicates (i.e. type variables are returned\n    in the order they are encountered, but no type variable is returned twice).\n\n    Loosely based on `typing._collect_parameters`.\n    \"\"\"\n    d: t.Dict[t.Union[t.TypeVar, ParamSpec], None] = {}  # relies on dicts preserving insertion order\n    _collect_typevars(d, args)\n    return tuple(d)\n</code></pre>"},{"location":"api/util/#pane.util.type_union","title":"<code>type_union(types)</code>","text":"Source code in <code>pane/util.py</code> <pre><code>def type_union(types: t.Iterable[type]) -&gt; type:\n    return functools.reduce(operator.or_, types)\n</code></pre>"},{"location":"api/util/#pane.util.flatten_union_args","title":"<code>flatten_union_args(types)</code>","text":"<p>Flatten nested unions, returning a single sequence of possible union types.</p> Source code in <code>pane/util.py</code> <pre><code>def flatten_union_args(types: t.Iterable[T]) -&gt; t.Iterator[T]:\n    \"\"\"Flatten nested unions, returning a single sequence of possible union types.\"\"\"\n    for ty in types:\n        if t.get_origin(ty) is t.Union:\n            yield from flatten_union_args(t.get_args(ty))\n        else:\n            yield ty\n</code></pre>"},{"location":"api/util/#pane.util.replace_typevars","title":"<code>replace_typevars(ty, replacements)</code>","text":"<p>Apply a list of type-variable replacements to <code>ty</code>, and return the modified type.</p> Source code in <code>pane/util.py</code> <pre><code>def replace_typevars(ty: t.Any,\n                     replacements: t.Mapping[t.Union[t.TypeVar, ParamSpec], type]) -&gt; t.Any:\n    \"\"\"\n    Apply a list of type-variable replacements to `ty`, and return the modified type.\n    \"\"\"\n    if isinstance(ty, (t.TypeVar, ParamSpec)):\n        return replacements.get(ty, ty)\n    if isinstance(ty, t.Sequence) and not isinstance(ty, (str, bytes)):\n        return type(ty)(replace_typevars(t, replacements) for t in ty)  # type: ignore\n\n    base = t.get_origin(ty) or ty\n    args = t.get_args(ty)\n\n    if not len(args):\n        return ty\n\n    args = (replace_typevars(ty, replacements) for ty in args)\n\n    if base is t.Union:\n        args = tuple(flatten_union_args(args))\n        # deduplicate union\n        args = dict.fromkeys(args).keys()\n\n        if len(args) == 1:\n            # single-element union, return as value\n            return next(iter(args))\n\n    return base[tuple(args)]  # type: ignore\n</code></pre>"},{"location":"api/util/#pane.util.get_type_hints","title":"<code>get_type_hints(cls)</code>","text":"<p>Extract a dict of type hints from <code>cls</code>. Evaluate forward refs if possible.</p> <p>This is a slightly modified version of typing.get_type_hints.</p> Source code in <code>pane/util.py</code> <pre><code>def get_type_hints(cls: type) -&gt; t.Dict[str, t.Any]:\n    \"\"\"\n    Extract a dict of type hints from `cls`. Evaluate forward refs if possible.\n\n    This is a slightly modified version of [typing.get_type_hints]().\n    \"\"\"\n\n    globalns = getattr(sys.modules.get(cls.__module__, None), '__dict__', {})\n    localns = dict(vars(cls))\n\n    d: t.Dict[str, t.Any] = {}\n    for name, value in cls.__dict__.get('__annotations__', {}).items():\n        if value is None:\n            value = type(None)\n        if isinstance(value, str):\n            value = t.ForwardRef(value, is_argument=False, is_class=True)\n        if isinstance(value, t.ForwardRef):\n            # hack to handle top-level KW_ONLY\n            val = value.__forward_value__ if value.__forward_evaluated__ else eval(value.__forward_code__, globalns, localns)\n            if val is KW_ONLY:\n                d[name] = KW_ONLY\n                continue\n        # private access inside typing module\n        value = t._eval_type(value, globalns, localns)  # type: ignore\n        d[name] = value\n\n    return d\n</code></pre>"},{"location":"api/util/#pane.util.broadcast_shapes","title":"<code>broadcast_shapes(*args)</code>","text":"<p>Attempt to broadcast the given shapes together using numpy semantics.</p> <p>Defers to <code>numpy.broadcast_shapes</code> if numpy is available.</p> Source code in <code>pane/util.py</code> <pre><code>def broadcast_shapes(*args: t.Sequence[int]) -&gt; t.Tuple[int, ...]:\n    \"\"\"\n    Attempt to broadcast the given shapes together using numpy semantics.\n\n    Defers to `numpy.broadcast_shapes` if numpy is available.\n    \"\"\"\n    try:\n        import numpy\n        return numpy.broadcast_shapes(*map(tuple, args))\n    except ImportError:\n        pass\n\n    # our own implementation, with worse error messages\n    out_shape: t.List[int] = []\n    for ax_lens in zip_longest(*(reversed(arg) for arg in args), fillvalue=1):\n        bcast = max(ax_lens)\n        if not all(ax_len in (1, bcast) for ax_len in ax_lens):\n            shapes = [f\"'{tuple(arg)!r}'\" for arg in args]\n            raise ValueError(f\"Couldn't broadcast shapes {list_phrase(shapes, 'and')}\")\n        out_shape.append(bcast)\n    return tuple(out_shape)\n</code></pre>"},{"location":"api/util/#pane.util.is_broadcastable","title":"<code>is_broadcastable(*args)</code>","text":"<p>Return whether <code>args</code> are broadcastable together using numpy semantics.</p> Source code in <code>pane/util.py</code> <pre><code>def is_broadcastable(*args: t.Sequence[int]) -&gt; bool:\n    \"\"\"Return whether `args` are broadcastable together using numpy semantics.\"\"\"\n    try:\n        broadcast_shapes(*args)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/util/#pane.util.key_cache","title":"<code>key_cache(key_f, *, maxsize=None)</code>","text":"Source code in <code>pane/util.py</code> <pre><code>def key_cache(key_f: t.Callable[P, t.Any], *, maxsize: t.Optional[int] = None) -&gt; t.Callable[[t.Callable[P, T]], KeyCache[P, T]]:\n    def inner(f: t.Callable[P, T]) -&gt; KeyCache[P, T]:\n        return t.cast(KeyCache[P, T], functools.update_wrapper(KeyCache(f, key_f, maxsize), f))\n\n    return inner\n</code></pre>"},{"location":"using/advanced/","title":"Under the hood: Advanced usage","text":""},{"location":"using/advanced/#custom-converters","title":"Custom converters","text":"<p>Out-of-the-box, <code>pane</code> supports <code>numpy</code> arrays and datatypes, as well as types which follow the <code>t.Sequence</code>/<code>t.Mapping</code> protocol.</p> <p>However, <code>pane</code> can easily be extended to support additional types. The first step is to create a <code>Converter</code> which handles the type. The <code>Converter</code> interface is quite simple. Three functions are required: <code>expected</code>, <code>try_convert</code>, and <code>collect_errors</code>.</p> <p>Say we have a type <code>CountryCode</code>, which contains a standard country code. <code>CountryCodeConverter</code> should accept a string-like type and convert it to a <code>CountryCode</code>, making sure that the string really is a country code. (In reality, this type could be implemented as <code>t.Literal['gb', 'cn', ...]</code>)</p> <p>An example implementation of <code>CountryCodeConverter</code> is shown below:</p> <pre><code>import typing as t\nfrom pane.errors import WrongTypeError, ErrorNode\n\nclass CountryCodeConverter:\n    countries = {'gb', 'us', 'cn', 'uk'}\n    def __init__(self, ty: t.Type[CountryCode]):\n        # type of CountrySet (could be a subclass)\n        self.ty = ty\n\n    def expected(self, plural: bool = False):\n        \"\"\"Return the value we expected (pluralized if `plural`).\"\"\"\n        return \"country codes\" if plural else \"a country code\"\n\n    # attempt to convert `val`.\n    # in this function, we only raise ParseInterrupt, never\n    # constructing an error\n    # this is to save time in case another conversion branch succeeds\n    def try_convert(self, val: t.Any) -&gt; CountryCode:\n        # the only data interchange type we support is `str`. Everything\n        # else should error\n        if not isinstance(val, str):\n            raise ParseInterrupt()\n\n        # check that `val` is a valid country code\n        if val not in self.countries:\n            raise ParseInterrupt()\n\n        return CountryCode(val)\n\n    # after try_convert fails, collect_errors is called\n    # to make full error messages.\n    # collect_errors should return an error iff try_convert raises ParseInterrupt\n    def collect_errors(self, val: t.Any) -&gt; t.Optional[ErrorNode]:\n        if not isinstance(val, str):\n            # every ParseInterrupt() in try_convert corresponds\n            # to an error in collect_errors\n            return WrongTypeError(self.expected(), val)\n\n        if val not in self.countries:\n            return WrongTypeError(self.expected(), val, info=f\"Unknown country code '{val}'\")\n\n        return None\n</code></pre> <p><code>expected</code> returns a brief string description of what values were expected by the converter. <code>try_convert</code> and <code>collect_errors</code> work together to perform parsing. When called with the same value, whenever <code>try_convert</code> succeeds, <code>collect_errors</code> should return <code>None</code>. Conversely, whenever <code>try_convert</code> raises a <code>ParseInterrupt</code>, <code>collect_errors</code> should return an <code>ErrorNode</code>. This means much of the same control flow should be present in both functions. However, <code>try_convert</code> is on the fast path; it should do as little work as possible, including avoiding constructing errors.</p> <p>With that said, There are a couple ways to inform <code>pane</code> of the presence of <code>CountryCodeConverter</code>. The simplest is through the <code>HasConverter</code> protocol. Just add a class method to <code>CountryCode</code>:</p> <pre><code>class CountryCode:\n    ...\n\n    @classmethod\n    def _converter(cls: t.Type[T], *args: type,\n                   handlers: ConverterHandlers) -&gt; CountryCodeConverter:\n        if len(args):\n            raise TypeError(\"'CountryCode' doesn't support type arguments\")\n        return CountryCodeConverter(cls)\n</code></pre> <p>In this protocol, any type arguments are passed to <code>args</code>. <code>handlers</code> contains a invocation-specific set of custom handlers. If you call <code>make_converter</code> inside of your <code>Converter</code>, you must pass <code>handlers</code> through to it.</p> <p>With that defined, <code>convert()</code>, <code>from_data()</code> and dataclasses will work seamlessly with <code>CountryCode</code>.</p>"},{"location":"using/advanced/#supporting-third-party-datatypes","title":"Supporting third-party datatypes","text":"<p>Sometimes you don't have access to a type to add a method to it. In these instances, you may instead add a global custom handler to <code>make_converter</code> using <code>register_converter_handler</code>. Say there's a type <code>Foo</code> that we'd like to support. First, we need to make a <code>FooConverter</code> (see Custom converters above). Next, we make a function called <code>foo_converter_handler</code>, and register it:</p> <pre><code>from pane.convert import register_converter_handler\n\n# called with the type to make a converter for, and any type arguments\ndef foo_converter_handler(ty: t.Any, args: t.Tuple[t.Any, ...], /, *\n                          handlers: ConverterHandlers) -&gt; FooConverter:\n    if not issubclass(ty, Foo):\n        return NotImplemented  # not a foo type, can't handle it\n    return FooConverter(ty, args)\n\nregister_converter_handler(foo_converter_handler)\n</code></pre> <p>Converter handlers can also be passed to <code>convert</code>, <code>into_data</code>, and <code>from_data</code> using the <code>custom</code> option:</p> <pre><code>foo = from_data({'foo': 'bar'}, Foo, custom=foo_converter_handler)\n</code></pre> <p><code>custom</code> may be a handler, a sequence of handlers (called in order), or a dict mapping types to <code>Converter</code>s.</p> <p>Local converter handlers are applied after special forms (e.g. <code>t.Union</code>), but before anything else. Global converter handlers are applied after basic type handlers and the <code>HasConverter</code> protocol (to increase performance), but before handlers for subclasses, <code>tuple</code>s, or <code>dict</code>s.</p>"},{"location":"using/advanced/#custom-annotations","title":"Custom annotations","text":"<p>Custom annotations are also supported. To create a custom annotation, subclass <code>ConvertAnnotation</code>. <code>_converter</code> will be called to construct a converter, with <code>inner_type</code> containing the type inside the annotation (or a <code>Converter</code> in the case of nested annotations). Raise a <code>TypeError</code> if <code>inner_type</code> isn't supported or understood by the annotation. <code>handlers</code> is a set of local converter handlers, which again must be passed through to any calls to <code>make_converter</code>.</p>"},{"location":"using/basic/","title":"Basic type conversion: <code>convert</code> &amp; friends","text":"<p>The core of <code>pane</code> is its data conversion routines. The simplest to use is <code>convert</code>:</p> <pre><code>&gt;&gt;&gt; import typing as t\n&gt;&gt;&gt; import pane\n&gt;&gt;&gt; pane.convert(-5., float)  # simple scalar type\n-5.0\n&gt;&gt;&gt; pane.convert([1., 'mystring', 5], (float, str, int))  # tuple-like type\n(1.0, 'mystring', 5)\n&gt;&gt;&gt; pane.convert({'x': 5.0, 'y': 'mystring'}, {'x': float, 'y': str})  # struct-like type\n{'x': 5.0, 'y': 'mystring'}\n&gt;&gt;&gt; pane.convert(5, t.Union[str, int, None])  # untagged union\n5\n</code></pre> <p><code>convert</code> actually performs two separate actions. First, it calls <code>into_data</code> on a value. This attempts to convert the value into a \"data interchange type\", which is a dialect of types supported by all converters.</p> <p>After <code>into_data</code>, <code>convert</code> calls <code>from_data</code>, which attempts to convert the value into the desired type.</p> <p>Currently, the data interchange types are:  - Scalar types: str, bytes, bool, int, float, complex, and None  - Sequences: list, tuple and <code>t.Sequence</code>  - Mappings: dict and <code>t.Mapping</code></p> <p>All implementations of <code>Converter.into_data</code> must output a data interchange type, and all implementations of <code>Converter</code> must handle any data interchange type (even if 'handle' just means returning an error). Data interchange types may be added in major releases, so <code>Converter</code> implementations should be made robust to new types.</p>"},{"location":"using/condition/","title":"<code>Condition</code>: Adding extra restrictions to types","text":"<p><code>Condition</code> is <code>pane</code>'s solution to field validation. In <code>pane</code>, features are built into the type system whenever possible, increasing composibility and flexibility. So to with value restrictions. These are implemented using <code>t.Annotated</code>.</p> <p>We'll start with some examples:</p> <pre><code>&gt;&gt;&gt; import typing as t\n&gt;&gt;&gt; from pane import convert, val_range, Condition, Positive\n\n# built-in conditions\n&gt;&gt;&gt; convert(5.0, t.Annotated[float, Positive])\n5.0\n\n&gt;&gt;&gt; convert(-1.0, t.Annotated[float, Positive])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected a positive float, instead got `-1.0` (failed condition 'positive')\n\n&gt;&gt;&gt; convert(6.0, t.Annotated[float, val_range(max=5.0)])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected a float satisfying v &lt;= 5.0, instead got `6.0` (failed condition 'v &lt;= 5.0')\n\n# custom conditions\n&gt;&gt;&gt; convert([0, 1, 2, 4], t.List[t.Annotated[int, Condition(lambda v: v % 2 == 0, name='even')]])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected sequence of ints satisfying even\nWhile parsing field '1':\n  Expected an int satisfying even, instead got `1` (failed condition 'even')\n</code></pre> <p>These conditions can be applied at any nesting level, not limited to top-level fields. Conditions also support the <code>&amp;</code> and <code>|</code> bitwise operators (interpreted as boolean operators).</p>"},{"location":"using/dataclasses/","title":"Dataclasses","text":"<p><code>pane</code> dataclasses work similarly to many other libraries. They aim to have a superset of the features of the standard library dataclasses. A dataclass can be made by subclassing <code>pane.PaneBase</code>:</p> <pre><code>import pane\nfrom typing import t\n\nclass MyDataclass(pane.PaneBase):\n    x: int = 5  # basic field w/ default\n    y: t.Optional[float] = None\n    # remaining fields should be keyword only\n    _: pane.KW_ONLY  \n    # advanced field specification\n    z: t.List[float] = pane.field(aliases=('w',), default_factory=list)\n    # apply custom logic to a field\n    w: str = pane.field(converter=CustomConverter())\n</code></pre>"},{"location":"using/dataclasses/#constructors","title":"Constructors","text":"<p><code>pane</code> automatically makes constructors for you:</p> <pre><code>&gt;&gt;&gt; import inspect; inspect.signature(MyDataclass.__init__)\n&lt;Signature (x: int = 5, y: Optional[float] = None, *, z: list[float] = []) -&gt; None&gt;\n</code></pre> <p><code>MyDataclass.__init__</code> performs conversion on arguments:</p> <pre><code>&gt;&gt;&gt; MyDataclass()\nMyDataclass(x=5, y=None, z=[])\n\n&gt;&gt;&gt; MyDataclass(z=[5.0, 10.0, 's'])\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected sequence of floats\nWhile parsing field '2':\n  Expected a float, instead got `s` of type `str`\n</code></pre> <p>To bypass conversion, use <code>Mydataclass.make_unchecked</code> instead:</p> <pre><code>&gt;&gt;&gt; MyDataclass.make_unchecked(z=[5.0, 10.0, 's'])\nMyDataclass(x=5, y=None, z=[5.0, 10.0, 's'])\n</code></pre> <p>Like regular dataclasses, <code>__post_init__</code> is called on construction, allowing extra validation logic and initializing <code>init=False</code> fields.</p> <p><code>MyDataclass.from_obj</code>, <code>MyDataclass.from_data</code>, <code>MyDataclass.from_json</code>, and <code>MyDataclass.from_yaml</code> perform conversion from an object:</p> <pre><code># note the use of an alias for 'z'\n&gt;&gt;&gt; MyDataclass.from_data({'x': 10, 'y': 10., 'w': [10.]})\nMyDataclass(x=10, y=10.0, z=[10.0])\n\n&gt;&gt;&gt; from io import StringIO\n&gt;&gt;&gt; MyDataclass.from_json(StringIO('{\"x\": 10, \"y\": 10.0, \"w\": [10.0]}'))\nMyDataclass(x=10, y=10.0, z=[10.0])\n</code></pre> <p>(<code>from_json</code> and <code>from_yaml</code> take a file-like object or filename. <code>from_jsons</code> and <code>from_yamls</code> take a string).</p>"},{"location":"using/dataclasses/#member-methods","title":"Member methods","text":"<p><code>MyDataclass.into_data</code> performs the reverse operation, converting a dataclass to a data interchange type (usually a dict):</p> <pre><code>&gt;&gt;&gt; MyDataclass(x=10, y=10.0, z=[10.0]).into_data()\n{'x': 10, 'y': 10.0, 'z': [10.0]}\n</code></pre> <p><code>MyDataclass.dict</code> returns a dictionary containing the fields, using their Python names. <code>set_only</code> may be specified to return only explicitly set fields, and <code>rename</code> may be specified to return using differently-styled names:</p>"},{"location":"using/dataclasses/#index-of-methods","title":"Index of methods","text":"Method name Method type Description <code>__init__</code> classmethod Instantiate a dataclass from data <code>make_unchecked</code> classmethod Instantiate a dataclass from data <code>from_obj</code> classmethod Instantiate a dataclass from a convertible object <code>from_data</code> classmethod Instantiate a dataclass from interchange data <code>from_json</code> classmethod Instantiate a dataclass from a JSON file <code>from_yaml</code> classmethod Instantiate a dataclass from a YAML file <code>from_jsons</code> classmethod Instantiate a dataclass from a JSON string <code>from_yamls</code> classmethod Instantiate a dataclass from a YAML string <code>into_data</code> instance method Convert dataclass into interchange data <code>dict</code> instance method Return dataclass fields as a dict (optionally, return only set fields)"},{"location":"using/dataclasses/#class-arguments","title":"Class arguments","text":"<p>Dataclass behavior can be customized using arguments passed to the class constructor. The following arguments are supported:</p> <p>Args:</p> <ul> <li>name (<code>str</code>): Name of the class, used in error messages.</li> <li><code>out_format</code> (<code>ClassLayout</code>): Format to serialize class in (default: <code>struct</code>)</li> <li><code>in_format</code> (<code>t.Sequence[ClassLayout]</code>): Formats class may be serialized from (default: <code>['struct', 'tuple']</code> if no keyword arguments, else <code>['struct']</code>)</li> <li><code>eq</code> (<code>bool</code>): Whether to add <code>__eq__</code> method</li> <li><code>order</code> (<code>bool</code>): Whether to add <code>__ord__</code> method</li> <li><code>frozen</code> (<code>bool</code>): Whether to freeze dataclass</li> <li><code>init</code> (<code>bool</code>): Whether to add <code>__init__</code> method</li> <li><code>kw_only</code> (<code>bool</code>): If true, make all parameters keyword-only</li> <li><code>rename</code> (<code>RenameStyle</code>): How to rename parameters upon conversion to data. Cannot be specified with <code>in_rename</code> or <code>out_rename</code></li> <li><code>in_rename</code> (<code>RenameStyle</code> or <code>t.Sequence[RenameStyle]</code>): Allow inputs renamed from these formats</li> <li><code>out_rename</code> (<code>RenameStyle</code>): Output renamed to this format</li> <li><code>allow_extra</code> (bool): Whether to allow (and ignore) extra parameters</li> <li><code>custom</code> (<code>IntoConverterHandlers</code>): Custom handlers to apply to members of this class. Can be a handler, a list of handlers, or a dict mapping types to converters.</li> </ul> <p>In general, these arguments are inherited by subclasses, unless overridden.</p>"},{"location":"using/dataclasses/#generic-classes","title":"Generic classes","text":"<p>Generic classes are supported natively, with proper inheritance.</p>"},{"location":"using/tagged/","title":"Tagged unions","text":"<p><code>pane</code> supports parsing tagged unions, which are invaluable in representing complex data types. Unlike a untagged union (represented by <code>t.Union</code>), tagged unions use a discriminating value to separate variants unambiguously.</p> <p>Tagged unions are specified with the <code>Tagged</code> annotation wrapping a <code>t.Union</code>:</p> <pre><code>import pane\nfrom pane.annotations import Tagged\n\nclass Variant1(pane.PaneBase):\n    x: t.Literal['variant1'] = 'variant1'\n    y: int = 6\n\nclass Variant2(pane.PaneBase):\n    x: t.Literal['variant2'] = 'variant2'\n    y: str = 'mystring'\n\nclass Variant3(pane.PaneBase):\n    x: t.Literal['variant3'] = 'variant3'\n    y: int = 6\n    z: int = 7\n\nTaggedUnion = t.Annotated[t.Union[Variant1, Variant2, Variant3], Tagged('x')]\n</code></pre> <p>This specifies a tagged union with a tag (in Python) of <code>'x'</code>. Attribute <code>'x'</code> is examined for each variant type, so that every possible value is uniquely associated with a type.</p> <p>When converting a value, the tag is matched first, and then the variant corresponding to that tag:</p> <pre><code>&gt;&gt;&gt; pane.convert({'x': 'variant3'}, TaggedUnion)\nVariant3(x='variant3', y=6, z=7)\n\n&gt;&gt;&gt; pane.convert({'x': 'variant2', 'y': 'str'}, TaggedUnion)\nVariant2(x='variant2', y='str')\n\n&gt;&gt;&gt; pane.convert({'x': 'unknown'}, TaggedUnion)\nTraceback (most recent call last):\n...\npane.errors.ConvertError: Expected tag 'x' one of 'variant1', 'variant2', or 'variant3', instead got `unknown` of type `str`\n</code></pre> <p>Note that if we had used an untagged union instead, we would have no way to distinguish between <code>Variant1</code> and <code>Variant3</code> in general.</p>"},{"location":"using/tagged/#tagged-union-layouts","title":"Tagged Union Layouts","text":"<p>By default, tagged unions are stored in the 'internally tagged' format, where tags are stored alongside the variant's values.</p> <p>Two other layouts are possible. First, the 'externally tagged' layout:</p> <pre><code>&gt;&gt;&gt; ExtTagged = t.Annotated[t.Union[Variant1, Variant2], Tagged('x', external=True)]\n&gt;&gt;&gt; pane.convert({'variant2': {'y': 'str'}}, ExtTagged)\nVariant2(x='variant2', y='str')\n</code></pre> <p>In this format, the tag is stored as the sole key in a mapping enclosing the variant object. The externally tagged format is often used by functional, type-safe languages such as Rust.</p> <p>The final layout is the 'adjacently tagged' layout:</p> <pre><code>&gt;&gt;&gt; AdjTagged = t.Annotated[t.Union[Variant1, Variant2], Tagged('x', external=('t', 'c'))]\n&gt;&gt;&gt; pane.convert({'t': 'variant1', 'c': {'y': 8}}, AdjTagged)\nVariant1(x='variant1', y=8)\n</code></pre> <p>In this format, the tag and content are stored alongside each other in a mapping. The tuple <code>('t', 'c')</code> specifies the keys identifying the tag and content respectively. This format is often used in Haskell.</p> <p>These tagged union layouts (along with untagged unions) are modeled after the enum representations in Rust's <code>serde</code> library.</p>"}]}